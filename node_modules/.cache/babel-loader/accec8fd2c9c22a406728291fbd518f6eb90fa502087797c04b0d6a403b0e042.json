{"ast":null,"code":"/**\n * Process text to extract bracket content\n */\nexport const processBracketSeparation = input => {\n  if (typeof input === 'string') {\n    const bracketRegex = /\\[(.*?)\\]|\\((.*?)\\)|\\{(.*?)\\}/g;\n    const matches = [];\n    const matchDetails = [];\n    let match;\n    while ((match = bracketRegex.exec(input)) !== null) {\n      const value = match[1] || match[2] || match[3];\n      if (value) {\n        matches.push(value);\n\n        // Store metadata about the match\n        matchDetails.push({\n          value,\n          bracketType: match[1] ? 'square' : match[2] ? 'round' : 'curly',\n          fullMatch: match[0],\n          // The full match including brackets\n          startIndex: match.index,\n          endIndex: match.index + match[0].length\n        });\n      }\n    }\n\n    // Clean the original string by removing all brackets\n    const cleanedOriginal = input.replace(/\\[.*?\\]|\\(.*?\\)|\\{.*?\\}/g, '').replace(/\\s+/g, ' ').trim();\n    return {\n      original: input,\n      cleaned: cleanedOriginal,\n      separated: matches,\n      matchDetails: matchDetails,\n      type: 'bracket-separation'\n    };\n  } else if (Array.isArray(input)) {\n    return input.map(item => processBracketSeparation(item));\n  } else if (typeof input === 'object' && input !== null) {\n    const result = {};\n    for (const key in input) {\n      result[key] = processBracketSeparation(input[key]);\n    }\n    return result;\n  }\n  return input;\n};\n\n/**\n * Process text to separate by delimiters\n */\nexport const processDelimiterSeparation = (input, delimiters) => {\n  // Sort delimiters by order property\n  const activeDelimiters = delimiters.filter(d => d.enabled).sort((a, b) => a.order - b.order).map(d => d.value);\n  if (typeof input === 'string') {\n    let parts = [input];\n\n    // Process each delimiter in sequence\n    activeDelimiters.forEach(delimiter => {\n      // Create a new array to store results after splitting by current delimiter\n      const newParts = [];\n      parts.forEach(part => {\n        // Escape special regex characters in delimiter\n        const escapedDelimiter = delimiter.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        const regex = new RegExp(`(${escapedDelimiter})`, 'g');\n\n        // Split by current delimiter and add non-empty parts to the result\n        part.split(regex).filter(p => p.trim() !== '' && p.trim() !== delimiter).forEach(p => newParts.push(p));\n      });\n\n      // Update parts for next delimiter\n      parts = newParts;\n    });\n    return {\n      original: input,\n      separated: parts.map(part => ({\n        value: part,\n        source: 'delimiter'\n      })),\n      type: 'delimiter-separation'\n    };\n  } else if (input && input.type === 'bracket-separation') {\n    // Get bracket details for later use\n    const bracketDetails = input.matchDetails || [];\n\n    // Process the original text with delimiter separation\n    // Use the cleaned text (without brackets) if available\n    const textToProcess = input.cleaned || input.original;\n    let cleanTextParts = [];\n\n    // Process clean text (text without brackets)\n    if (textToProcess.trim().length > 0) {\n      // Split by commas first if they exist\n      if (textToProcess.includes(',')) {\n        cleanTextParts = textToProcess.split(',').map(part => part.trim()).filter(part => part.length > 0);\n      } else {\n        // Otherwise just use the whole text\n        cleanTextParts = [textToProcess];\n      }\n    }\n\n    // Process clean text parts with delimiters\n    let processedCleanTextParts = [];\n\n    // Process each delimiter in sequence\n    cleanTextParts.forEach(textPart => {\n      let parts = [textPart];\n      activeDelimiters.forEach(delimiter => {\n        if (delimiter === ',') return; // Skip comma as we already processed it\n\n        const newParts = [];\n        parts.forEach(part => {\n          const escapedDelimiter = delimiter.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n          const regex = new RegExp(`(${escapedDelimiter})`, 'g');\n          part.split(regex).filter(p => p.trim() !== '' && p.trim() !== delimiter).forEach(p => newParts.push(p));\n        });\n        parts = newParts;\n      });\n      processedCleanTextParts = [...processedCleanTextParts, ...parts];\n    });\n\n    // Process bracket values separately\n    const bracketSeparated = [];\n    if (input.separated) {\n      input.separated.forEach((val, index) => {\n        // Get the original bracket info\n        const bracketInfo = bracketDetails[index];\n\n        // Process each bracket value with delimiters\n        let bracketParts = [val];\n        activeDelimiters.forEach(delimiter => {\n          if (delimiter === ',') return; // Skip comma as we already processed it\n\n          const newParts = [];\n          bracketParts.forEach(part => {\n            const escapedDelimiter = delimiter.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n            const regex = new RegExp(`(${escapedDelimiter})`, 'g');\n            part.split(regex).filter(p => p.trim() !== '' && p.trim() !== delimiter).forEach(p => newParts.push(p));\n          });\n          bracketParts = newParts;\n        });\n\n        // Add each part with the original bracket info\n        if (bracketParts.length <= 1) {\n          // If no splitting occurred, add the original value\n          bracketSeparated.push({\n            value: val,\n            source: 'bracket',\n            bracketInfo: bracketInfo\n          });\n        } else {\n          // Add each split part with original bracket info\n          bracketParts.forEach((part, partIdx) => {\n            bracketSeparated.push({\n              value: part,\n              source: 'bracket',\n              bracketInfo: bracketInfo,\n              // Indicate this is a part of a split bracket value\n              isSplitPart: true,\n              partIndex: partIdx,\n              totalParts: bracketParts.length\n            });\n          });\n        }\n      });\n    }\n\n    // Add processed clean text parts\n    const cleanTextSeparated = processedCleanTextParts.map(part => ({\n      value: part,\n      source: 'clean-text'\n    }));\n\n    // Combine all parts (do not remove duplicates to preserve original order)\n    const allParts = [...cleanTextSeparated, ...bracketSeparated];\n    return {\n      original: input.original,\n      cleaned: input.cleaned,\n      separated: allParts,\n      type: 'delimiter-separation',\n      previous: {\n        type: input.type,\n        separated: input.separated,\n        matchDetails: input.matchDetails\n      }\n    };\n  } else if (Array.isArray(input)) {\n    return input.map(item => processDelimiterSeparation(item, delimiters));\n  } else if (typeof input === 'object' && input !== null) {\n    const result = {};\n    for (const key in input) {\n      result[key] = processDelimiterSeparation(input[key], delimiters);\n    }\n    return result;\n  }\n  return input;\n};\n\n/**\n * Flatten data structure to generate simple rows for display\n */\nexport const flattenData = (data, path = '', rows = []) => {\n  if (!data) return rows;\n  if (data.type === 'bracket-separation' || data.type === 'delimiter-separation') {\n    rows.push({\n      path,\n      original: data.original,\n      separated: data.separated,\n      type: data.type,\n      previous: data.previous,\n      matchDetails: data.matchDetails || (data.previous ? data.previous.matchDetails : null)\n    });\n  } else if (data.type === 'substring-grouping') {\n    // For substring grouping, preserve the groups and substrings\n    rows.push({\n      path,\n      original: data.original,\n      groups: data.groups,\n      substrings: data.substrings,\n      type: data.type,\n      previous: data.previous\n    });\n  } else if (data.type === 'substring-segmentation') {\n    // For substring segmentation, preserve the segmentation data\n    rows.push({\n      path,\n      original: data.original,\n      separated: data.separated,\n      type: data.type,\n      previous: data.previous\n    });\n  } else if (Array.isArray(data)) {\n    data.forEach((item, index) => {\n      const itemPath = path ? `${path}[${index}]` : `[${index}]`;\n      flattenData(item, itemPath, rows);\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    Object.entries(data).forEach(([key, value]) => {\n      const keyPath = path ? `${path}.${key}` : key;\n      flattenData(value, keyPath, rows);\n    });\n  } else if (path) {\n    // Simple value\n    rows.push({\n      path,\n      original: data,\n      separated: []\n    });\n  }\n  return rows;\n};\n\n/**\n * Process data to group by common substrings (prefixes or suffixes)\n */\nexport const processSubstringGrouping = (input, config) => {\n  const {\n    includeBrackets,\n    minSubstringLength,\n    minFrequency\n  } = config;\n\n  // Preserve the original data structure for display purposes\n  let originalData = input;\n  let previousSeparated = [];\n  if (input.type === 'delimiter-separation' || input.type === 'bracket-separation') {\n    originalData = input.original;\n    previousSeparated = input.separated || [];\n  }\n\n  // Extract all values to group\n  const extractValues = data => {\n    if (!data) return [];\n    if (Array.isArray(data)) {\n      return data.flatMap(extractValues);\n    } else if (typeof data === 'object' && data !== null) {\n      if (data.separated && Array.isArray(data.separated)) {\n        // This is a processed row with separated values\n        return data.separated.filter(item => {\n          // Skip bracket items if not including brackets\n          if (!includeBrackets && item.source === 'bracket') {\n            return false;\n          }\n          return true;\n        }).map(item => typeof item === 'string' ? item : item.value);\n      } else if (data.type === 'delimiter-separation' || data.type === 'bracket-separation') {\n        // If this is already a processed row but we didn't catch it above\n        if (data.separated && Array.isArray(data.separated)) {\n          return data.separated.filter(item => includeBrackets || item.source !== 'bracket').map(item => typeof item === 'string' ? item : item.value);\n        }\n        return [];\n      } else {\n        // Recursively extract from nested objects\n        return Object.values(data).flatMap(extractValues);\n      }\n    } else if (typeof data === 'string') {\n      return [data];\n    }\n    return [];\n  };\n\n  // Get all unique values\n  const allValues = extractValues(input);\n  const uniqueValues = [...new Set(allValues)].filter(val => val && val.trim().length >= minSubstringLength);\n\n  // Filter out substrings that are contained within others with the same frequency\n  const filterSubstrings = substrings => {\n    const result = [];\n\n    // Group by frequency first\n    const freqGroups = new Map();\n    for (const [substring, count] of substrings) {\n      if (!freqGroups.has(count)) {\n        freqGroups.set(count, []);\n      }\n      freqGroups.get(count).push(substring);\n    }\n\n    // For each frequency group, filter out contained substrings\n    for (const [count, substrs] of freqGroups.entries()) {\n      // Sort by length (longest first)\n      substrs.sort((a, b) => b.length - a.length);\n      const filtered = [];\n      for (const substr of substrs) {\n        // Check if this substring is contained in any already filtered string\n        const isContained = filtered.some(existing => existing.includes(substr) && existing !== substr);\n        if (!isContained) {\n          filtered.push(substr);\n        }\n      }\n\n      // Add filtered substrings with their counts\n      for (const substr of filtered) {\n        result.push([substr, count]);\n      }\n    }\n    return result;\n  };\n\n  // Find common prefixes with filtering\n  const findPrefixes = values => {\n    const prefixMap = new Map();\n\n    // Count all possible prefixes\n    values.forEach(value => {\n      if (typeof value !== 'string' || !value) return;\n      for (let length = minSubstringLength; length <= value.length; length++) {\n        const prefix = value.substring(0, length);\n        prefixMap.set(prefix, (prefixMap.get(prefix) || 0) + 1);\n      }\n    });\n\n    // Get candidates and filter by minimum frequency\n    const candidates = [...prefixMap.entries()].filter(([prefix, count]) => count >= minFrequency).sort((a, b) => {\n      // First by frequency (descending)\n      if (b[1] !== a[1]) return b[1] - a[1];\n      // Then by length (longer first)\n      return b[0].length - a[0].length;\n    });\n    return filterSubstrings(candidates);\n  };\n\n  // Find common suffixes with filtering\n  const findSuffixes = values => {\n    const suffixMap = new Map();\n\n    // Count all possible suffixes\n    values.forEach(value => {\n      if (typeof value !== 'string' || !value) return;\n      for (let length = minSubstringLength; length <= value.length; length++) {\n        const suffix = value.substring(value.length - length);\n        suffixMap.set(suffix, (suffixMap.get(suffix) || 0) + 1);\n      }\n    });\n\n    // Get candidates and filter by minimum frequency\n    const candidates = [...suffixMap.entries()].filter(([suffix, count]) => count >= minFrequency).sort((a, b) => {\n      // First by frequency (descending)\n      if (b[1] !== a[1]) return b[1] - a[1];\n      // Then by length (longer first)\n      return b[0].length - a[0].length;\n    });\n    return filterSubstrings(candidates);\n  };\n\n  // Find the most significant prefixes and suffixes\n  const prefixes = findPrefixes(uniqueValues);\n  const suffixes = findSuffixes(uniqueValues);\n\n  // Combine prefixes and suffixes, while avoiding duplicates\n  let combinedSubstrings = [...prefixes];\n  suffixes.forEach(([suffix, count]) => {\n    // Check if this suffix already exists in prefixes (avoid duplicates)\n    if (!prefixes.some(([prefix]) => prefix === suffix)) {\n      combinedSubstrings.push([suffix, count]);\n    }\n  });\n\n  // Sort by frequency and then by length\n  combinedSubstrings.sort((a, b) => {\n    // First by frequency (descending)\n    if (b[1] !== a[1]) return b[1] - a[1];\n    // Then by length (longer first)\n    return b[0].length - a[0].length;\n  });\n\n  // Group values by substring\n  const groupBySubstring = (values, substrings) => {\n    const result = {};\n    const ungrouped = [...values]; // Start with all values, remove as they get grouped\n\n    // Initialize groups\n    substrings.forEach(([substring]) => {\n      result[substring] = [];\n    });\n\n    // Assign values to groups\n    substrings.forEach(([substring]) => {\n      // Find values that match this substring\n      for (let i = ungrouped.length - 1; i >= 0; i--) {\n        const value = ungrouped[i];\n        if (typeof value !== 'string' || !value) continue;\n\n        // Check if value starts with or ends with the substring\n        if (value.startsWith(substring) || value.endsWith(substring)) {\n          result[substring].push(value);\n          ungrouped.splice(i, 1); // Remove from ungrouped\n        }\n      }\n    });\n\n    // Add the remaining ungrouped values\n    result['__ungrouped__'] = ungrouped.filter(v => typeof v === 'string' && v);\n    return result;\n  };\n\n  // Group values by substring\n  const groups = groupBySubstring(uniqueValues, combinedSubstrings);\n\n  // Return grouped data, including original data structure\n  return {\n    original: originalData,\n    separated: previousSeparated,\n    groups,\n    substrings: combinedSubstrings.map(([substring, count]) => ({\n      substring,\n      count\n    })),\n    ungrouped: groups['__ungrouped__'] || [],\n    type: 'substring-grouping',\n    previous: {\n      type: input.type,\n      separated: input.separated\n    }\n  };\n};\n\n/**\n * Process data to segment strings based on substrings contained in other strings\n */\nexport const processSubstringSegmentation = (input, config) => {\n  const {\n    minSubstringLength,\n    minOccurrence\n  } = config;\n\n  // Extract all values from input data\n  const extractAllValues = data => {\n    if (!data) return [];\n    if (Array.isArray(data)) {\n      return data.flatMap(extractAllValues);\n    } else if (typeof data === 'object' && data !== null) {\n      if (data.separated && Array.isArray(data.separated)) {\n        // Extract from processed data rows\n        return data.separated.map(item => typeof item === 'string' ? item : item.value);\n      } else {\n        // Recursively extract from nested objects\n        return Object.values(data).flatMap(extractAllValues);\n      }\n    } else if (typeof data === 'string') {\n      return [data];\n    }\n    return [];\n  };\n\n  // Find all strings from input\n  let allValues = [];\n  if (input.type === 'delimiter-separation' || input.type === 'bracket-separation') {\n    // Extract from already processed data\n    if (input.separated && Array.isArray(input.separated)) {\n      allValues = input.separated.map(item => typeof item === 'string' ? item : item.value);\n    } else {\n      allValues = extractAllValues(input);\n    }\n  } else if (Array.isArray(input)) {\n    allValues = input.flatMap(extractAllValues);\n  } else if (typeof input === 'object' && input !== null) {\n    allValues = Object.values(input).flatMap(extractAllValues);\n  }\n\n  // Filter out empty or too short strings\n  allValues = allValues.filter(val => typeof val === 'string' && val.trim().length >= minSubstringLength);\n\n  // Identify candidate substrings (those that appear in multiple values)\n  const candidateSubstrings = [];\n  const valueOccurrences = new Map();\n\n  // First pass: collect all possible substrings of sufficient length\n  allValues.forEach(value => {\n    if (typeof value !== 'string') return;\n\n    // Generate all possible substrings of sufficient length\n    for (let startIdx = 0; startIdx <= value.length - minSubstringLength; startIdx++) {\n      for (let endIdx = startIdx + minSubstringLength; endIdx <= value.length; endIdx++) {\n        const substring = value.substring(startIdx, endIdx);\n        if (substring.length >= minSubstringLength) {\n          const current = valueOccurrences.get(substring) || [];\n          // Only add unique values\n          if (!current.includes(value)) {\n            current.push(value);\n            valueOccurrences.set(substring, current);\n          }\n        }\n      }\n    }\n  });\n\n  // Filter substrings that appear in at least minOccurrence different values\n  valueOccurrences.forEach((values, substring) => {\n    if (values.length >= minOccurrence) {\n      candidateSubstrings.push({\n        substring,\n        occurrences: values.length,\n        values: values\n      });\n    }\n  });\n\n  // Sort by length (prefer longer substrings) and then by occurrences\n  candidateSubstrings.sort((a, b) => {\n    // Prefer longer substrings\n    if (b.substring.length !== a.substring.length) {\n      return b.substring.length - a.substring.length;\n    }\n    // If same length, prefer more occurrences\n    return b.occurrences - a.occurrences;\n  });\n\n  // Create segmentation info\n  const segmentations = new Map();\n\n  // Process each string to find segmentation points\n  allValues.forEach(value => {\n    if (typeof value !== 'string') return;\n\n    // Skip short strings\n    if (value.length < minSubstringLength * 2) {\n      segmentations.set(value, [{\n        text: value,\n        isSubstring: false\n      }]);\n      return;\n    }\n    const segments = [];\n    let remaining = value;\n    let startIndex = 0;\n    let madeChanges = true;\n\n    // Continue until no more changes can be made or we've processed the whole string\n    while (madeChanges && remaining.length > 0) {\n      madeChanges = false;\n\n      // Try to find matches from candidate substrings\n      for (const candidate of candidateSubstrings) {\n        const {\n          substring\n        } = candidate;\n\n        // Skip if this substring is the entire value\n        if (substring === value) continue;\n        const index = remaining.indexOf(substring);\n        if (index !== -1) {\n          // We found a match\n          madeChanges = true;\n\n          // Add segment before match if it exists\n          if (index > 0) {\n            segments.push({\n              text: remaining.substring(0, index),\n              isSubstring: false,\n              position: startIndex\n            });\n          }\n\n          // Add the matching substring\n          segments.push({\n            text: substring,\n            isSubstring: true,\n            position: startIndex + index\n          });\n\n          // Update remaining and startIndex\n          remaining = remaining.substring(index + substring.length);\n          startIndex += index + substring.length;\n\n          // Break out to restart with our new remaining string\n          break;\n        }\n      }\n    }\n\n    // Add any remaining text\n    if (remaining.length > 0) {\n      segments.push({\n        text: remaining,\n        isSubstring: false,\n        position: startIndex\n      });\n    }\n\n    // If no segmentation was found, just use the original value\n    if (segments.length === 0) {\n      segments.push({\n        text: value,\n        isSubstring: false,\n        position: 0\n      });\n    }\n\n    // Sort segments by position to ensure correct order\n    segments.sort((a, b) => a.position - b.position);\n\n    // Store segmentation for this value\n    segmentations.set(value, segments);\n  });\n\n  // Process the input to apply segmentations\n  const processWithSegmentations = data => {\n    if (!data) return data;\n    if (typeof data === 'string') {\n      return {\n        original: data,\n        segments: segmentations.get(data) || [{\n          text: data,\n          isSubstring: false\n        }],\n        type: 'substring-segmentation'\n      };\n    } else if (data.type === 'delimiter-separation' || data.type === 'bracket-separation') {\n      // Create a copy of the input but with segmented info\n      const result = {\n        ...data\n      };\n\n      // Add segmentation info to each separated item\n      if (result.separated && Array.isArray(result.separated)) {\n        // 브라켓 아이템과 일반 아이템 분리\n        const bracketItems = result.separated.filter(item => typeof item === 'object' && item.source === 'bracket');\n        const nonBracketItems = result.separated.filter(item => typeof item !== 'object' || item.source !== 'bracket');\n\n        // 각각 처리\n        const processedBracketItems = bracketItems.map(item => {\n          const value = typeof item === 'string' ? item : item.value;\n          const segments = segmentations.get(value) || [{\n            text: value,\n            isSubstring: false\n          }];\n          return {\n            ...item,\n            segments\n          };\n        });\n        const processedNonBracketItems = nonBracketItems.map(item => {\n          const value = typeof item === 'string' ? item : item.value;\n          const segments = segmentations.get(value) || [{\n            text: value,\n            isSubstring: false\n          }];\n          if (typeof item === 'string') {\n            return {\n              value,\n              segments,\n              source: 'text'\n            };\n          } else {\n            return {\n              ...item,\n              segments\n            };\n          }\n        });\n\n        // 브라켓 아이템을 원래 위치에 맞게 배치 - 원래 배열 순서 유지\n        let resultItems = [];\n        if (data.type === 'bracket-separation' && data.matchDetails) {\n          // 괄호 위치 정보가 있는 경우 위치 순서대로 배치\n          const bracketsByIndex = {};\n          processedBracketItems.forEach((item, idx) => {\n            if (item.bracketInfo && item.bracketInfo.startIndex !== undefined) {\n              bracketsByIndex[item.bracketInfo.startIndex] = item;\n            }\n          });\n\n          // 원래 배열에서의 순서를 유지\n          result.separated.forEach(originalItem => {\n            if (typeof originalItem === 'object' && originalItem.source === 'bracket') {\n              if (originalItem.bracketInfo && bracketsByIndex[originalItem.bracketInfo.startIndex]) {\n                resultItems.push(bracketsByIndex[originalItem.bracketInfo.startIndex]);\n              }\n            } else {\n              // 일반 아이템 중에서 찾기\n              const value = typeof originalItem === 'string' ? originalItem : originalItem.value;\n              const matchingItem = processedNonBracketItems.find(item => {\n                const itemValue = typeof item === 'string' ? item : item.value;\n                return itemValue === value;\n              });\n              if (matchingItem) {\n                resultItems.push(matchingItem);\n                // 이미 사용된 아이템 제거\n                processedNonBracketItems.splice(processedNonBracketItems.indexOf(matchingItem), 1);\n              }\n            }\n          });\n\n          // 남은 아이템 추가\n          resultItems = [...resultItems, ...processedNonBracketItems];\n        } else {\n          // 위치 정보가 없는 경우 원래 순서 유지\n          resultItems = result.separated.map(item => {\n            if (typeof item === 'object' && item.source === 'bracket') {\n              return processedBracketItems.find(b => b.value === item.value) || item;\n            } else {\n              const value = typeof item === 'string' ? item : item.value;\n              return processedNonBracketItems.find(b => {\n                const itemValue = typeof b === 'string' ? b : b.value;\n                return itemValue === value;\n              }) || item;\n            }\n          });\n        }\n        result.separated = resultItems;\n      }\n      result.type = 'substring-segmentation';\n      result.previous = {\n        type: data.type,\n        separated: data.separated,\n        matchDetails: data.matchDetails\n      };\n      return result;\n    } else if (Array.isArray(data)) {\n      return data.map(processWithSegmentations);\n    } else if (typeof data === 'object' && data !== null) {\n      const result = {};\n      for (const key in data) {\n        result[key] = processWithSegmentations(data[key]);\n      }\n      return result;\n    }\n    return data;\n  };\n  return {\n    segmentations: Array.from(segmentations.entries()).map(([value, segments]) => ({\n      value,\n      segments\n    })),\n    candidateSubstrings,\n    processed: processWithSegmentations(input)\n  };\n};","map":{"version":3,"names":["processBracketSeparation","input","bracketRegex","matches","matchDetails","match","exec","value","push","bracketType","fullMatch","startIndex","index","endIndex","length","cleanedOriginal","replace","trim","original","cleaned","separated","type","Array","isArray","map","item","result","key","processDelimiterSeparation","delimiters","activeDelimiters","filter","d","enabled","sort","a","b","order","parts","forEach","delimiter","newParts","part","escapedDelimiter","regex","RegExp","split","p","source","bracketDetails","textToProcess","cleanTextParts","includes","processedCleanTextParts","textPart","bracketSeparated","val","bracketInfo","bracketParts","partIdx","isSplitPart","partIndex","totalParts","cleanTextSeparated","allParts","previous","flattenData","data","path","rows","groups","substrings","itemPath","Object","entries","keyPath","processSubstringGrouping","config","includeBrackets","minSubstringLength","minFrequency","originalData","previousSeparated","extractValues","flatMap","values","allValues","uniqueValues","Set","filterSubstrings","freqGroups","Map","substring","count","has","set","get","substrs","filtered","substr","isContained","some","existing","findPrefixes","prefixMap","prefix","candidates","findSuffixes","suffixMap","suffix","prefixes","suffixes","combinedSubstrings","groupBySubstring","ungrouped","i","startsWith","endsWith","splice","v","processSubstringSegmentation","minOccurrence","extractAllValues","candidateSubstrings","valueOccurrences","startIdx","endIdx","current","occurrences","segmentations","text","isSubstring","segments","remaining","madeChanges","candidate","indexOf","position","processWithSegmentations","bracketItems","nonBracketItems","processedBracketItems","processedNonBracketItems","resultItems","bracketsByIndex","idx","undefined","originalItem","matchingItem","find","itemValue","from","processed"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/dataProcessors.js"],"sourcesContent":["/**\n * Process text to extract bracket content\n */\nexport const processBracketSeparation = (input) => {\n  if (typeof input === 'string') {\n    const bracketRegex = /\\[(.*?)\\]|\\((.*?)\\)|\\{(.*?)\\}/g;\n    const matches = [];\n    const matchDetails = [];\n    let match;\n    \n    while ((match = bracketRegex.exec(input)) !== null) {\n      const value = match[1] || match[2] || match[3];\n      if (value) {\n        matches.push(value);\n        \n        // Store metadata about the match\n        matchDetails.push({\n          value,\n          bracketType: match[1] ? 'square' : match[2] ? 'round' : 'curly',\n          fullMatch: match[0], // The full match including brackets\n          startIndex: match.index,\n          endIndex: match.index + match[0].length\n        });\n      }\n    }\n    \n    // Clean the original string by removing all brackets\n    const cleanedOriginal = input.replace(/\\[.*?\\]|\\(.*?\\)|\\{.*?\\}/g, '').replace(/\\s+/g, ' ').trim();\n    \n    return {\n      original: input,\n      cleaned: cleanedOriginal,\n      separated: matches,\n      matchDetails: matchDetails,\n      type: 'bracket-separation'\n    };\n  } else if (Array.isArray(input)) {\n    return input.map(item => processBracketSeparation(item));\n  } else if (typeof input === 'object' && input !== null) {\n    const result = {};\n    for (const key in input) {\n      result[key] = processBracketSeparation(input[key]);\n    }\n    return result;\n  }\n  \n  return input;\n};\n\n/**\n * Process text to separate by delimiters\n */\nexport const processDelimiterSeparation = (input, delimiters) => {\n  // Sort delimiters by order property\n  const activeDelimiters = delimiters\n    .filter(d => d.enabled)\n    .sort((a, b) => a.order - b.order)\n    .map(d => d.value);\n  \n  if (typeof input === 'string') {\n    let parts = [input];\n    \n    // Process each delimiter in sequence\n    activeDelimiters.forEach(delimiter => {\n      // Create a new array to store results after splitting by current delimiter\n      const newParts = [];\n      \n      parts.forEach(part => {\n        // Escape special regex characters in delimiter\n        const escapedDelimiter = delimiter.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        const regex = new RegExp(`(${escapedDelimiter})`, 'g');\n        \n        // Split by current delimiter and add non-empty parts to the result\n        part.split(regex)\n          .filter(p => p.trim() !== '' && p.trim() !== delimiter)\n          .forEach(p => newParts.push(p));\n      });\n      \n      // Update parts for next delimiter\n      parts = newParts;\n    });\n    \n    return {\n      original: input,\n      separated: parts.map(part => ({\n        value: part,\n        source: 'delimiter'\n      })),\n      type: 'delimiter-separation'\n    };\n  } else if (input && input.type === 'bracket-separation') {\n    // Get bracket details for later use\n    const bracketDetails = input.matchDetails || [];\n    \n    // Process the original text with delimiter separation\n    // Use the cleaned text (without brackets) if available\n    const textToProcess = input.cleaned || input.original;\n    \n    let cleanTextParts = [];\n    \n    // Process clean text (text without brackets)\n    if (textToProcess.trim().length > 0) {\n      // Split by commas first if they exist\n      if (textToProcess.includes(',')) {\n        cleanTextParts = textToProcess.split(',')\n          .map(part => part.trim())\n          .filter(part => part.length > 0);\n      } else {\n        // Otherwise just use the whole text\n        cleanTextParts = [textToProcess];\n      }\n    }\n    \n    // Process clean text parts with delimiters\n    let processedCleanTextParts = [];\n    \n    // Process each delimiter in sequence\n    cleanTextParts.forEach(textPart => {\n      let parts = [textPart];\n      \n      activeDelimiters.forEach(delimiter => {\n        if (delimiter === ',') return; // Skip comma as we already processed it\n        \n        const newParts = [];\n        \n        parts.forEach(part => {\n          const escapedDelimiter = delimiter.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n          const regex = new RegExp(`(${escapedDelimiter})`, 'g');\n          \n          part.split(regex)\n            .filter(p => p.trim() !== '' && p.trim() !== delimiter)\n            .forEach(p => newParts.push(p));\n        });\n        \n        parts = newParts;\n      });\n      \n      processedCleanTextParts = [...processedCleanTextParts, ...parts];\n    });\n    \n    // Process bracket values separately\n    const bracketSeparated = [];\n    \n    if (input.separated) {\n      input.separated.forEach((val, index) => {\n        // Get the original bracket info\n        const bracketInfo = bracketDetails[index];\n        \n        // Process each bracket value with delimiters\n        let bracketParts = [val];\n        \n        activeDelimiters.forEach(delimiter => {\n          if (delimiter === ',') return; // Skip comma as we already processed it\n          \n          const newParts = [];\n          \n          bracketParts.forEach(part => {\n            const escapedDelimiter = delimiter.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n            const regex = new RegExp(`(${escapedDelimiter})`, 'g');\n            \n            part.split(regex)\n              .filter(p => p.trim() !== '' && p.trim() !== delimiter)\n              .forEach(p => newParts.push(p));\n          });\n          \n          bracketParts = newParts;\n        });\n        \n        // Add each part with the original bracket info\n        if (bracketParts.length <= 1) {\n          // If no splitting occurred, add the original value\n          bracketSeparated.push({\n            value: val,\n            source: 'bracket',\n            bracketInfo: bracketInfo\n          });\n        } else {\n          // Add each split part with original bracket info\n          bracketParts.forEach((part, partIdx) => {\n            bracketSeparated.push({\n              value: part,\n              source: 'bracket',\n              bracketInfo: bracketInfo,\n              // Indicate this is a part of a split bracket value\n              isSplitPart: true,\n              partIndex: partIdx,\n              totalParts: bracketParts.length\n            });\n          });\n        }\n      });\n    }\n    \n    // Add processed clean text parts\n    const cleanTextSeparated = processedCleanTextParts.map(part => ({\n      value: part,\n      source: 'clean-text'\n    }));\n    \n    // Combine all parts (do not remove duplicates to preserve original order)\n    const allParts = [...cleanTextSeparated, ...bracketSeparated];\n    \n    return {\n      original: input.original,\n      cleaned: input.cleaned,\n      separated: allParts,\n      type: 'delimiter-separation',\n      previous: {\n        type: input.type,\n        separated: input.separated,\n        matchDetails: input.matchDetails\n      }\n    };\n  } else if (Array.isArray(input)) {\n    return input.map(item => processDelimiterSeparation(item, delimiters));\n  } else if (typeof input === 'object' && input !== null) {\n    const result = {};\n    for (const key in input) {\n      result[key] = processDelimiterSeparation(input[key], delimiters);\n    }\n    return result;\n  }\n  \n  return input;\n};\n\n/**\n * Flatten data structure to generate simple rows for display\n */\nexport const flattenData = (data, path = '', rows = []) => {\n  if (!data) return rows;\n  \n  if (data.type === 'bracket-separation' || data.type === 'delimiter-separation') {\n    rows.push({\n      path,\n      original: data.original,\n      separated: data.separated,\n      type: data.type,\n      previous: data.previous,\n      matchDetails: data.matchDetails || (data.previous ? data.previous.matchDetails : null)\n    });\n  } else if (data.type === 'substring-grouping') {\n    // For substring grouping, preserve the groups and substrings\n    rows.push({\n      path,\n      original: data.original,\n      groups: data.groups,\n      substrings: data.substrings,\n      type: data.type,\n      previous: data.previous\n    });\n  } else if (data.type === 'substring-segmentation') {\n    // For substring segmentation, preserve the segmentation data\n    rows.push({\n      path,\n      original: data.original,\n      separated: data.separated,\n      type: data.type,\n      previous: data.previous\n    });\n  } else if (Array.isArray(data)) {\n    data.forEach((item, index) => {\n      const itemPath = path ? `${path}[${index}]` : `[${index}]`;\n      flattenData(item, itemPath, rows);\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    Object.entries(data).forEach(([key, value]) => {\n      const keyPath = path ? `${path}.${key}` : key;\n      flattenData(value, keyPath, rows);\n    });\n  } else if (path) {\n    // Simple value\n    rows.push({\n      path,\n      original: data,\n      separated: []\n    });\n  }\n  \n  return rows;\n};\n\n/**\n * Process data to group by common substrings (prefixes or suffixes)\n */\nexport const processSubstringGrouping = (input, config) => {\n  const { includeBrackets, minSubstringLength, minFrequency } = config;\n  \n  // Preserve the original data structure for display purposes\n  let originalData = input;\n  let previousSeparated = [];\n  \n  if (input.type === 'delimiter-separation' || input.type === 'bracket-separation') {\n    originalData = input.original;\n    previousSeparated = input.separated || [];\n  }\n  \n  // Extract all values to group\n  const extractValues = (data) => {\n    if (!data) return [];\n    \n    if (Array.isArray(data)) {\n      return data.flatMap(extractValues);\n    } else if (typeof data === 'object' && data !== null) {\n      if (data.separated && Array.isArray(data.separated)) {\n        // This is a processed row with separated values\n        return data.separated\n          .filter(item => {\n            // Skip bracket items if not including brackets\n            if (!includeBrackets && item.source === 'bracket') {\n              return false;\n            }\n            return true;\n          })\n          .map(item => typeof item === 'string' ? item : item.value);\n      } else if (data.type === 'delimiter-separation' || data.type === 'bracket-separation') {\n        // If this is already a processed row but we didn't catch it above\n        if (data.separated && Array.isArray(data.separated)) {\n          return data.separated\n            .filter(item => includeBrackets || (item.source !== 'bracket'))\n            .map(item => typeof item === 'string' ? item : item.value);\n        }\n        return [];\n      } else {\n        // Recursively extract from nested objects\n        return Object.values(data).flatMap(extractValues);\n      }\n    } else if (typeof data === 'string') {\n      return [data];\n    }\n    \n    return [];\n  };\n  \n  // Get all unique values\n  const allValues = extractValues(input);\n  const uniqueValues = [...new Set(allValues)].filter(val => val && val.trim().length >= minSubstringLength);\n  \n  // Filter out substrings that are contained within others with the same frequency\n  const filterSubstrings = (substrings) => {\n    const result = [];\n    \n    // Group by frequency first\n    const freqGroups = new Map();\n    for (const [substring, count] of substrings) {\n      if (!freqGroups.has(count)) {\n        freqGroups.set(count, []);\n      }\n      freqGroups.get(count).push(substring);\n    }\n    \n    // For each frequency group, filter out contained substrings\n    for (const [count, substrs] of freqGroups.entries()) {\n      // Sort by length (longest first)\n      substrs.sort((a, b) => b.length - a.length);\n      \n      const filtered = [];\n      for (const substr of substrs) {\n        // Check if this substring is contained in any already filtered string\n        const isContained = filtered.some(existing => \n          existing.includes(substr) && existing !== substr\n        );\n        \n        if (!isContained) {\n          filtered.push(substr);\n        }\n      }\n      \n      // Add filtered substrings with their counts\n      for (const substr of filtered) {\n        result.push([substr, count]);\n      }\n    }\n    \n    return result;\n  };\n  \n  // Find common prefixes with filtering\n  const findPrefixes = (values) => {\n    const prefixMap = new Map();\n    \n    // Count all possible prefixes\n    values.forEach(value => {\n      if (typeof value !== 'string' || !value) return;\n      \n      for (let length = minSubstringLength; length <= value.length; length++) {\n        const prefix = value.substring(0, length);\n        prefixMap.set(prefix, (prefixMap.get(prefix) || 0) + 1);\n      }\n    });\n    \n    // Get candidates and filter by minimum frequency\n    const candidates = [...prefixMap.entries()]\n      .filter(([prefix, count]) => count >= minFrequency)\n      .sort((a, b) => {\n        // First by frequency (descending)\n        if (b[1] !== a[1]) return b[1] - a[1];\n        // Then by length (longer first)\n        return b[0].length - a[0].length;\n      });\n    \n    return filterSubstrings(candidates);\n  };\n  \n  // Find common suffixes with filtering\n  const findSuffixes = (values) => {\n    const suffixMap = new Map();\n    \n    // Count all possible suffixes\n    values.forEach(value => {\n      if (typeof value !== 'string' || !value) return;\n      \n      for (let length = minSubstringLength; length <= value.length; length++) {\n        const suffix = value.substring(value.length - length);\n        suffixMap.set(suffix, (suffixMap.get(suffix) || 0) + 1);\n      }\n    });\n    \n    // Get candidates and filter by minimum frequency\n    const candidates = [...suffixMap.entries()]\n      .filter(([suffix, count]) => count >= minFrequency)\n      .sort((a, b) => {\n        // First by frequency (descending)\n        if (b[1] !== a[1]) return b[1] - a[1];\n        // Then by length (longer first)\n        return b[0].length - a[0].length;\n      });\n    \n    return filterSubstrings(candidates);\n  };\n  \n  // Find the most significant prefixes and suffixes\n  const prefixes = findPrefixes(uniqueValues);\n  const suffixes = findSuffixes(uniqueValues);\n  \n  // Combine prefixes and suffixes, while avoiding duplicates\n  let combinedSubstrings = [...prefixes];\n  suffixes.forEach(([suffix, count]) => {\n    // Check if this suffix already exists in prefixes (avoid duplicates)\n    if (!prefixes.some(([prefix]) => prefix === suffix)) {\n      combinedSubstrings.push([suffix, count]);\n    }\n  });\n  \n  // Sort by frequency and then by length\n  combinedSubstrings.sort((a, b) => {\n    // First by frequency (descending)\n    if (b[1] !== a[1]) return b[1] - a[1];\n    // Then by length (longer first)\n    return b[0].length - a[0].length;\n  });\n  \n  // Group values by substring\n  const groupBySubstring = (values, substrings) => {\n    const result = {};\n    const ungrouped = [...values]; // Start with all values, remove as they get grouped\n    \n    // Initialize groups\n    substrings.forEach(([substring]) => {\n      result[substring] = [];\n    });\n    \n    // Assign values to groups\n    substrings.forEach(([substring]) => {\n      // Find values that match this substring\n      for (let i = ungrouped.length - 1; i >= 0; i--) {\n        const value = ungrouped[i];\n        if (typeof value !== 'string' || !value) continue;\n        \n        // Check if value starts with or ends with the substring\n        if (value.startsWith(substring) || value.endsWith(substring)) {\n          result[substring].push(value);\n          ungrouped.splice(i, 1); // Remove from ungrouped\n        }\n      }\n    });\n    \n    // Add the remaining ungrouped values\n    result['__ungrouped__'] = ungrouped.filter(v => typeof v === 'string' && v);\n    \n    return result;\n  };\n  \n  // Group values by substring\n  const groups = groupBySubstring(uniqueValues, combinedSubstrings);\n  \n  // Return grouped data, including original data structure\n  return {\n    original: originalData,\n    separated: previousSeparated,\n    groups,\n    substrings: combinedSubstrings.map(([substring, count]) => ({ substring, count })),\n    ungrouped: groups['__ungrouped__'] || [],\n    type: 'substring-grouping',\n    previous: {\n      type: input.type,\n      separated: input.separated\n    }\n  };\n};\n\n/**\n * Process data to segment strings based on substrings contained in other strings\n */\nexport const processSubstringSegmentation = (input, config) => {\n  const { minSubstringLength, minOccurrence } = config;\n  \n  // Extract all values from input data\n  const extractAllValues = (data) => {\n    if (!data) return [];\n    \n    if (Array.isArray(data)) {\n      return data.flatMap(extractAllValues);\n    } else if (typeof data === 'object' && data !== null) {\n      if (data.separated && Array.isArray(data.separated)) {\n        // Extract from processed data rows\n        return data.separated\n          .map(item => typeof item === 'string' ? item : item.value);\n      } else {\n        // Recursively extract from nested objects\n        return Object.values(data).flatMap(extractAllValues);\n      }\n    } else if (typeof data === 'string') {\n      return [data];\n    }\n    \n    return [];\n  };\n  \n  // Find all strings from input\n  let allValues = [];\n  \n  if (input.type === 'delimiter-separation' || input.type === 'bracket-separation') {\n    // Extract from already processed data\n    if (input.separated && Array.isArray(input.separated)) {\n      allValues = input.separated.map(item => \n        typeof item === 'string' ? item : item.value\n      );\n    } else {\n      allValues = extractAllValues(input);\n    }\n  } else if (Array.isArray(input)) {\n    allValues = input.flatMap(extractAllValues);\n  } else if (typeof input === 'object' && input !== null) {\n    allValues = Object.values(input).flatMap(extractAllValues);\n  }\n  \n  // Filter out empty or too short strings\n  allValues = allValues.filter(val => \n    typeof val === 'string' && val.trim().length >= minSubstringLength\n  );\n  \n  // Identify candidate substrings (those that appear in multiple values)\n  const candidateSubstrings = [];\n  const valueOccurrences = new Map();\n  \n  // First pass: collect all possible substrings of sufficient length\n  allValues.forEach(value => {\n    if (typeof value !== 'string') return;\n    \n    // Generate all possible substrings of sufficient length\n    for (let startIdx = 0; startIdx <= value.length - minSubstringLength; startIdx++) {\n      for (let endIdx = startIdx + minSubstringLength; endIdx <= value.length; endIdx++) {\n        const substring = value.substring(startIdx, endIdx);\n        if (substring.length >= minSubstringLength) {\n          const current = valueOccurrences.get(substring) || [];\n          // Only add unique values\n          if (!current.includes(value)) {\n            current.push(value);\n            valueOccurrences.set(substring, current);\n          }\n        }\n      }\n    }\n  });\n  \n  // Filter substrings that appear in at least minOccurrence different values\n  valueOccurrences.forEach((values, substring) => {\n    if (values.length >= minOccurrence) {\n      candidateSubstrings.push({\n        substring,\n        occurrences: values.length,\n        values: values\n      });\n    }\n  });\n  \n  // Sort by length (prefer longer substrings) and then by occurrences\n  candidateSubstrings.sort((a, b) => {\n    // Prefer longer substrings\n    if (b.substring.length !== a.substring.length) {\n      return b.substring.length - a.substring.length;\n    }\n    // If same length, prefer more occurrences\n    return b.occurrences - a.occurrences;\n  });\n  \n  // Create segmentation info\n  const segmentations = new Map();\n  \n  // Process each string to find segmentation points\n  allValues.forEach(value => {\n    if (typeof value !== 'string') return;\n    \n    // Skip short strings\n    if (value.length < minSubstringLength * 2) {\n      segmentations.set(value, [{ text: value, isSubstring: false }]);\n      return;\n    }\n    \n    const segments = [];\n    let remaining = value;\n    let startIndex = 0;\n    let madeChanges = true;\n    \n    // Continue until no more changes can be made or we've processed the whole string\n    while (madeChanges && remaining.length > 0) {\n      madeChanges = false;\n      \n      // Try to find matches from candidate substrings\n      for (const candidate of candidateSubstrings) {\n        const { substring } = candidate;\n        \n        // Skip if this substring is the entire value\n        if (substring === value) continue;\n        \n        const index = remaining.indexOf(substring);\n        if (index !== -1) {\n          // We found a match\n          madeChanges = true;\n          \n          // Add segment before match if it exists\n          if (index > 0) {\n            segments.push({\n              text: remaining.substring(0, index),\n              isSubstring: false,\n              position: startIndex\n            });\n          }\n          \n          // Add the matching substring\n          segments.push({\n            text: substring,\n            isSubstring: true,\n            position: startIndex + index\n          });\n          \n          // Update remaining and startIndex\n          remaining = remaining.substring(index + substring.length);\n          startIndex += index + substring.length;\n          \n          // Break out to restart with our new remaining string\n          break;\n        }\n      }\n    }\n    \n    // Add any remaining text\n    if (remaining.length > 0) {\n      segments.push({\n        text: remaining,\n        isSubstring: false,\n        position: startIndex\n      });\n    }\n    \n    // If no segmentation was found, just use the original value\n    if (segments.length === 0) {\n      segments.push({\n        text: value,\n        isSubstring: false,\n        position: 0\n      });\n    }\n    \n    // Sort segments by position to ensure correct order\n    segments.sort((a, b) => a.position - b.position);\n    \n    // Store segmentation for this value\n    segmentations.set(value, segments);\n  });\n  \n  // Process the input to apply segmentations\n  const processWithSegmentations = (data) => {\n    if (!data) return data;\n    \n    if (typeof data === 'string') {\n      return {\n        original: data,\n        segments: segmentations.get(data) || [{ text: data, isSubstring: false }],\n        type: 'substring-segmentation'\n      };\n    } else if (data.type === 'delimiter-separation' || data.type === 'bracket-separation') {\n      // Create a copy of the input but with segmented info\n      const result = { ...data };\n      \n      // Add segmentation info to each separated item\n      if (result.separated && Array.isArray(result.separated)) {\n        // 브라켓 아이템과 일반 아이템 분리\n        const bracketItems = result.separated.filter(item => \n          typeof item === 'object' && item.source === 'bracket'\n        );\n        \n        const nonBracketItems = result.separated.filter(item => \n          typeof item !== 'object' || item.source !== 'bracket'\n        );\n        \n        // 각각 처리\n        const processedBracketItems = bracketItems.map(item => {\n          const value = typeof item === 'string' ? item : item.value;\n          const segments = segmentations.get(value) || [{ text: value, isSubstring: false }];\n          return {\n            ...item,\n            segments\n          };\n        });\n        \n        const processedNonBracketItems = nonBracketItems.map(item => {\n          const value = typeof item === 'string' ? item : item.value;\n          const segments = segmentations.get(value) || [{ text: value, isSubstring: false }];\n          \n          if (typeof item === 'string') {\n            return {\n              value,\n              segments,\n              source: 'text'\n            };\n          } else {\n            return {\n              ...item,\n              segments\n            };\n          }\n        });\n        \n        // 브라켓 아이템을 원래 위치에 맞게 배치 - 원래 배열 순서 유지\n        let resultItems = [];\n        \n        if (data.type === 'bracket-separation' && data.matchDetails) {\n          // 괄호 위치 정보가 있는 경우 위치 순서대로 배치\n          const bracketsByIndex = {};\n          processedBracketItems.forEach((item, idx) => {\n            if (item.bracketInfo && item.bracketInfo.startIndex !== undefined) {\n              bracketsByIndex[item.bracketInfo.startIndex] = item;\n            }\n          });\n          \n          // 원래 배열에서의 순서를 유지\n          result.separated.forEach(originalItem => {\n            if (typeof originalItem === 'object' && originalItem.source === 'bracket') {\n              if (originalItem.bracketInfo && bracketsByIndex[originalItem.bracketInfo.startIndex]) {\n                resultItems.push(bracketsByIndex[originalItem.bracketInfo.startIndex]);\n              }\n            } else {\n              // 일반 아이템 중에서 찾기\n              const value = typeof originalItem === 'string' ? originalItem : originalItem.value;\n              const matchingItem = processedNonBracketItems.find(item => {\n                const itemValue = typeof item === 'string' ? item : item.value;\n                return itemValue === value;\n              });\n              \n              if (matchingItem) {\n                resultItems.push(matchingItem);\n                // 이미 사용된 아이템 제거\n                processedNonBracketItems.splice(processedNonBracketItems.indexOf(matchingItem), 1);\n              }\n            }\n          });\n          \n          // 남은 아이템 추가\n          resultItems = [...resultItems, ...processedNonBracketItems];\n        } else {\n          // 위치 정보가 없는 경우 원래 순서 유지\n          resultItems = result.separated.map(item => {\n            if (typeof item === 'object' && item.source === 'bracket') {\n              return processedBracketItems.find(b => b.value === item.value) || item;\n            } else {\n              const value = typeof item === 'string' ? item : item.value;\n              return processedNonBracketItems.find(b => {\n                const itemValue = typeof b === 'string' ? b : b.value;\n                return itemValue === value;\n              }) || item;\n            }\n          });\n        }\n        \n        result.separated = resultItems;\n      }\n      \n      result.type = 'substring-segmentation';\n      result.previous = {\n        type: data.type,\n        separated: data.separated,\n        matchDetails: data.matchDetails\n      };\n      \n      return result;\n    } else if (Array.isArray(data)) {\n      return data.map(processWithSegmentations);\n    } else if (typeof data === 'object' && data !== null) {\n      const result = {};\n      for (const key in data) {\n        result[key] = processWithSegmentations(data[key]);\n      }\n      return result;\n    }\n    \n    return data;\n  };\n  \n  return {\n    segmentations: Array.from(segmentations.entries()).map(([value, segments]) => ({\n      value,\n      segments\n    })),\n    candidateSubstrings,\n    processed: processWithSegmentations(input)\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
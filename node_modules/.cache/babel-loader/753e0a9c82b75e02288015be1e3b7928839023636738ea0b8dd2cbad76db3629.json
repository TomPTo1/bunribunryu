{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js\";\nimport React from 'react';\nimport './SeparationClassifier.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DataDisplay = ({\n  processedData,\n  flattenData,\n  segmentationData\n}) => {\n  if (!processedData) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"no-data\",\n      children: \"\\uCC98\\uB9AC\\uD560 \\uB370\\uC774\\uD130\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 12\n    }, this);\n  }\n\n  // Check if the text is a duplicated string (contains itself twice)\n  const isDuplicatedText = text => {\n    if (typeof text !== 'string' || text.length === 0) return false;\n    const halfLength = Math.floor(text.length / 2);\n    const firstHalf = text.substring(0, halfLength);\n    return text.includes(firstHalf + firstHalf);\n  };\n\n  // Remove duplicated text if needed\n  const cleanDuplicatedText = text => {\n    if (!isDuplicatedText(text)) return text;\n    const halfLength = Math.floor(text.length / 2);\n    return text.substring(0, halfLength);\n  };\n\n  // Check if a value has segmentation data\n  const hasSegmentationData = value => {\n    if (!segmentationData || !segmentationData.segmentations) return false;\n    const segmentations = segmentationData.segmentations;\n    return segmentations.some(seg => seg.value === value && seg.segments.length > 1);\n  };\n\n  // Get segmentation data for a value\n  const getSegmentationData = value => {\n    if (!segmentationData || !segmentationData.segmentations) return null;\n    const segmentations = segmentationData.segmentations;\n    return segmentations.find(seg => seg.value === value);\n  };\n\n  // Handle segment click\n  const handleSegmentClick = (segment, e) => {\n    // 전파 중지 - 부모의 클릭 이벤트가 발생하지 않도록\n    e.stopPropagation();\n    console.log('Segment clicked:', segment);\n    // 필요에 따라 여기에 추가 동작 구현 (예: 검색, 필터링 등)\n  };\n\n  // Handle whole tag click\n  const handleTagClick = value => {\n    console.log('Whole tag clicked:', value);\n    // 필요에 따라 여기에 추가 동작 구현 (예: 검색, 필터링 등)\n  };\n\n  // Helper function to render a tag with appropriate styling\n  const renderTag = (value, source, key, isLastStep) => {\n    let className = `value-tag ${source === 'bracket' ? 'bracket-source' : source === 'clean-text' ? 'text-source' : 'delimiter-source'}`;\n\n    // Check if we have segmentation data for this value\n    const valueText = typeof value === 'string' ? value : value.value;\n    const segmentation = getSegmentationData(valueText);\n    if (segmentation && segmentation.segments.length > 1) {\n      // Render with inner segments\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: `${className} clickable-tag`,\n        onClick: () => handleTagClick(valueText),\n        children: segmentation.segments.map((segment, segIdx) => /*#__PURE__*/_jsxDEV(\"button\", {\n          className: `segment-button ${segment.isSubstring ? 'segment-matched' : 'segment-unmatched'}`,\n          onClick: e => handleSegmentClick(segment, e),\n          children: [segment.text, segIdx < segmentation.segments.length - 1 && /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"segment-divider\",\n            children: \"\\u2022\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 81,\n            columnNumber: 17\n          }, this)]\n        }, `seg-${segIdx}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 74,\n          columnNumber: 13\n        }, this))\n      }, key, false, {\n        fileName: _jsxFileName,\n        lineNumber: 68,\n        columnNumber: 9\n      }, this);\n    }\n\n    // No segmentation, render normally but still clickable\n    return /*#__PURE__*/_jsxDEV(\"span\", {\n      className: `${className} clickable-tag`,\n      onClick: () => handleTagClick(valueText),\n      children: valueText\n    }, key, false, {\n      fileName: _jsxFileName,\n      lineNumber: 90,\n      columnNumber: 7\n    }, this);\n  };\n\n  // Render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = row => {\n    // Handle substring segmentation data\n    if (row.type === 'substring-segmentation') {\n      return renderSubstringSegmentationView(row);\n    }\n\n    // Check if this is the last pipeline step (right before substring segmentation)\n    const isLastStep = segmentationData && segmentationData.processed && segmentationData.processed.previous && segmentationData.processed.previous.type === row.type;\n\n    // Clean up potentially duplicated original text\n    let original = row.original;\n    if (isDuplicatedText(original)) {\n      original = cleanDuplicatedText(original);\n    }\n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row, isLastStep);\n    }\n\n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"unprocessed-tag\",\n        children: original\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 124,\n        columnNumber: 14\n      }, this);\n    }\n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n\n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"unprocessed-tag\",\n            children: unprocessedText\n          }, `unproc-${idx}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 141,\n            columnNumber: 13\n          }, this));\n        }\n\n        // Add the processed bracket content\n        result.push(renderTag(match.value, 'bracket', `proc-${idx}`, isLastStep));\n        lastIndex = match.endIndex;\n      });\n\n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"unprocessed-tag\",\n          children: original.substring(lastIndex)\n        }, \"unproc-last\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 156,\n          columnNumber: 11\n        }, this));\n      }\n      return result;\n    }\n\n    // Fallback to original display method\n    return renderSeparatedValues(row, isLastStep);\n  };\n\n  // Render substring segmentation view with segmented parts\n  const renderSubstringSegmentationView = row => {\n    if (!row.previous || !row.previous.separated || row.previous.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"no-values\",\n        children: \"\\uC774\\uC804 \\uB2E8\\uACC4\\uC758 \\uAC12\\uC774 \\uC5C6\\uC2B5\\uB2C8\\uB2E4\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 172,\n        columnNumber: 14\n      }, this);\n    }\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"substring-segmentation-view\",\n      children: row.separated.map((item, idx) => {\n        const value = typeof item === 'string' ? item : item.value;\n        const segments = item.segments || [];\n        const source = item.source || 'text';\n\n        // If there are segments, render them\n        if (segments.length > 1) {\n          return /*#__PURE__*/_jsxDEV(\"span\", {\n            className: `value-tag clickable-tag ${source === 'bracket' ? 'bracket-source' : source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n            onClick: () => handleTagClick(value),\n            children: segments.map((segment, segIdx) => /*#__PURE__*/_jsxDEV(\"button\", {\n              className: `segment-button ${segment.isSubstring ? 'segment-matched' : 'segment-unmatched'}`,\n              onClick: e => handleSegmentClick(segment, e),\n              children: [segment.text, segIdx < segments.length - 1 && /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"segment-divider\",\n                children: \"\\u2022\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 198,\n                columnNumber: 23\n              }, this)]\n            }, `seg-${segIdx}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 191,\n              columnNumber: 19\n            }, this))\n          }, idx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 185,\n            columnNumber: 15\n          }, this);\n        }\n\n        // No segments, render normally\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: `value-tag clickable-tag ${source === 'bracket' ? 'bracket-source' : source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n          onClick: () => handleTagClick(value),\n          children: value\n        }, idx, false, {\n          fileName: _jsxFileName,\n          lineNumber: 207,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 176,\n      columnNumber: 7\n    }, this);\n  };\n  const renderSeparatedValues = (row, isLastStep) => {\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"no-values\",\n        children: \"\\uCD94\\uCD9C\\uB41C \\uAC12 \\uC5C6\\uC74C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 222,\n        columnNumber: 14\n      }, this);\n    }\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => renderTag(val, 'text', idx, isLastStep));\n    }\n\n    // New format (with metadata)\n    return row.separated.map((item, idx) => renderTag(item, item.source || 'text', idx, isLastStep));\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"data-display\",\n    children: /*#__PURE__*/_jsxDEV(\"table\", {\n      className: \"data-table\",\n      children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n        children: flattenData(processedData).map((row, index) => /*#__PURE__*/_jsxDEV(\"tr\", {\n          children: /*#__PURE__*/_jsxDEV(\"td\", {\n            className: \"enhanced-view\",\n            children: renderEnhancedView(row)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 244,\n            columnNumber: 15\n          }, this)\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 243,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 241,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 240,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 239,\n    columnNumber: 5\n  }, this);\n};\n_c = DataDisplay;\nexport default DataDisplay;\nvar _c;\n$RefreshReg$(_c, \"DataDisplay\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","DataDisplay","processedData","flattenData","segmentationData","className","children","fileName","_jsxFileName","lineNumber","columnNumber","isDuplicatedText","text","length","halfLength","Math","floor","firstHalf","substring","includes","cleanDuplicatedText","hasSegmentationData","value","segmentations","some","seg","segments","getSegmentationData","find","handleSegmentClick","segment","e","stopPropagation","console","log","handleTagClick","renderTag","source","key","isLastStep","valueText","segmentation","onClick","map","segIdx","isSubstring","renderEnhancedView","row","type","renderSubstringSegmentationView","processed","previous","original","renderSeparatedValues","separated","result","lastIndex","matchDetails","sortedMatches","sort","a","b","startIndex","forEach","match","idx","unprocessedText","push","endIndex","item","Array","isArray","every","v","val","index","_c","$RefreshReg$"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js"],"sourcesContent":["import React from 'react';\nimport './SeparationClassifier.css';\n\nconst DataDisplay = ({ processedData, flattenData, segmentationData }) => {\n  if (!processedData) {\n    return <div className=\"no-data\">처리할 데이터가 없습니다</div>;\n  }\n\n  // Check if the text is a duplicated string (contains itself twice)\n  const isDuplicatedText = (text) => {\n    if (typeof text !== 'string' || text.length === 0) return false;\n    const halfLength = Math.floor(text.length / 2);\n    const firstHalf = text.substring(0, halfLength);\n    return text.includes(firstHalf + firstHalf);\n  };\n\n  // Remove duplicated text if needed\n  const cleanDuplicatedText = (text) => {\n    if (!isDuplicatedText(text)) return text;\n    const halfLength = Math.floor(text.length / 2);\n    return text.substring(0, halfLength);\n  };\n\n  // Check if a value has segmentation data\n  const hasSegmentationData = (value) => {\n    if (!segmentationData || !segmentationData.segmentations) return false;\n    \n    const segmentations = segmentationData.segmentations;\n    return segmentations.some(seg => seg.value === value && seg.segments.length > 1);\n  };\n\n  // Get segmentation data for a value\n  const getSegmentationData = (value) => {\n    if (!segmentationData || !segmentationData.segmentations) return null;\n    \n    const segmentations = segmentationData.segmentations;\n    return segmentations.find(seg => seg.value === value);\n  };\n\n  // Handle segment click\n  const handleSegmentClick = (segment, e) => {\n    // 전파 중지 - 부모의 클릭 이벤트가 발생하지 않도록\n    e.stopPropagation();\n    console.log('Segment clicked:', segment);\n    // 필요에 따라 여기에 추가 동작 구현 (예: 검색, 필터링 등)\n  };\n\n  // Handle whole tag click\n  const handleTagClick = (value) => {\n    console.log('Whole tag clicked:', value);\n    // 필요에 따라 여기에 추가 동작 구현 (예: 검색, 필터링 등)\n  };\n\n  // Helper function to render a tag with appropriate styling\n  const renderTag = (value, source, key, isLastStep) => {\n    let className = `value-tag ${\n      source === 'bracket' ? 'bracket-source' : \n      source === 'clean-text' ? 'text-source' : 'delimiter-source'\n    }`;\n    \n    // Check if we have segmentation data for this value\n    const valueText = typeof value === 'string' ? value : value.value;\n    const segmentation = getSegmentationData(valueText);\n    \n    if (segmentation && segmentation.segments.length > 1) {\n      // Render with inner segments\n      return (\n        <span \n          key={key} \n          className={`${className} clickable-tag`} \n          onClick={() => handleTagClick(valueText)}\n        >\n          {segmentation.segments.map((segment, segIdx) => (\n            <button \n              key={`seg-${segIdx}`} \n              className={`segment-button ${segment.isSubstring ? 'segment-matched' : 'segment-unmatched'}`}\n              onClick={(e) => handleSegmentClick(segment, e)}\n            >\n              {segment.text}\n              {segIdx < segmentation.segments.length - 1 && \n                <span className=\"segment-divider\">•</span>}\n            </button>\n          ))}\n        </span>\n      );\n    }\n    \n    // No segmentation, render normally but still clickable\n    return (\n      <span \n        key={key} \n        className={`${className} clickable-tag`}\n        onClick={() => handleTagClick(valueText)}\n      >\n        {valueText}\n      </span>\n    );\n  };\n\n  // Render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = (row) => {\n    // Handle substring segmentation data\n    if (row.type === 'substring-segmentation') {\n      return renderSubstringSegmentationView(row);\n    }\n    \n    // Check if this is the last pipeline step (right before substring segmentation)\n    const isLastStep = segmentationData && segmentationData.processed && \n                       (segmentationData.processed.previous &&\n                        segmentationData.processed.previous.type === row.type);\n    \n    // Clean up potentially duplicated original text\n    let original = row.original;\n    if (isDuplicatedText(original)) {\n      original = cleanDuplicatedText(original);\n    }\n    \n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row, isLastStep);\n    }\n    \n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"unprocessed-tag\">{original}</span>;\n    }\n    \n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n      \n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      \n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(\n            <span key={`unproc-${idx}`} className=\"unprocessed-tag\">{unprocessedText}</span>\n          );\n        }\n        \n        // Add the processed bracket content\n        result.push(\n          renderTag(match.value, 'bracket', `proc-${idx}`, isLastStep)\n        );\n        \n        lastIndex = match.endIndex;\n      });\n      \n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(\n          <span key=\"unproc-last\" className=\"unprocessed-tag\">\n            {original.substring(lastIndex)}\n          </span>\n        );\n      }\n      \n      return result;\n    }\n    \n    // Fallback to original display method\n    return renderSeparatedValues(row, isLastStep);\n  };\n  \n  // Render substring segmentation view with segmented parts\n  const renderSubstringSegmentationView = (row) => {\n    if (!row.previous || !row.previous.separated || row.previous.separated.length === 0) {\n      return <span className=\"no-values\">이전 단계의 값이 없습니다</span>;\n    }\n    \n    return (\n      <div className=\"substring-segmentation-view\">\n        {row.separated.map((item, idx) => {\n          const value = typeof item === 'string' ? item : item.value;\n          const segments = item.segments || [];\n          const source = item.source || 'text';\n          \n          // If there are segments, render them\n          if (segments.length > 1) {\n            return (\n              <span \n                key={idx} \n                className={`value-tag clickable-tag ${source === 'bracket' ? 'bracket-source' : source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n                onClick={() => handleTagClick(value)}\n              >\n                {segments.map((segment, segIdx) => (\n                  <button \n                    key={`seg-${segIdx}`} \n                    className={`segment-button ${segment.isSubstring ? 'segment-matched' : 'segment-unmatched'}`}\n                    onClick={(e) => handleSegmentClick(segment, e)}\n                  >\n                    {segment.text}\n                    {segIdx < segments.length - 1 && \n                      <span className=\"segment-divider\">•</span>}\n                  </button>\n                ))}\n              </span>\n            );\n          }\n          \n          // No segments, render normally\n          return (\n            <span \n              key={idx} \n              className={`value-tag clickable-tag ${source === 'bracket' ? 'bracket-source' : source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n              onClick={() => handleTagClick(value)}\n            >\n              {value}\n            </span>\n          );\n        })}\n      </div>\n    );\n  };\n\n  const renderSeparatedValues = (row, isLastStep) => {\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"no-values\">추출된 값 없음</span>;\n    }\n\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => \n        renderTag(val, 'text', idx, isLastStep)\n      );\n    } \n    \n    // New format (with metadata)\n    return row.separated.map((item, idx) => \n      renderTag(item, item.source || 'text', idx, isLastStep)\n    );\n  };\n\n  return (\n    <div className=\"data-display\">\n      <table className=\"data-table\">\n        <tbody>\n          {flattenData(processedData).map((row, index) => (\n            <tr key={index}>\n              <td className=\"enhanced-view\">\n                {renderEnhancedView(row)}\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport default DataDisplay; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js\";\nimport React from 'react';\nimport './SeparationClassifier.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DataDisplay = ({\n  processedData,\n  flattenData\n}) => {\n  if (!processedData) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"no-data\",\n      children: \"\\uCC98\\uB9AC\\uD560 \\uB370\\uC774\\uD130\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 12\n    }, this);\n  }\n\n  // New function to render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = row => {\n    const original = row.original;\n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row);\n    }\n\n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"unprocessed-tag\",\n        children: original\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 19,\n        columnNumber: 14\n      }, this);\n    }\n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n\n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"unprocessed-tag\",\n            children: unprocessedText\n          }, `unproc-${idx}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 36,\n            columnNumber: 13\n          }, this));\n        }\n\n        // Add the processed bracket content\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"value-tag bracket-source\",\n          children: match.value\n        }, `proc-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 42,\n          columnNumber: 11\n        }, this));\n        lastIndex = match.endIndex;\n      });\n\n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"unprocessed-tag\",\n          children: original.substring(lastIndex)\n        }, \"unproc-last\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 51,\n          columnNumber: 11\n        }, this));\n      }\n      return result;\n    } else if (row.type === 'delimiter-separation') {\n      // For delimiter separation, we need to reconstruct the sequence\n      // This is more complex since we need to put parts back in original order\n\n      // First, collect all parts with their positions where available\n      const parts = [];\n\n      // Add parts from brackets (these have position info in matchDetails)\n      if (row.previous && row.previous.matchDetails) {\n        row.separated.forEach(item => {\n          if (item.source === 'bracket' && item.bracketInfo) {\n            parts.push({\n              ...item,\n              startIndex: item.bracketInfo.startIndex,\n              endIndex: item.bracketInfo.endIndex,\n              isProcessed: true\n            });\n          }\n        });\n      }\n\n      // Add clean text parts\n      const cleanTextParts = row.separated.filter(item => item.source === 'clean-text');\n\n      // We need to figure out positions of clean text parts\n      // For simplicity, we'll just display them in sequence for now\n      let cleanTextIndex = 0;\n      let currentPosition = 0;\n\n      // Construct a representation that follows the original text order\n      const orderedElements = [];\n      const bracketParts = parts.filter(p => p.isProcessed).sort((a, b) => a.startIndex - b.startIndex);\n      let lastBracketEnd = 0;\n      bracketParts.forEach((bracketPart, idx) => {\n        // Add unprocessed text before this bracket\n        if (bracketPart.startIndex > lastBracketEnd) {\n          const unprocessedLength = bracketPart.startIndex - lastBracketEnd;\n\n          // Find clean text parts that fit in this gap\n          let remainingLength = unprocessedLength;\n          let cleanTextUsed = false;\n          while (cleanTextIndex < cleanTextParts.length && remainingLength > 0) {\n            const cleanPart = cleanTextParts[cleanTextIndex];\n            // Add the clean text part\n            orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"value-tag text-source\",\n              children: cleanPart.value\n            }, `clean-${cleanTextIndex}`, false, {\n              fileName: _jsxFileName,\n              lineNumber: 106,\n              columnNumber: 15\n            }, this));\n            cleanTextUsed = true;\n            cleanTextIndex++;\n            // Approximation since we don't know the exact character length\n            remainingLength -= cleanPart.value.length + 1;\n          }\n\n          // If no clean text was used, add as unprocessed\n          if (!cleanTextUsed) {\n            orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"unprocessed-tag\",\n              children: original.substring(lastBracketEnd, bracketPart.startIndex)\n            }, `unproc-${idx}`, false, {\n              fileName: _jsxFileName,\n              lineNumber: 119,\n              columnNumber: 15\n            }, this));\n          }\n        }\n\n        // Add the bracket content\n        orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"value-tag bracket-source\",\n          children: bracketPart.value\n        }, `bracket-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 128,\n          columnNumber: 11\n        }, this));\n        lastBracketEnd = bracketPart.endIndex;\n      });\n\n      // Add remaining clean text parts\n      while (cleanTextIndex < cleanTextParts.length) {\n        const cleanPart = cleanTextParts[cleanTextIndex];\n        orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"value-tag text-source\",\n          children: cleanPart.value\n        }, `clean-${cleanTextIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 140,\n          columnNumber: 11\n        }, this));\n        cleanTextIndex++;\n      }\n\n      // Add any remaining text as unprocessed\n      if (lastBracketEnd < original.length) {\n        orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"unprocessed-tag\",\n          children: original.substring(lastBracketEnd)\n        }, \"unproc-last\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 150,\n          columnNumber: 11\n        }, this));\n      }\n      return orderedElements.length > 0 ? orderedElements : renderSeparatedValues(row);\n    }\n\n    // Fallback to original display method\n    return renderSeparatedValues(row);\n  };\n  const renderSeparatedValues = row => {\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"no-values\",\n        children: \"\\uCD94\\uCD9C\\uB41C \\uAC12 \\uC5C6\\uC74C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 14\n      }, this);\n    }\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"value-tag\",\n        children: val\n      }, idx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 9\n      }, this));\n    }\n\n    // New format (with metadata)\n    return row.separated.map((item, idx) => /*#__PURE__*/_jsxDEV(\"span\", {\n      className: `value-tag ${item.source === 'bracket' ? 'bracket-source' : item.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n      children: typeof item === 'string' ? item : item.value\n    }, idx, false, {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 7\n    }, this));\n  };\n  return /*#__PURE__*/_jsxDEV(\"table\", {\n    className: \"data-table\",\n    children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n      children: flattenData(processedData).map((row, index) => /*#__PURE__*/_jsxDEV(\"tr\", {\n        children: /*#__PURE__*/_jsxDEV(\"td\", {\n          className: \"enhanced-view\",\n          children: renderEnhancedView(row)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 192,\n          columnNumber: 13\n        }, this)\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 191,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 189,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 188,\n    columnNumber: 5\n  }, this);\n};\n_c = DataDisplay;\nexport default DataDisplay;\nvar _c;\n$RefreshReg$(_c, \"DataDisplay\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","DataDisplay","processedData","flattenData","className","children","fileName","_jsxFileName","lineNumber","columnNumber","renderEnhancedView","row","original","renderSeparatedValues","separated","length","type","result","lastIndex","matchDetails","sortedMatches","sort","a","b","startIndex","forEach","match","idx","unprocessedText","substring","push","value","endIndex","parts","previous","item","source","bracketInfo","isProcessed","cleanTextParts","filter","cleanTextIndex","currentPosition","orderedElements","bracketParts","p","lastBracketEnd","bracketPart","unprocessedLength","remainingLength","cleanTextUsed","cleanPart","Array","isArray","every","v","map","val","index","_c","$RefreshReg$"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js"],"sourcesContent":["import React from 'react';\nimport './SeparationClassifier.css';\n\nconst DataDisplay = ({ processedData, flattenData }) => {\n  if (!processedData) {\n    return <div className=\"no-data\">처리할 데이터가 없습니다</div>;\n  }\n\n  // New function to render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = (row) => {\n    const original = row.original;\n    \n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row);\n    }\n    \n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"unprocessed-tag\">{original}</span>;\n    }\n    \n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n      \n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      \n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(\n            <span key={`unproc-${idx}`} className=\"unprocessed-tag\">{unprocessedText}</span>\n          );\n        }\n        \n        // Add the processed bracket content\n        result.push(\n          <span key={`proc-${idx}`} className=\"value-tag bracket-source\">{match.value}</span>\n        );\n        \n        lastIndex = match.endIndex;\n      });\n      \n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(\n          <span key=\"unproc-last\" className=\"unprocessed-tag\">\n            {original.substring(lastIndex)}\n          </span>\n        );\n      }\n      \n      return result;\n    } else if (row.type === 'delimiter-separation') {\n      // For delimiter separation, we need to reconstruct the sequence\n      // This is more complex since we need to put parts back in original order\n      \n      // First, collect all parts with their positions where available\n      const parts = [];\n      \n      // Add parts from brackets (these have position info in matchDetails)\n      if (row.previous && row.previous.matchDetails) {\n        row.separated.forEach(item => {\n          if (item.source === 'bracket' && item.bracketInfo) {\n            parts.push({\n              ...item,\n              startIndex: item.bracketInfo.startIndex,\n              endIndex: item.bracketInfo.endIndex,\n              isProcessed: true\n            });\n          }\n        });\n      }\n      \n      // Add clean text parts\n      const cleanTextParts = row.separated.filter(item => item.source === 'clean-text');\n      \n      // We need to figure out positions of clean text parts\n      // For simplicity, we'll just display them in sequence for now\n      let cleanTextIndex = 0;\n      let currentPosition = 0;\n      \n      // Construct a representation that follows the original text order\n      const orderedElements = [];\n      const bracketParts = parts.filter(p => p.isProcessed).sort((a, b) => a.startIndex - b.startIndex);\n      \n      let lastBracketEnd = 0;\n      \n      bracketParts.forEach((bracketPart, idx) => {\n        // Add unprocessed text before this bracket\n        if (bracketPart.startIndex > lastBracketEnd) {\n          const unprocessedLength = bracketPart.startIndex - lastBracketEnd;\n          \n          // Find clean text parts that fit in this gap\n          let remainingLength = unprocessedLength;\n          let cleanTextUsed = false;\n          \n          while (cleanTextIndex < cleanTextParts.length && remainingLength > 0) {\n            const cleanPart = cleanTextParts[cleanTextIndex];\n            // Add the clean text part\n            orderedElements.push(\n              <span key={`clean-${cleanTextIndex}`} className=\"value-tag text-source\">\n                {cleanPart.value}\n              </span>\n            );\n            cleanTextUsed = true;\n            cleanTextIndex++;\n            // Approximation since we don't know the exact character length\n            remainingLength -= cleanPart.value.length + 1; \n          }\n          \n          // If no clean text was used, add as unprocessed\n          if (!cleanTextUsed) {\n            orderedElements.push(\n              <span key={`unproc-${idx}`} className=\"unprocessed-tag\">\n                {original.substring(lastBracketEnd, bracketPart.startIndex)}\n              </span>\n            );\n          }\n        }\n        \n        // Add the bracket content\n        orderedElements.push(\n          <span key={`bracket-${idx}`} className=\"value-tag bracket-source\">\n            {bracketPart.value}\n          </span>\n        );\n        \n        lastBracketEnd = bracketPart.endIndex;\n      });\n      \n      // Add remaining clean text parts\n      while (cleanTextIndex < cleanTextParts.length) {\n        const cleanPart = cleanTextParts[cleanTextIndex];\n        orderedElements.push(\n          <span key={`clean-${cleanTextIndex}`} className=\"value-tag text-source\">\n            {cleanPart.value}\n          </span>\n        );\n        cleanTextIndex++;\n      }\n      \n      // Add any remaining text as unprocessed\n      if (lastBracketEnd < original.length) {\n        orderedElements.push(\n          <span key=\"unproc-last\" className=\"unprocessed-tag\">\n            {original.substring(lastBracketEnd)}\n          </span>\n        );\n      }\n      \n      return orderedElements.length > 0 ? orderedElements : renderSeparatedValues(row);\n    }\n    \n    // Fallback to original display method\n    return renderSeparatedValues(row);\n  };\n\n  const renderSeparatedValues = (row) => {\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"no-values\">추출된 값 없음</span>;\n    }\n\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => (\n        <span key={idx} className=\"value-tag\">{val}</span>\n      ));\n    } \n    \n    // New format (with metadata)\n    return row.separated.map((item, idx) => (\n      <span \n        key={idx} \n        className={`value-tag ${item.source === 'bracket' ? 'bracket-source' : \n                              item.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n      >\n        {typeof item === 'string' ? item : item.value}\n      </span>\n    ));\n  };\n\n  return (\n    <table className=\"data-table\">\n      <tbody>\n        {flattenData(processedData).map((row, index) => (\n          <tr key={index}>\n            <td className=\"enhanced-view\">\n              {renderEnhancedView(row)}\n            </td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n};\n\nexport default DataDisplay; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js\";\nimport React from 'react';\nimport './SeparationClassifier.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DataDisplay = ({\n  processedData,\n  flattenData\n}) => {\n  if (!processedData) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"no-data\",\n      children: \"\\uCC98\\uB9AC\\uD560 \\uB370\\uC774\\uD130\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 12\n    }, this);\n  }\n\n  // Check if the text is a duplicated string (contains itself twice)\n  const isDuplicatedText = text => {\n    if (typeof text !== 'string' || text.length === 0) return false;\n    const halfLength = Math.floor(text.length / 2);\n    const firstHalf = text.substring(0, halfLength);\n    return text.includes(firstHalf + firstHalf);\n  };\n\n  // Remove duplicated text if needed\n  const cleanDuplicatedText = text => {\n    if (!isDuplicatedText(text)) return text;\n\n    // Try to find where the duplication starts\n    for (let i = 1; i < text.length / 2; i++) {\n      const firstPart = text.substring(0, i);\n      const secondPart = text.substring(i, i * 2);\n      if (firstPart === secondPart) {\n        // Check if this pattern repeats in the rest of the string\n        const pattern = firstPart;\n        const remaining = text.substring(i * 2);\n\n        // If the remaining part starts with the same pattern, we have duplication\n        if (remaining.startsWith(pattern)) {\n          return firstPart + remaining;\n        }\n      }\n    }\n\n    // Fallback: just take the first half if we can't find the exact pattern\n    const halfLength = Math.floor(text.length / 2);\n    return text.substring(0, halfLength);\n  };\n\n  // New function to render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = row => {\n    // Clean up potentially duplicated original text\n    let original = row.original;\n    if (isDuplicatedText(original)) {\n      original = cleanDuplicatedText(original);\n    }\n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row);\n    }\n\n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"unprocessed-tag\",\n        children: original\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 57,\n        columnNumber: 14\n      }, this);\n    }\n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n\n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"unprocessed-tag\",\n            children: unprocessedText\n          }, `unproc-${idx}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 74,\n            columnNumber: 13\n          }, this));\n        }\n\n        // Add the processed bracket content\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"value-tag bracket-source\",\n          children: match.value\n        }, `proc-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 80,\n          columnNumber: 11\n        }, this));\n        lastIndex = match.endIndex;\n      });\n\n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"unprocessed-tag\",\n          children: original.substring(lastIndex)\n        }, \"unproc-last\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 89,\n          columnNumber: 11\n        }, this));\n      }\n      return result;\n    } else if (row.type === 'delimiter-separation') {\n      // For delimiter separation, we need to reconstruct the sequence\n\n      // First, gather all bracket parts with their exact positions\n      const allParts = [];\n\n      // Add bracket parts first (they have exact position info)\n      if (row.previous && row.previous.matchDetails) {\n        // Use matchDetails directly from previous step for more accurate positioning\n        const matchDetails = row.previous.matchDetails || [];\n\n        // Find and add bracket parts from the separated data\n        row.separated.forEach(item => {\n          if (item.source === 'bracket') {\n            const bracketInfo = item.bracketInfo;\n            if (bracketInfo) {\n              allParts.push({\n                value: item.value,\n                source: 'bracket',\n                startIndex: bracketInfo.startIndex,\n                endIndex: bracketInfo.endIndex,\n                exactPosition: true // Flag that this has exact position\n              });\n            }\n          }\n        });\n      }\n\n      // Add clean text parts with approximate positions\n      row.separated.forEach(item => {\n        if (item.source === 'clean-text') {\n          const value = item.value.trim();\n          if (value.length === 0) return;\n          let position = -1;\n\n          // First try to find the exact text in the original\n          position = original.indexOf(value);\n          if (position >= 0) {\n            // Found position\n            allParts.push({\n              value: item.value,\n              source: 'clean-text',\n              startIndex: position,\n              endIndex: position + value.length,\n              exactPosition: false\n            });\n          } else {\n            // If not found exactly, add to the end\n            allParts.push({\n              value: item.value,\n              source: 'clean-text',\n              startIndex: Number.MAX_SAFE_INTEGER,\n              endIndex: Number.MAX_SAFE_INTEGER,\n              exactPosition: false\n            });\n          }\n        }\n      });\n\n      // Add any delimiter parts\n      row.separated.forEach(item => {\n        if (item.source !== 'bracket' && item.source !== 'clean-text') {\n          allParts.push({\n            value: item.value,\n            source: item.source || 'delimiter',\n            startIndex: Number.MAX_SAFE_INTEGER,\n            endIndex: Number.MAX_SAFE_INTEGER,\n            exactPosition: false\n          });\n        }\n      });\n\n      // Sort all parts by position\n      const sortedParts = [...allParts].sort((a, b) => {\n        // Always prioritize exact positions\n        if (a.exactPosition && !b.exactPosition) return -1;\n        if (!a.exactPosition && b.exactPosition) return 1;\n\n        // Then sort by index\n        return a.startIndex - b.startIndex;\n      });\n\n      // Now build the result elements in order\n      const resultElements = [];\n      let lastIndex = 0;\n\n      // Add parts in order with unprocessed text in between\n      sortedParts.forEach((part, idx) => {\n        if (part.startIndex === Number.MAX_SAFE_INTEGER) return; // Skip unpositioned parts for now\n\n        // Add unprocessed text between last part and this one\n        if (part.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, part.startIndex);\n          if (unprocessedText.trim().length > 0) {\n            resultElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"unprocessed-tag\",\n              children: unprocessedText\n            }, `unproc-${idx}`, false, {\n              fileName: _jsxFileName,\n              lineNumber: 193,\n              columnNumber: 15\n            }, this));\n          }\n        }\n\n        // Add the part\n        resultElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: `value-tag ${part.source === 'bracket' ? 'bracket-source' : part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n          children: part.value\n        }, `part-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 202,\n          columnNumber: 11\n        }, this));\n\n        // Update last processed position\n        lastIndex = part.endIndex;\n      });\n\n      // Add any remaining text\n      if (lastIndex < original.length) {\n        orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"unprocessed-tag\",\n          children: original.substring(lastIndex)\n        }, \"unproc-last\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 218,\n          columnNumber: 11\n        }, this));\n      }\n\n      // Add unpositioned parts at the end\n      unpositionedParts.forEach((part, idx) => {\n        orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: `value-tag ${part.source === 'bracket' ? 'bracket-source' : part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n          children: part.value\n        }, `unpos-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 227,\n          columnNumber: 11\n        }, this));\n      });\n      return orderedElements.length > 0 ? orderedElements : renderSeparatedValues(row);\n    }\n\n    // Fallback to original display method\n    return renderSeparatedValues(row);\n  };\n  const renderSeparatedValues = row => {\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"no-values\",\n        children: \"\\uCD94\\uCD9C\\uB41C \\uAC12 \\uC5C6\\uC74C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 246,\n        columnNumber: 14\n      }, this);\n    }\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"value-tag\",\n        children: val\n      }, idx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 252,\n        columnNumber: 9\n      }, this));\n    }\n\n    // New format (with metadata)\n    return row.separated.map((item, idx) => /*#__PURE__*/_jsxDEV(\"span\", {\n      className: `value-tag ${item.source === 'bracket' ? 'bracket-source' : item.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n      children: typeof item === 'string' ? item : item.value\n    }, idx, false, {\n      fileName: _jsxFileName,\n      lineNumber: 258,\n      columnNumber: 7\n    }, this));\n  };\n  return /*#__PURE__*/_jsxDEV(\"table\", {\n    className: \"data-table\",\n    children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n      children: flattenData(processedData).map((row, index) => /*#__PURE__*/_jsxDEV(\"tr\", {\n        children: /*#__PURE__*/_jsxDEV(\"td\", {\n          className: \"enhanced-view\",\n          children: renderEnhancedView(row)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 273,\n          columnNumber: 13\n        }, this)\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 272,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 270,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 269,\n    columnNumber: 5\n  }, this);\n};\n_c = DataDisplay;\nexport default DataDisplay;\nvar _c;\n$RefreshReg$(_c, \"DataDisplay\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","DataDisplay","processedData","flattenData","className","children","fileName","_jsxFileName","lineNumber","columnNumber","isDuplicatedText","text","length","halfLength","Math","floor","firstHalf","substring","includes","cleanDuplicatedText","i","firstPart","secondPart","pattern","remaining","startsWith","renderEnhancedView","row","original","renderSeparatedValues","separated","type","result","lastIndex","matchDetails","sortedMatches","sort","a","b","startIndex","forEach","match","idx","unprocessedText","push","value","endIndex","allParts","previous","item","source","bracketInfo","exactPosition","trim","position","indexOf","Number","MAX_SAFE_INTEGER","sortedParts","resultElements","part","orderedElements","unpositionedParts","Array","isArray","every","v","map","val","index","_c","$RefreshReg$"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js"],"sourcesContent":["import React from 'react';\nimport './SeparationClassifier.css';\n\nconst DataDisplay = ({ processedData, flattenData }) => {\n  if (!processedData) {\n    return <div className=\"no-data\">처리할 데이터가 없습니다</div>;\n  }\n\n  // Check if the text is a duplicated string (contains itself twice)\n  const isDuplicatedText = (text) => {\n    if (typeof text !== 'string' || text.length === 0) return false;\n    const halfLength = Math.floor(text.length / 2);\n    const firstHalf = text.substring(0, halfLength);\n    return text.includes(firstHalf + firstHalf);\n  };\n\n  // Remove duplicated text if needed\n  const cleanDuplicatedText = (text) => {\n    if (!isDuplicatedText(text)) return text;\n    \n    // Try to find where the duplication starts\n    for (let i = 1; i < text.length / 2; i++) {\n      const firstPart = text.substring(0, i);\n      const secondPart = text.substring(i, i * 2);\n      \n      if (firstPart === secondPart) {\n        // Check if this pattern repeats in the rest of the string\n        const pattern = firstPart;\n        const remaining = text.substring(i * 2);\n        \n        // If the remaining part starts with the same pattern, we have duplication\n        if (remaining.startsWith(pattern)) {\n          return firstPart + remaining;\n        }\n      }\n    }\n    \n    // Fallback: just take the first half if we can't find the exact pattern\n    const halfLength = Math.floor(text.length / 2);\n    return text.substring(0, halfLength);\n  };\n\n  // New function to render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = (row) => {\n    // Clean up potentially duplicated original text\n    let original = row.original;\n    if (isDuplicatedText(original)) {\n      original = cleanDuplicatedText(original);\n    }\n    \n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row);\n    }\n    \n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"unprocessed-tag\">{original}</span>;\n    }\n    \n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n      \n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      \n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(\n            <span key={`unproc-${idx}`} className=\"unprocessed-tag\">{unprocessedText}</span>\n          );\n        }\n        \n        // Add the processed bracket content\n        result.push(\n          <span key={`proc-${idx}`} className=\"value-tag bracket-source\">{match.value}</span>\n        );\n        \n        lastIndex = match.endIndex;\n      });\n      \n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(\n          <span key=\"unproc-last\" className=\"unprocessed-tag\">\n            {original.substring(lastIndex)}\n          </span>\n        );\n      }\n      \n      return result;\n    } else if (row.type === 'delimiter-separation') {\n      // For delimiter separation, we need to reconstruct the sequence\n      \n      // First, gather all bracket parts with their exact positions\n      const allParts = [];\n      \n      // Add bracket parts first (they have exact position info)\n      if (row.previous && row.previous.matchDetails) {\n        // Use matchDetails directly from previous step for more accurate positioning\n        const matchDetails = row.previous.matchDetails || [];\n        \n        // Find and add bracket parts from the separated data\n        row.separated.forEach(item => {\n          if (item.source === 'bracket') {\n            const bracketInfo = item.bracketInfo;\n            if (bracketInfo) {\n              allParts.push({\n                value: item.value,\n                source: 'bracket',\n                startIndex: bracketInfo.startIndex,\n                endIndex: bracketInfo.endIndex,\n                exactPosition: true  // Flag that this has exact position\n              });\n            }\n          }\n        });\n      }\n      \n      // Add clean text parts with approximate positions\n      row.separated.forEach(item => {\n        if (item.source === 'clean-text') {\n          const value = item.value.trim();\n          if (value.length === 0) return;\n          \n          let position = -1;\n          \n          // First try to find the exact text in the original\n          position = original.indexOf(value);\n          \n          if (position >= 0) {\n            // Found position\n            allParts.push({\n              value: item.value,\n              source: 'clean-text',\n              startIndex: position,\n              endIndex: position + value.length,\n              exactPosition: false\n            });\n          } else {\n            // If not found exactly, add to the end\n            allParts.push({\n              value: item.value,\n              source: 'clean-text',\n              startIndex: Number.MAX_SAFE_INTEGER,\n              endIndex: Number.MAX_SAFE_INTEGER,\n              exactPosition: false\n            });\n          }\n        }\n      });\n      \n      // Add any delimiter parts\n      row.separated.forEach(item => {\n        if (item.source !== 'bracket' && item.source !== 'clean-text') {\n          allParts.push({\n            value: item.value,\n            source: item.source || 'delimiter',\n            startIndex: Number.MAX_SAFE_INTEGER,\n            endIndex: Number.MAX_SAFE_INTEGER,\n            exactPosition: false\n          });\n        }\n      });\n      \n      // Sort all parts by position\n      const sortedParts = [...allParts].sort((a, b) => {\n        // Always prioritize exact positions\n        if (a.exactPosition && !b.exactPosition) return -1;\n        if (!a.exactPosition && b.exactPosition) return 1;\n        \n        // Then sort by index\n        return a.startIndex - b.startIndex;\n      });\n      \n      // Now build the result elements in order\n      const resultElements = [];\n      let lastIndex = 0;\n      \n      // Add parts in order with unprocessed text in between\n      sortedParts.forEach((part, idx) => {\n        if (part.startIndex === Number.MAX_SAFE_INTEGER) return; // Skip unpositioned parts for now\n        \n        // Add unprocessed text between last part and this one\n        if (part.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, part.startIndex);\n          if (unprocessedText.trim().length > 0) {\n            resultElements.push(\n              <span key={`unproc-${idx}`} className=\"unprocessed-tag\">\n                {unprocessedText}\n              </span>\n            );\n          }\n        }\n        \n        // Add the part\n        resultElements.push(\n          <span \n            key={`part-${idx}`} \n            className={`value-tag ${part.source === 'bracket' ? 'bracket-source' : \n                                 part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n          >\n            {part.value}\n          </span>\n        );\n        \n        // Update last processed position\n        lastIndex = part.endIndex;\n      });\n      \n      // Add any remaining text\n      if (lastIndex < original.length) {\n        orderedElements.push(\n          <span key=\"unproc-last\" className=\"unprocessed-tag\">\n            {original.substring(lastIndex)}\n          </span>\n        );\n      }\n      \n      // Add unpositioned parts at the end\n      unpositionedParts.forEach((part, idx) => {\n        orderedElements.push(\n          <span \n            key={`unpos-${idx}`} \n            className={`value-tag ${part.source === 'bracket' ? 'bracket-source' : \n                                 part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n          >\n            {part.value}\n          </span>\n        );\n      });\n      \n      return orderedElements.length > 0 ? orderedElements : renderSeparatedValues(row);\n    }\n    \n    // Fallback to original display method\n    return renderSeparatedValues(row);\n  };\n\n  const renderSeparatedValues = (row) => {\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"no-values\">추출된 값 없음</span>;\n    }\n\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => (\n        <span key={idx} className=\"value-tag\">{val}</span>\n      ));\n    } \n    \n    // New format (with metadata)\n    return row.separated.map((item, idx) => (\n      <span \n        key={idx} \n        className={`value-tag ${item.source === 'bracket' ? 'bracket-source' : \n                              item.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n      >\n        {typeof item === 'string' ? item : item.value}\n      </span>\n    ));\n  };\n\n  return (\n    <table className=\"data-table\">\n      <tbody>\n        {flattenData(processedData).map((row, index) => (\n          <tr key={index}>\n            <td className=\"enhanced-view\">\n              {renderEnhancedView(row)}\n            </td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n};\n\nexport default DataDisplay; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/reorganize/channel-list-app/src/components/MiningView.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MiningView = ({\n  combinationHeaders,\n  loading,\n  error,\n  testMode\n}) => {\n  _s();\n  const [miningData, setMiningData] = useState(null);\n  const [expandedNodes, setExpandedNodes] = useState({});\n  const [highlightedPattern, setHighlightedPattern] = useState(null);\n  const [algorithm, setAlgorithm] = useState('eclat'); // 'eclat' or 'fpgrowth'\n  const [minSupport, setMinSupport] = useState(0.1); // 10% default\n  const [minConfidence, setMinConfidence] = useState(0.5); // 50% default\n  const [maxDepth, setMaxDepth] = useState(15); // Increased default depth for deeper patterns\n  const svgRef = useRef(null);\n\n  // 데이터가 변경될 때마다 마이닝 실행\n  useEffect(() => {\n    if (combinationHeaders && combinationHeaders.length > 0) {\n      generateMiningData(combinationHeaders, algorithm);\n    } else {\n      setMiningData(null);\n    }\n  }, [combinationHeaders, algorithm, minSupport, minConfidence, maxDepth]);\n\n  // Effect to update SVG visualization when mining data changes\n  useEffect(() => {\n    if (miningData && svgRef.current) {\n      renderMiningTree();\n    }\n  }, [miningData, expandedNodes, highlightedPattern]);\n\n  // Function to render a unified hierarchical tree visualization\n  const renderMiningTree = () => {\n    if (!svgRef.current || !miningData) return;\n    const svg = svgRef.current;\n    // Clear previous content\n    while (svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n    const CONTAINER_WIDTH = svg.clientWidth || 300;\n    const NODE_HEIGHT = 34; // Slightly larger height for better readability\n    const NODE_SPACING = 10; // Increased spacing between nodes\n    const LEVEL_INDENT = 28; // Increased indent for better hierarchy visualization\n\n    // Calculate tree structure based on expanded nodes\n    const treeNodes = [];\n    let yOffset = 20; // Initial top padding\n\n    // Skip the root node and start directly with top-level items\n\n    // Recursive function to add nodes\n    const addNodesRecursively = (nodes, parentId, level, isVisible) => {\n      if (!nodes || nodes.length === 0) return;\n\n      // Sort nodes by support for better visualization\n      const sortedNodes = [...nodes].sort((a, b) => b.support - a.support);\n      sortedNodes.forEach(node => {\n        // Skip if parent is collapsed\n        if (!isVisible) return;\n        const isExpanded = expandedNodes[node.id] || false;\n\n        // Add current node\n        treeNodes.push({\n          ...node,\n          level,\n          x: 10 + level * LEVEL_INDENT,\n          y: yOffset,\n          isExpanded,\n          parent: parentId\n        });\n\n        // Increment y-position for next node\n        yOffset += NODE_HEIGHT + NODE_SPACING;\n\n        // Process children if any\n        if (node.children && node.children.length > 0) {\n          addNodesRecursively(node.children, node.id, level + 1, isVisible && isExpanded);\n        }\n      });\n    };\n\n    // Add all nodes from mining data starting without a root\n    // Sort top-level items by support\n    const sortedTopNodes = [...miningData].sort((a, b) => b.support - a.support);\n    addNodesRecursively(sortedTopNodes, null, 0, true);\n\n    // Set SVG height based on content\n    svg.setAttribute('height', `${yOffset + 20}px`); // Add bottom padding\n\n    // Create a container for the SVG elements\n    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    svg.appendChild(container);\n\n    // Draw connections between nodes\n    treeNodes.forEach(node => {\n      if (node.parent) {\n        const parent = treeNodes.find(n => n.id === node.parent);\n        if (parent) {\n          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n          const startX = parent.x + 8; // Start from parent indentation + offset\n          const startY = parent.y + NODE_HEIGHT / 2;\n          const endX = node.x;\n          const endY = node.y + NODE_HEIGHT / 2;\n\n          // Create an elbow connector (straight lines with 90-degree turn)\n          const d = `M ${startX} ${startY} L ${startX + 5} ${startY} L ${startX + 5} ${endY} L ${endX} ${endY}`;\n          path.setAttribute('d', d);\n          path.setAttribute('fill', 'none');\n\n          // Highlight path if node is part of highlighted pattern\n          const isHighlighted = highlightedPattern && highlightedPattern.includes(node.id) && highlightedPattern.includes(parent.id);\n          path.setAttribute('stroke', isHighlighted ? '#999' : '#eee');\n          path.setAttribute('stroke-width', isHighlighted ? '1.5' : '1');\n          container.appendChild(path);\n        }\n      }\n    });\n\n    // Draw nodes\n    treeNodes.forEach(node => {\n      const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      nodeGroup.setAttribute('transform', `translate(${node.x}, ${node.y})`);\n\n      // Node background (rectangle)\n      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n\n      // Calculate width based on content and level\n      const baseWidth = CONTAINER_WIDTH - node.x - 30;\n      const width = Math.min(baseWidth, 240); // Increased max width for better readability\n\n      rect.setAttribute('width', width);\n      rect.setAttribute('height', NODE_HEIGHT);\n      rect.setAttribute('rx', 4); // Rounded corners\n\n      // Determine fill color based on level and highlight state\n      const isHighlighted = highlightedPattern && highlightedPattern.includes(node.id);\n\n      // Use a more monotone color scheme, with slight variation for top-level vs child nodes\n      let fillColor = node.level === 0 ? '#f5f5f5' : '#fafafa';\n      if (isHighlighted) {\n        fillColor = '#f0f0f0'; // Slightly different shade for highlighted nodes\n      }\n      rect.setAttribute('fill', fillColor);\n      rect.setAttribute('stroke', isHighlighted ? '#999' : '#ddd');\n      rect.setAttribute('stroke-width', isHighlighted ? '1.5' : '1');\n\n      // Make nodes interactive\n      if (node.children && node.children.length > 0) {\n        nodeGroup.style.cursor = 'pointer';\n\n        // Toggle expansion on click\n        nodeGroup.addEventListener('click', () => {\n          toggleNode(node.id);\n        });\n      }\n\n      // Hover effect for highlighting patterns\n      nodeGroup.addEventListener('mouseenter', () => {\n        // Find all ancestors and highlight the path\n        const pattern = [node.id];\n        let currentNode = node;\n        while (currentNode.parent) {\n          pattern.push(currentNode.parent);\n          currentNode = treeNodes.find(n => n.id === currentNode.parent);\n          if (!currentNode) break;\n        }\n        setHighlightedPattern(pattern);\n      });\n      nodeGroup.addEventListener('mouseleave', () => {\n        setHighlightedPattern(null);\n      });\n\n      // Add expansion indicator if node has children\n      if (node.children && node.children.length > 0) {\n        const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        indicator.textContent = node.isExpanded ? '−' : '+';\n        indicator.setAttribute('x', width - 15);\n        indicator.setAttribute('y', NODE_HEIGHT / 2 + 4);\n        indicator.setAttribute('font-size', '12px');\n        indicator.setAttribute('font-weight', 'bold');\n        indicator.setAttribute('fill', '#888');\n        nodeGroup.appendChild(indicator);\n      }\n\n      // Node label - truncate if needed\n      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttribute('x', 8);\n      text.setAttribute('y', NODE_HEIGHT / 2 + 4);\n      text.setAttribute('font-size', node.level === 0 ? '12px' : '11px');\n      text.setAttribute('font-weight', node.level === 0 ? 'bold' : 'normal');\n      text.setAttribute('fill', '#333');\n\n      // Make sure text fits\n      const maxTextWidth = width - 60; // Leave room for support and indicator\n      let displayText = node.name;\n      if (displayText.length > 25) {\n        // Allow longer text to display\n        displayText = displayText.substring(0, 23) + '...';\n      }\n      text.textContent = displayText;\n\n      // Support count\n      const supportText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      supportText.setAttribute('x', width - 30);\n      supportText.setAttribute('y', NODE_HEIGHT / 2 + 4);\n      supportText.setAttribute('font-size', '11px');\n      supportText.setAttribute('text-anchor', 'end');\n      supportText.setAttribute('fill', '#555');\n      supportText.setAttribute('font-weight', node.level === 0 ? 'bold' : 'normal');\n      supportText.textContent = node.support;\n      nodeGroup.appendChild(rect);\n      nodeGroup.appendChild(text);\n      nodeGroup.appendChild(supportText);\n      container.appendChild(nodeGroup);\n    });\n  };\n\n  // Function to generate mining data using Eclat or FP Growth algorithm\n  const generateMiningData = (combinationData, algo = 'eclat') => {\n    if (!combinationData || combinationData.length === 0) {\n      setMiningData(null);\n      return;\n    }\n\n    // Step 1: Create transactions from header combinations\n    const transactions = combinationData.filter(item => item.header_group).map(item => item.header_group.split('|'));\n\n    // Step 2: Count item frequencies for both algorithms\n    const itemCounts = {};\n    const totalTransactions = transactions.length;\n    transactions.forEach(transaction => {\n      transaction.forEach(item => {\n        itemCounts[item] = (itemCounts[item] || 0) + 1;\n      });\n    });\n\n    // Calculate minimum support threshold - use absolute minimum of 2\n    const minSupportCount = Math.max(2, Math.floor(totalTransactions * minSupport));\n\n    // Get frequent items sorted by frequency\n    const frequentItems = Object.keys(itemCounts).filter(item => itemCounts[item] >= minSupportCount).sort((a, b) => itemCounts[b] - itemCounts[a]);\n    if (algo === 'eclat') {\n      // ECLAT ALGORITHM IMPLEMENTATION\n\n      // Step 1: Build vertical tid-lists (transaction ID lists) for each item\n      const tidLists = {};\n      frequentItems.forEach(item => {\n        tidLists[item] = new Set();\n      });\n      transactions.forEach((transaction, tid) => {\n        transaction.forEach(item => {\n          if (frequentItems.includes(item)) {\n            tidLists[item].add(tid);\n          }\n        });\n      });\n\n      // Step 2: Find frequent itemsets using ECLAT recursion\n      const frequentItemsets = {};\n\n      // Initialize with single items\n      frequentItems.forEach(item => {\n        const support = tidLists[item].size;\n        frequentItemsets[item] = {\n          support,\n          confidence: support / totalTransactions,\n          tids: tidLists[item],\n          children: {}\n        };\n      });\n\n      // Recursive function to find frequent itemsets (allowing deeper patterns)\n      const eclat = (prefix, tidList, level, parent) => {\n        if (level > maxDepth) return; // Increased depth limit\n\n        // Find extensions with all items that come after the prefix's last item\n        const lastItem = prefix[prefix.length - 1];\n        const lastItemIndex = frequentItems.indexOf(lastItem);\n        for (let i = lastItemIndex + 1; i < frequentItems.length; i++) {\n          const item = frequentItems[i];\n          const itemTids = tidLists[item];\n\n          // Compute intersection\n          const intersection = new Set([...tidList].filter(tid => itemTids.has(tid)));\n          const support = intersection.size;\n\n          // If support is high enough, add to frequent itemsets\n          // Modified to use absolute minimum count of 2 rather than percentage-based\n          if (support >= Math.max(2, minSupportCount)) {\n            const newPrefix = [...prefix, item];\n            const newPrefixStr = item; // Just use the extension item as key\n\n            // Calculate confidence (support of extended pattern / support of prefix)\n            const confidence = support / tidList.size;\n\n            // Modified confidence check to be lower for deeper patterns\n            if (confidence >= (level > 3 ? minConfidence / 2 : minConfidence)) {\n              parent.children[newPrefixStr] = {\n                support,\n                confidence,\n                tids: intersection,\n                children: {}\n              };\n\n              // Recursively find extensions of this new prefix\n              eclat(newPrefix, intersection, level + 1, parent.children[newPrefixStr]);\n            }\n          }\n        }\n      };\n\n      // Start ECLAT recursion for each single item\n      frequentItems.forEach(item => {\n        eclat([item], tidLists[item], 1, frequentItemsets[item]);\n      });\n\n      // Convert to array format for visualization\n      const buildDeepNestedTree = itemsets => {\n        const result = [];\n        frequentItems.forEach(item => {\n          const itemData = {\n            id: item,\n            name: item,\n            support: tidLists[item].size,\n            confidence: tidLists[item].size / totalTransactions,\n            children: []\n          };\n\n          // 재귀적으로 모든 자식 노드를 추가하는 함수\n          const addChildrenRecursively = (parentId, parentNode, currentItemset) => {\n            const children = currentItemset.children || {};\n            Object.entries(children).forEach(([childKey, childValue]) => {\n              const childId = `${parentId}-${childKey}`;\n              const childNode = {\n                id: childId,\n                name: childKey,\n                support: childValue.support,\n                confidence: childValue.confidence,\n                children: []\n              };\n              parentNode.children.push(childNode);\n\n              // 재귀적으로 손자 노드 처리\n              addChildrenRecursively(childId, childNode, childValue);\n            });\n          };\n\n          // 첫 레벨 자식 노드 추가\n          addChildrenRecursively(item, itemData, frequentItemsets[item]);\n          result.push(itemData);\n        });\n        return result;\n      };\n      const result = buildDeepNestedTree(frequentItemsets);\n      setMiningData(result);\n    } else {\n      // FP GROWTH ALGORITHM - UNIFIED TREE IMPLEMENTATION\n\n      // Step 3: Reorder transactions based on frequency\n      const orderedTransactions = transactions.map(transaction => {\n        return transaction.filter(item => frequentItems.includes(item)).sort((a, b) => itemCounts[b] - itemCounts[a]);\n      }).filter(transaction => transaction.length > 0);\n\n      // Step 4: Build unified FP-Tree\n      const fpTree = {\n        name: \"root\",\n        count: 0,\n        children: {},\n        nodeLinks: {} // Header table node links\n      };\n\n      // Initialize header table\n      const headerTable = {};\n      frequentItems.forEach(item => {\n        headerTable[item] = {\n          count: itemCounts[item],\n          nodeLink: null\n        };\n      });\n\n      // Insert a transaction into the FP-Tree\n      const insertTransaction = (transaction, tree, count = 1) => {\n        if (transaction.length === 0) return;\n        const item = transaction[0];\n\n        // Create node if it doesn't exist\n        if (!tree.children[item]) {\n          tree.children[item] = {\n            name: item,\n            count: 0,\n            children: {},\n            parent: tree,\n            nextSameItem: null\n          };\n\n          // Update header table node links\n          if (!headerTable[item].nodeLink) {\n            headerTable[item].nodeLink = tree.children[item];\n          } else {\n            let current = headerTable[item].nodeLink;\n            while (current.nextSameItem) {\n              current = current.nextSameItem;\n            }\n            current.nextSameItem = tree.children[item];\n          }\n        }\n\n        // Increment count\n        tree.children[item].count += count;\n\n        // Insert remaining items\n        if (transaction.length > 1) {\n          insertTransaction(transaction.slice(1), tree.children[item], count);\n        }\n      };\n\n      // Insert all transactions\n      orderedTransactions.forEach(transaction => {\n        insertTransaction(transaction, fpTree);\n      });\n\n      // Step 5: Mine patterns using FP-Growth\n      const patterns = {};\n\n      // Mine patterns with a suffix\n      const minePatterns = (headerTable, conditionalBase, suffix = [], parentSupport = totalTransactions) => {\n        // Get items in descending order of frequency\n        const items = Object.keys(headerTable).sort((a, b) => headerTable[b].count - headerTable[a].count);\n        for (const item of items) {\n          // New frequent itemset found\n          const newSuffix = [item, ...suffix];\n          const supportCount = headerTable[item].count;\n\n          // Calculate confidence for patterns with len > 1\n          const confidence = newSuffix.length > 1 ? supportCount / parentSupport : supportCount / totalTransactions;\n\n          // Only include if confidence meets threshold\n          if (confidence >= minConfidence) {\n            // Store pattern\n            const patternKey = newSuffix.join('-');\n            patterns[patternKey] = {\n              items: newSuffix,\n              support: supportCount,\n              confidence: confidence\n            };\n\n            // Build conditional pattern base\n            const conditionalPatternBase = [];\n            let node = headerTable[item].nodeLink;\n            while (node) {\n              // Traverse upward to get the path\n              const path = [];\n              let prefixSupport = node.count;\n              let parent = node.parent;\n              while (parent && parent.name !== \"root\") {\n                path.unshift(parent.name);\n                parent = parent.parent;\n              }\n              if (path.length > 0) {\n                conditionalPatternBase.push({\n                  path,\n                  count: prefixSupport\n                });\n              }\n              node = node.nextSameItem;\n            }\n\n            // Build conditional FP-Tree\n            if (conditionalPatternBase.length > 0) {\n              const newConditionalBase = {};\n\n              // Count items in the conditional pattern base\n              conditionalPatternBase.forEach(({\n                path,\n                count\n              }) => {\n                path.forEach(pathItem => {\n                  newConditionalBase[pathItem] = (newConditionalBase[pathItem] || 0) + count;\n                });\n              });\n\n              // Filter items by minimum support\n              const newHeaderTable = {};\n              Object.keys(newConditionalBase).forEach(item => {\n                // Use a fixed threshold of 2 for deeper patterns\n                if (newConditionalBase[item] >= Math.max(2, minSupportCount)) {\n                  newHeaderTable[item] = {\n                    count: newConditionalBase[item],\n                    nodeLink: null\n                  };\n                }\n              });\n\n              // Recursively mine with the new conditional tree, up to more depth\n              if (Object.keys(newHeaderTable).length > 0 && newSuffix.length < maxDepth) {\n                minePatterns(newHeaderTable, conditionalPatternBase, newSuffix, supportCount);\n              }\n            }\n          }\n        }\n      };\n\n      // Start mining\n      minePatterns(headerTable, []);\n\n      // Build tree from patterns\n      const buildTree = patterns => {\n        const result = [];\n        const itemMap = {};\n\n        // Group by first item\n        Object.values(patterns).forEach(pattern => {\n          if (pattern.items.length > 0) {\n            const firstItem = pattern.items[0];\n            if (!itemMap[firstItem]) {\n              itemMap[firstItem] = {\n                id: firstItem,\n                name: firstItem,\n                support: itemCounts[firstItem],\n                confidence: itemCounts[firstItem] / totalTransactions,\n                children: []\n              };\n              result.push(itemMap[firstItem]);\n            }\n\n            // Add subsequent items as children\n            if (pattern.items.length > 1) {\n              let currentNode = itemMap[firstItem];\n              let currentPath = firstItem;\n              for (let i = 1; i < pattern.items.length; i++) {\n                const currentItem = pattern.items[i];\n                currentPath = `${currentPath}-${currentItem}`;\n\n                // Check if child already exists\n                let childNode = currentNode.children.find(child => child.name === currentItem);\n                if (!childNode) {\n                  childNode = {\n                    id: currentPath,\n                    name: currentItem,\n                    support: pattern.support,\n                    confidence: pattern.confidence,\n                    children: []\n                  };\n                  currentNode.children.push(childNode);\n                }\n                currentNode = childNode;\n              }\n            }\n          }\n        });\n        return result;\n      };\n      const result = buildTree(patterns);\n      setMiningData(result);\n    }\n\n    // Initialize expanded state for visualization\n    const initialExpanded = {};\n    // Auto-expand some top nodes for better initial view\n    if (miningData && miningData.length > 0) {\n      // Expand all top-level nodes and their first children\n      miningData.forEach(node => {\n        initialExpanded[node.id] = true;\n\n        // Also expand first child of each top node if available\n        if (node.children && node.children.length > 0) {\n          const firstChild = node.children[0];\n          initialExpanded[firstChild.id] = true;\n        }\n      });\n    }\n    setExpandedNodes(initialExpanded);\n  };\n\n  // Switch between algorithms\n  const switchAlgorithm = algo => {\n    setAlgorithm(algo);\n  };\n\n  // Change minimum support threshold\n  const handleSupportChange = e => {\n    const value = parseFloat(e.target.value);\n    if (!isNaN(value) && value > 0 && value <= 1) {\n      setMinSupport(value);\n    }\n  };\n\n  // Change minimum confidence threshold\n  const handleConfidenceChange = e => {\n    const value = parseFloat(e.target.value);\n    if (!isNaN(value) && value > 0 && value <= 1) {\n      setMinConfidence(value);\n    }\n  };\n\n  // Change maximum depth\n  const handleDepthChange = e => {\n    const value = parseInt(e.target.value);\n    if (!isNaN(value) && value > 0) {\n      setMaxDepth(value);\n    }\n  };\n\n  // Function to toggle node expansion\n  const toggleNode = nodeId => {\n    setExpandedNodes(prev => ({\n      ...prev,\n      [nodeId]: !prev[nodeId]\n    }));\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"tab-content\",\n    children: [loading ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"loading\",\n      children: \"\\uB85C\\uB529 \\uC911...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 654,\n      columnNumber: 9\n    }, this) : error ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"error\",\n      children: [\"\\uC5D0\\uB7EC: \", error]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 656,\n      columnNumber: 9\n    }, this) : combinationHeaders && combinationHeaders.length > 0 ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mining-view\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"mining-controls\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"algorithm-selector\",\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            className: `algorithm-btn ${algorithm === 'eclat' ? 'active' : ''}`,\n            onClick: () => switchAlgorithm('eclat'),\n            children: \"Eclat \\uC54C\\uACE0\\uB9AC\\uC998\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 661,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            className: `algorithm-btn ${algorithm === 'fpgrowth' ? 'active' : ''}`,\n            onClick: () => switchAlgorithm('fpgrowth'),\n            children: \"FP-Growth \\uC54C\\uACE0\\uB9AC\\uC998\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 667,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 660,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"thresholds-control\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"threshold-item\",\n            children: [/*#__PURE__*/_jsxDEV(\"label\", {\n              children: [\"\\uCD5C\\uC18C \\uC9C0\\uC9C0\\uB3C4 (Minimum Support): \", (minSupport * 100).toFixed(0), \"%\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 676,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"range\",\n              min: \"0.01\",\n              max: \"0.5\",\n              step: \"0.05\",\n              value: minSupport,\n              onChange: handleSupportChange\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 677,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 675,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"threshold-item\",\n            children: [/*#__PURE__*/_jsxDEV(\"label\", {\n              children: [\"\\uCD5C\\uC18C \\uC2E0\\uB8B0\\uB3C4 (Minimum Confidence): \", (minConfidence * 100).toFixed(0), \"%\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 687,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"range\",\n              min: \"0.01\",\n              max: \"0.9\",\n              step: \"0.1\",\n              value: minConfidence,\n              onChange: handleConfidenceChange\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 688,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 686,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"threshold-item\",\n            children: [/*#__PURE__*/_jsxDEV(\"label\", {\n              children: [\"\\uCD5C\\uB300 \\uD328\\uD134 \\uAE4A\\uC774 (Maximum Pattern Depth): \", maxDepth]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 698,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"range\",\n              min: \"3\",\n              max: \"20\",\n              step: \"1\",\n              value: maxDepth,\n              onChange: handleDepthChange\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 699,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 697,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 674,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 659,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"mining-tree-container\",\n        children: /*#__PURE__*/_jsxDEV(\"svg\", {\n          className: \"mining-tree-svg\",\n          ref: svgRef,\n          width: \"100%\",\n          height: \"400\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 712,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 711,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"mining-explanation\",\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          children: [algorithm === 'eclat' ? 'Eclat' : 'FP-Growth', \" \\uC54C\\uACE0\\uB9AC\\uC998 \\uD328\\uD134 \\uC2DC\\uAC01\\uD654:\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 721,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n          children: [/*#__PURE__*/_jsxDEV(\"li\", {\n            children: \"\\uD328\\uD134 \\uCD9C\\uD604 \\uBE48\\uB3C4 \\uAE30\\uC900 \\uB0B4\\uB9BC\\uCC28\\uC21C\\uC73C\\uB85C \\uC815\\uB82C\\uB428\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 723,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n            children: \"\\uD328\\uD134 \\uD074\\uB9AD: \\uD558\\uC704 \\uD328\\uD134 \\uD655\\uC7A5/\\uCD95\\uC18C\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 724,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n            children: \"\\uB9C8\\uC6B0\\uC2A4 \\uC624\\uBC84: \\uD328\\uD134 \\uACBD\\uB85C \\uD558\\uC774\\uB77C\\uC774\\uD2B8\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 725,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n            children: \"\\uC22B\\uC790: \\uD328\\uD134 \\uBC1C\\uC0DD \\uBE48\\uB3C4 (\\uCD5C\\uC18C 2\\uD68C \\uC774\\uC0C1)\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 726,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 722,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 720,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 658,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"column-empty\",\n      children: testMode ? \"마이닝 데이터를 로딩 중입니다...\" : \"채널과 헤더를 선택하면 마이닝 결과가 표시됩니다.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 731,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"style\", {\n      jsx: true,\n      children: `\n        .mining-view {\n          height: 100%;\n          display: flex;\n          flex-direction: column;\n        }\n        \n        .mining-controls {\n          display: flex;\n          flex-direction: column;\n          gap: 8px;\n          margin-bottom: 12px;\n          background-color: #fafafa;\n          border-radius: 4px;\n          padding: 8px;\n        }\n        \n        .algorithm-selector {\n          display: flex;\n          gap: 8px;\n        }\n        \n        .algorithm-btn {\n          background: #f7f7f7;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          padding: 4px 8px;\n          font-size: 12px;\n          cursor: pointer;\n        }\n        \n        .algorithm-btn.active {\n          background: #666;\n          color: white;\n          border-color: #666;\n        }\n        \n        .thresholds-control {\n          display: flex;\n          flex-direction: column;\n          gap: 6px;\n        }\n        \n        .threshold-item {\n          display: flex;\n          flex-direction: column;\n          font-size: 11px;\n        }\n        \n        .threshold-item label {\n          margin-bottom: 2px;\n        }\n        \n        .threshold-item input {\n          width: 100%;\n        }\n        \n        .mining-tree-container {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: auto;\n          background-color: #ffffff;\n          flex-grow: 1;\n          min-height: 350px;  // Increased minimum height\n          padding: 10px;\n          box-shadow: inset 0 0 3px rgba(0,0,0,0.05);\n        }\n        \n        .mining-explanation {\n          margin-top: 10px;\n          font-size: 11px;\n          color: #666;\n          background-color: #f9f9f9;\n          border-radius: 4px;\n          padding: 6px 10px;\n        }\n        \n        .mining-explanation ul {\n          padding-left: 16px;\n          margin: 4px 0;\n        }\n        \n        .mining-explanation p {\n          margin: 4px 0;\n          font-weight: bold;\n        }\n        \n        .mining-explanation li {\n          margin-bottom: 2px;\n        }\n      `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 738,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 652,\n    columnNumber: 5\n  }, this);\n};\n_s(MiningView, \"ofkUh6S3WiU8oHxI2JxZeDsQV10=\");\n_c = MiningView;\nexport default MiningView;\nvar _c;\n$RefreshReg$(_c, \"MiningView\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","MiningView","combinationHeaders","loading","error","testMode","_s","miningData","setMiningData","expandedNodes","setExpandedNodes","highlightedPattern","setHighlightedPattern","algorithm","setAlgorithm","minSupport","setMinSupport","minConfidence","setMinConfidence","maxDepth","setMaxDepth","svgRef","length","generateMiningData","current","renderMiningTree","svg","firstChild","removeChild","CONTAINER_WIDTH","clientWidth","NODE_HEIGHT","NODE_SPACING","LEVEL_INDENT","treeNodes","yOffset","addNodesRecursively","nodes","parentId","level","isVisible","sortedNodes","sort","a","b","support","forEach","node","isExpanded","id","push","x","y","parent","children","sortedTopNodes","setAttribute","container","document","createElementNS","appendChild","find","n","path","startX","startY","endX","endY","d","isHighlighted","includes","nodeGroup","rect","baseWidth","width","Math","min","fillColor","style","cursor","addEventListener","toggleNode","pattern","currentNode","indicator","textContent","text","maxTextWidth","displayText","name","substring","supportText","combinationData","algo","transactions","filter","item","header_group","map","split","itemCounts","totalTransactions","transaction","minSupportCount","max","floor","frequentItems","Object","keys","tidLists","Set","tid","add","frequentItemsets","size","confidence","tids","eclat","prefix","tidList","lastItem","lastItemIndex","indexOf","i","itemTids","intersection","has","newPrefix","newPrefixStr","buildDeepNestedTree","itemsets","result","itemData","addChildrenRecursively","parentNode","currentItemset","entries","childKey","childValue","childId","childNode","orderedTransactions","fpTree","count","nodeLinks","headerTable","nodeLink","insertTransaction","tree","nextSameItem","slice","patterns","minePatterns","conditionalBase","suffix","parentSupport","items","newSuffix","supportCount","patternKey","join","conditionalPatternBase","prefixSupport","unshift","newConditionalBase","pathItem","newHeaderTable","buildTree","itemMap","values","firstItem","currentPath","currentItem","child","initialExpanded","switchAlgorithm","handleSupportChange","e","value","parseFloat","target","isNaN","handleConfidenceChange","handleDepthChange","parseInt","nodeId","prev","className","fileName","_jsxFileName","lineNumber","columnNumber","onClick","toFixed","type","step","onChange","ref","height","jsx","_c","$RefreshReg$"],"sources":["/Users/francesson/reorganize/channel-list-app/src/components/MiningView.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\n\nconst MiningView = ({ combinationHeaders, loading, error, testMode }) => {\n  const [miningData, setMiningData] = useState(null);\n  const [expandedNodes, setExpandedNodes] = useState({});\n  const [highlightedPattern, setHighlightedPattern] = useState(null);\n  const [algorithm, setAlgorithm] = useState('eclat'); // 'eclat' or 'fpgrowth'\n  const [minSupport, setMinSupport] = useState(0.1); // 10% default\n  const [minConfidence, setMinConfidence] = useState(0.5); // 50% default\n  const [maxDepth, setMaxDepth] = useState(15); // Increased default depth for deeper patterns\n  const svgRef = useRef(null);\n\n  // 데이터가 변경될 때마다 마이닝 실행\n  useEffect(() => {\n    if (combinationHeaders && combinationHeaders.length > 0) {\n      generateMiningData(combinationHeaders, algorithm);\n    } else {\n      setMiningData(null);\n    }\n  }, [combinationHeaders, algorithm, minSupport, minConfidence, maxDepth]);\n\n  // Effect to update SVG visualization when mining data changes\n  useEffect(() => {\n    if (miningData && svgRef.current) {\n      renderMiningTree();\n    }\n  }, [miningData, expandedNodes, highlightedPattern]);\n\n  // Function to render a unified hierarchical tree visualization\n  const renderMiningTree = () => {\n    if (!svgRef.current || !miningData) return;\n\n    const svg = svgRef.current;\n    // Clear previous content\n    while (svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n\n    const CONTAINER_WIDTH = svg.clientWidth || 300;\n    const NODE_HEIGHT = 34; // Slightly larger height for better readability\n    const NODE_SPACING = 10; // Increased spacing between nodes\n    const LEVEL_INDENT = 28; // Increased indent for better hierarchy visualization\n    \n    // Calculate tree structure based on expanded nodes\n    const treeNodes = [];\n    let yOffset = 20;  // Initial top padding\n    \n    // Skip the root node and start directly with top-level items\n    \n    // Recursive function to add nodes\n    const addNodesRecursively = (nodes, parentId, level, isVisible) => {\n      if (!nodes || nodes.length === 0) return;\n      \n      // Sort nodes by support for better visualization\n      const sortedNodes = [...nodes].sort((a, b) => b.support - a.support);\n      \n      sortedNodes.forEach(node => {\n        // Skip if parent is collapsed\n        if (!isVisible) return;\n        \n        const isExpanded = expandedNodes[node.id] || false;\n        \n        // Add current node\n        treeNodes.push({\n          ...node,\n          level,\n          x: 10 + (level * LEVEL_INDENT),\n          y: yOffset,\n          isExpanded,\n          parent: parentId\n        });\n        \n        // Increment y-position for next node\n        yOffset += NODE_HEIGHT + NODE_SPACING;\n        \n        // Process children if any\n        if (node.children && node.children.length > 0) {\n          addNodesRecursively(node.children, node.id, level + 1, isVisible && isExpanded);\n        }\n      });\n    };\n    \n    // Add all nodes from mining data starting without a root\n    // Sort top-level items by support\n    const sortedTopNodes = [...miningData].sort((a, b) => b.support - a.support);\n    addNodesRecursively(sortedTopNodes, null, 0, true);\n    \n    // Set SVG height based on content\n    svg.setAttribute('height', `${yOffset + 20}px`);  // Add bottom padding\n    \n    // Create a container for the SVG elements\n    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    svg.appendChild(container);\n    \n    // Draw connections between nodes\n    treeNodes.forEach(node => {\n      if (node.parent) {\n        const parent = treeNodes.find(n => n.id === node.parent);\n        if (parent) {\n          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n          \n          const startX = parent.x + 8;  // Start from parent indentation + offset\n          const startY = parent.y + (NODE_HEIGHT / 2);\n          const endX = node.x;\n          const endY = node.y + (NODE_HEIGHT / 2);\n          \n          // Create an elbow connector (straight lines with 90-degree turn)\n          const d = `M ${startX} ${startY} L ${startX + 5} ${startY} L ${startX + 5} ${endY} L ${endX} ${endY}`;\n          \n          path.setAttribute('d', d);\n          path.setAttribute('fill', 'none');\n          \n          // Highlight path if node is part of highlighted pattern\n          const isHighlighted = highlightedPattern && (\n            highlightedPattern.includes(node.id) && highlightedPattern.includes(parent.id)\n          );\n          \n          path.setAttribute('stroke', isHighlighted ? '#999' : '#eee');\n          path.setAttribute('stroke-width', isHighlighted ? '1.5' : '1');\n          \n          container.appendChild(path);\n        }\n      }\n    });\n    \n    // Draw nodes\n    treeNodes.forEach(node => {\n      const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      nodeGroup.setAttribute('transform', `translate(${node.x}, ${node.y})`);\n      \n      // Node background (rectangle)\n      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n      \n      // Calculate width based on content and level\n      const baseWidth = CONTAINER_WIDTH - node.x - 30;\n      const width = Math.min(baseWidth, 240);  // Increased max width for better readability\n      \n      rect.setAttribute('width', width);\n      rect.setAttribute('height', NODE_HEIGHT);\n      rect.setAttribute('rx', 4);  // Rounded corners\n      \n      // Determine fill color based on level and highlight state\n      const isHighlighted = highlightedPattern && highlightedPattern.includes(node.id);\n      \n      // Use a more monotone color scheme, with slight variation for top-level vs child nodes\n      let fillColor = node.level === 0 ? '#f5f5f5' : '#fafafa'; \n      \n      if (isHighlighted) {\n        fillColor = '#f0f0f0'; // Slightly different shade for highlighted nodes\n      }\n      \n      rect.setAttribute('fill', fillColor);\n      rect.setAttribute('stroke', isHighlighted ? '#999' : '#ddd');\n      rect.setAttribute('stroke-width', isHighlighted ? '1.5' : '1');\n      \n      // Make nodes interactive\n      if (node.children && node.children.length > 0) {\n        nodeGroup.style.cursor = 'pointer';\n        \n        // Toggle expansion on click\n        nodeGroup.addEventListener('click', () => {\n          toggleNode(node.id);\n        });\n      }\n      \n      // Hover effect for highlighting patterns\n      nodeGroup.addEventListener('mouseenter', () => {\n        // Find all ancestors and highlight the path\n        const pattern = [node.id];\n        let currentNode = node;\n        \n        while (currentNode.parent) {\n          pattern.push(currentNode.parent);\n          currentNode = treeNodes.find(n => n.id === currentNode.parent);\n          if (!currentNode) break;\n        }\n        \n        setHighlightedPattern(pattern);\n      });\n      \n      nodeGroup.addEventListener('mouseleave', () => {\n        setHighlightedPattern(null);\n      });\n      \n      // Add expansion indicator if node has children\n      if (node.children && node.children.length > 0) {\n        const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        indicator.textContent = node.isExpanded ? '−' : '+';\n        indicator.setAttribute('x', width - 15);\n        indicator.setAttribute('y', NODE_HEIGHT / 2 + 4);\n        indicator.setAttribute('font-size', '12px');\n        indicator.setAttribute('font-weight', 'bold');\n        indicator.setAttribute('fill', '#888');\n        nodeGroup.appendChild(indicator);\n      }\n      \n      // Node label - truncate if needed\n      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttribute('x', 8);\n      text.setAttribute('y', NODE_HEIGHT / 2 + 4);\n      text.setAttribute('font-size', node.level === 0 ? '12px' : '11px');\n      text.setAttribute('font-weight', node.level === 0 ? 'bold' : 'normal');\n      text.setAttribute('fill', '#333');\n      \n      // Make sure text fits\n      const maxTextWidth = width - 60;  // Leave room for support and indicator\n      let displayText = node.name;\n      \n      if (displayText.length > 25) {  // Allow longer text to display\n        displayText = displayText.substring(0, 23) + '...';\n      }\n      \n      text.textContent = displayText;\n      \n      // Support count\n      const supportText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      supportText.setAttribute('x', width - 30);\n      supportText.setAttribute('y', NODE_HEIGHT / 2 + 4);\n      supportText.setAttribute('font-size', '11px');\n      supportText.setAttribute('text-anchor', 'end');\n      supportText.setAttribute('fill', '#555');\n      supportText.setAttribute('font-weight', node.level === 0 ? 'bold' : 'normal');\n      supportText.textContent = node.support;\n      \n      nodeGroup.appendChild(rect);\n      nodeGroup.appendChild(text);\n      nodeGroup.appendChild(supportText);\n      container.appendChild(nodeGroup);\n    });\n  };\n  \n  // Function to generate mining data using Eclat or FP Growth algorithm\n  const generateMiningData = (combinationData, algo = 'eclat') => {\n    if (!combinationData || combinationData.length === 0) {\n      setMiningData(null);\n      return;\n    }\n\n    // Step 1: Create transactions from header combinations\n    const transactions = combinationData\n      .filter(item => item.header_group)\n      .map(item => item.header_group.split('|'));\n\n    // Step 2: Count item frequencies for both algorithms\n    const itemCounts = {};\n    const totalTransactions = transactions.length;\n    \n    transactions.forEach(transaction => {\n      transaction.forEach(item => {\n        itemCounts[item] = (itemCounts[item] || 0) + 1;\n      });\n    });\n\n    // Calculate minimum support threshold - use absolute minimum of 2\n    const minSupportCount = Math.max(2, Math.floor(totalTransactions * minSupport));\n    \n    // Get frequent items sorted by frequency\n    const frequentItems = Object.keys(itemCounts)\n      .filter(item => itemCounts[item] >= minSupportCount)\n      .sort((a, b) => itemCounts[b] - itemCounts[a]);\n    \n    if (algo === 'eclat') {\n      // ECLAT ALGORITHM IMPLEMENTATION\n      \n      // Step 1: Build vertical tid-lists (transaction ID lists) for each item\n      const tidLists = {};\n      frequentItems.forEach(item => {\n        tidLists[item] = new Set();\n      });\n      \n      transactions.forEach((transaction, tid) => {\n        transaction.forEach(item => {\n          if (frequentItems.includes(item)) {\n            tidLists[item].add(tid);\n          }\n        });\n      });\n      \n      // Step 2: Find frequent itemsets using ECLAT recursion\n      const frequentItemsets = {};\n      \n      // Initialize with single items\n      frequentItems.forEach(item => {\n        const support = tidLists[item].size;\n        frequentItemsets[item] = {\n          support,\n          confidence: support / totalTransactions,\n          tids: tidLists[item],\n          children: {}\n        };\n      });\n      \n      // Recursive function to find frequent itemsets (allowing deeper patterns)\n      const eclat = (prefix, tidList, level, parent) => {\n        if (level > maxDepth) return; // Increased depth limit\n        \n        // Find extensions with all items that come after the prefix's last item\n        const lastItem = prefix[prefix.length - 1];\n        const lastItemIndex = frequentItems.indexOf(lastItem);\n        \n        for (let i = lastItemIndex + 1; i < frequentItems.length; i++) {\n          const item = frequentItems[i];\n          const itemTids = tidLists[item];\n          \n          // Compute intersection\n          const intersection = new Set([...tidList].filter(tid => itemTids.has(tid)));\n          const support = intersection.size;\n          \n          // If support is high enough, add to frequent itemsets\n          // Modified to use absolute minimum count of 2 rather than percentage-based\n          if (support >= Math.max(2, minSupportCount)) {\n            const newPrefix = [...prefix, item];\n            const newPrefixStr = item; // Just use the extension item as key\n            \n            // Calculate confidence (support of extended pattern / support of prefix)\n            const confidence = support / tidList.size;\n            \n            // Modified confidence check to be lower for deeper patterns\n            if (confidence >= (level > 3 ? minConfidence/2 : minConfidence)) {\n              parent.children[newPrefixStr] = {\n                support,\n                confidence,\n                tids: intersection,\n                children: {}\n              };\n              \n              // Recursively find extensions of this new prefix\n              eclat(newPrefix, intersection, level + 1, parent.children[newPrefixStr]);\n            }\n          }\n        }\n      };\n      \n      // Start ECLAT recursion for each single item\n      frequentItems.forEach(item => {\n        eclat([item], tidLists[item], 1, frequentItemsets[item]);\n      });\n      \n      // Convert to array format for visualization\n      const buildDeepNestedTree = (itemsets) => {\n        const result = [];\n        \n        frequentItems.forEach(item => {\n          const itemData = {\n            id: item,\n            name: item,\n            support: tidLists[item].size,\n            confidence: tidLists[item].size / totalTransactions,\n            children: []\n          };\n          \n          // 재귀적으로 모든 자식 노드를 추가하는 함수\n          const addChildrenRecursively = (parentId, parentNode, currentItemset) => {\n            const children = currentItemset.children || {};\n            \n            Object.entries(children).forEach(([childKey, childValue]) => {\n              const childId = `${parentId}-${childKey}`;\n              const childNode = {\n                id: childId,\n                name: childKey,\n                support: childValue.support,\n                confidence: childValue.confidence,\n                children: []\n              };\n              \n              parentNode.children.push(childNode);\n              \n              // 재귀적으로 손자 노드 처리\n              addChildrenRecursively(childId, childNode, childValue);\n            });\n          };\n          \n          // 첫 레벨 자식 노드 추가\n          addChildrenRecursively(item, itemData, frequentItemsets[item]);\n          \n          result.push(itemData);\n        });\n        \n        return result;\n      };\n      \n      const result = buildDeepNestedTree(frequentItemsets);\n      setMiningData(result);\n      \n    } else {\n      // FP GROWTH ALGORITHM - UNIFIED TREE IMPLEMENTATION\n      \n      // Step 3: Reorder transactions based on frequency\n      const orderedTransactions = transactions.map(transaction => {\n        return transaction\n          .filter(item => frequentItems.includes(item))\n          .sort((a, b) => itemCounts[b] - itemCounts[a]);\n      }).filter(transaction => transaction.length > 0);\n      \n      // Step 4: Build unified FP-Tree\n      const fpTree = { \n        name: \"root\", \n        count: 0,\n        children: {},\n        nodeLinks: {} // Header table node links\n      };\n      \n      // Initialize header table\n      const headerTable = {};\n      frequentItems.forEach(item => {\n        headerTable[item] = {\n          count: itemCounts[item],\n          nodeLink: null\n        };\n      });\n      \n      // Insert a transaction into the FP-Tree\n      const insertTransaction = (transaction, tree, count = 1) => {\n        if (transaction.length === 0) return;\n        \n        const item = transaction[0];\n        \n        // Create node if it doesn't exist\n        if (!tree.children[item]) {\n          tree.children[item] = {\n            name: item,\n            count: 0,\n            children: {},\n            parent: tree,\n            nextSameItem: null\n          };\n          \n          // Update header table node links\n          if (!headerTable[item].nodeLink) {\n            headerTable[item].nodeLink = tree.children[item];\n          } else {\n            let current = headerTable[item].nodeLink;\n            while (current.nextSameItem) {\n              current = current.nextSameItem;\n            }\n            current.nextSameItem = tree.children[item];\n          }\n        }\n        \n        // Increment count\n        tree.children[item].count += count;\n        \n        // Insert remaining items\n        if (transaction.length > 1) {\n          insertTransaction(transaction.slice(1), tree.children[item], count);\n        }\n      };\n      \n      // Insert all transactions\n      orderedTransactions.forEach(transaction => {\n        insertTransaction(transaction, fpTree);\n      });\n      \n      // Step 5: Mine patterns using FP-Growth\n      const patterns = {};\n      \n      // Mine patterns with a suffix\n      const minePatterns = (headerTable, conditionalBase, suffix = [], parentSupport = totalTransactions) => {\n        // Get items in descending order of frequency\n        const items = Object.keys(headerTable).sort((a, b) => headerTable[b].count - headerTable[a].count);\n        \n        for (const item of items) {\n          // New frequent itemset found\n          const newSuffix = [item, ...suffix];\n          const supportCount = headerTable[item].count;\n          \n          // Calculate confidence for patterns with len > 1\n          const confidence = newSuffix.length > 1 ? supportCount / parentSupport : supportCount / totalTransactions;\n          \n          // Only include if confidence meets threshold\n          if (confidence >= minConfidence) {\n            // Store pattern\n            const patternKey = newSuffix.join('-');\n            patterns[patternKey] = {\n              items: newSuffix,\n              support: supportCount,\n              confidence: confidence\n            };\n            \n            // Build conditional pattern base\n            const conditionalPatternBase = [];\n            let node = headerTable[item].nodeLink;\n            \n            while (node) {\n              // Traverse upward to get the path\n              const path = [];\n              let prefixSupport = node.count;\n              let parent = node.parent;\n              \n              while (parent && parent.name !== \"root\") {\n                path.unshift(parent.name);\n                parent = parent.parent;\n              }\n              \n              if (path.length > 0) {\n                conditionalPatternBase.push({\n                  path,\n                  count: prefixSupport\n                });\n              }\n              \n              node = node.nextSameItem;\n            }\n            \n            // Build conditional FP-Tree\n            if (conditionalPatternBase.length > 0) {\n              const newConditionalBase = {};\n              \n              // Count items in the conditional pattern base\n              conditionalPatternBase.forEach(({path, count}) => {\n                path.forEach(pathItem => {\n                  newConditionalBase[pathItem] = (newConditionalBase[pathItem] || 0) + count;\n                });\n              });\n              \n              // Filter items by minimum support\n              const newHeaderTable = {};\n              Object.keys(newConditionalBase).forEach(item => {\n                // Use a fixed threshold of 2 for deeper patterns\n                if (newConditionalBase[item] >= Math.max(2, minSupportCount)) {\n                  newHeaderTable[item] = {\n                    count: newConditionalBase[item],\n                    nodeLink: null\n                  };\n                }\n              });\n              \n              // Recursively mine with the new conditional tree, up to more depth\n              if (Object.keys(newHeaderTable).length > 0 && newSuffix.length < maxDepth) {\n                minePatterns(newHeaderTable, conditionalPatternBase, newSuffix, supportCount);\n              }\n            }\n          }\n        }\n      };\n      \n      // Start mining\n      minePatterns(headerTable, []);\n      \n      // Build tree from patterns\n      const buildTree = (patterns) => {\n        const result = [];\n        const itemMap = {};\n        \n        // Group by first item\n        Object.values(patterns).forEach(pattern => {\n          if (pattern.items.length > 0) {\n            const firstItem = pattern.items[0];\n            if (!itemMap[firstItem]) {\n              itemMap[firstItem] = {\n                id: firstItem,\n                name: firstItem,\n                support: itemCounts[firstItem],\n                confidence: itemCounts[firstItem] / totalTransactions,\n                children: []\n              };\n              result.push(itemMap[firstItem]);\n            }\n            \n            // Add subsequent items as children\n            if (pattern.items.length > 1) {\n              let currentNode = itemMap[firstItem];\n              let currentPath = firstItem;\n              \n              for (let i = 1; i < pattern.items.length; i++) {\n                const currentItem = pattern.items[i];\n                currentPath = `${currentPath}-${currentItem}`;\n                \n                // Check if child already exists\n                let childNode = currentNode.children.find(child => child.name === currentItem);\n                \n                if (!childNode) {\n                  childNode = {\n                    id: currentPath,\n                    name: currentItem,\n                    support: pattern.support,\n                    confidence: pattern.confidence,\n                    children: []\n                  };\n                  currentNode.children.push(childNode);\n                }\n                \n                currentNode = childNode;\n              }\n            }\n          }\n        });\n        \n        return result;\n      };\n      \n      const result = buildTree(patterns);\n      setMiningData(result);\n    }\n    \n    // Initialize expanded state for visualization\n    const initialExpanded = {};\n    // Auto-expand some top nodes for better initial view\n    if (miningData && miningData.length > 0) {\n      // Expand all top-level nodes and their first children\n      miningData.forEach(node => {\n        initialExpanded[node.id] = true;\n        \n        // Also expand first child of each top node if available\n        if (node.children && node.children.length > 0) {\n          const firstChild = node.children[0];\n          initialExpanded[firstChild.id] = true;\n        }\n      });\n    }\n    setExpandedNodes(initialExpanded);\n  };\n\n  // Switch between algorithms\n  const switchAlgorithm = (algo) => {\n    setAlgorithm(algo);\n  };\n  \n  // Change minimum support threshold\n  const handleSupportChange = (e) => {\n    const value = parseFloat(e.target.value);\n    if (!isNaN(value) && value > 0 && value <= 1) {\n      setMinSupport(value);\n    }\n  };\n  \n  // Change minimum confidence threshold\n  const handleConfidenceChange = (e) => {\n    const value = parseFloat(e.target.value);\n    if (!isNaN(value) && value > 0 && value <= 1) {\n      setMinConfidence(value);\n    }\n  };\n  \n  // Change maximum depth\n  const handleDepthChange = (e) => {\n    const value = parseInt(e.target.value);\n    if (!isNaN(value) && value > 0) {\n      setMaxDepth(value);\n    }\n  };\n\n  // Function to toggle node expansion\n  const toggleNode = (nodeId) => {\n    setExpandedNodes(prev => ({\n      ...prev,\n      [nodeId]: !prev[nodeId]\n    }));\n  };\n\n  return (\n    <div className=\"tab-content\">\n      {loading ? (\n        <div className=\"loading\">로딩 중...</div>\n      ) : error ? (\n        <div className=\"error\">에러: {error}</div>\n      ) : combinationHeaders && combinationHeaders.length > 0 ? (\n        <div className=\"mining-view\">\n          <div className=\"mining-controls\">\n            <div className=\"algorithm-selector\">\n              <button \n                className={`algorithm-btn ${algorithm === 'eclat' ? 'active' : ''}`} \n                onClick={() => switchAlgorithm('eclat')}\n              >\n                Eclat 알고리즘\n              </button>\n              <button \n                className={`algorithm-btn ${algorithm === 'fpgrowth' ? 'active' : ''}`} \n                onClick={() => switchAlgorithm('fpgrowth')}\n              >\n                FP-Growth 알고리즘\n              </button>\n            </div>\n            <div className=\"thresholds-control\">\n              <div className=\"threshold-item\">\n                <label>최소 지지도 (Minimum Support): {(minSupport * 100).toFixed(0)}%</label>\n                <input \n                  type=\"range\" \n                  min=\"0.01\" \n                  max=\"0.5\" \n                  step=\"0.05\" \n                  value={minSupport}\n                  onChange={handleSupportChange}\n                />\n              </div>\n              <div className=\"threshold-item\">\n                <label>최소 신뢰도 (Minimum Confidence): {(minConfidence * 100).toFixed(0)}%</label>\n                <input \n                  type=\"range\" \n                  min=\"0.01\" \n                  max=\"0.9\" \n                  step=\"0.1\" \n                  value={minConfidence}\n                  onChange={handleConfidenceChange}\n                />\n              </div>\n              <div className=\"threshold-item\">\n                <label>최대 패턴 깊이 (Maximum Pattern Depth): {maxDepth}</label>\n                <input \n                  type=\"range\" \n                  min=\"3\" \n                  max=\"20\" \n                  step=\"1\" \n                  value={maxDepth}\n                  onChange={handleDepthChange}\n                />\n              </div>\n            </div>\n          </div>\n          \n          <div className=\"mining-tree-container\">\n            <svg \n              className=\"mining-tree-svg\" \n              ref={svgRef} \n              width=\"100%\" \n              height=\"400\"\n            ></svg>\n          </div>\n          \n          <div className=\"mining-explanation\">\n            <p>{algorithm === 'eclat' ? 'Eclat' : 'FP-Growth'} 알고리즘 패턴 시각화:</p>\n            <ul>\n              <li>패턴 출현 빈도 기준 내림차순으로 정렬됨</li>\n              <li>패턴 클릭: 하위 패턴 확장/축소</li>\n              <li>마우스 오버: 패턴 경로 하이라이트</li>\n              <li>숫자: 패턴 발생 빈도 (최소 2회 이상)</li>\n            </ul>\n          </div>\n        </div>\n      ) : (\n        <div className=\"column-empty\">\n          {testMode \n            ? \"마이닝 데이터를 로딩 중입니다...\" \n            : \"채널과 헤더를 선택하면 마이닝 결과가 표시됩니다.\"}\n        </div>\n      )}\n\n      <style jsx>{`\n        .mining-view {\n          height: 100%;\n          display: flex;\n          flex-direction: column;\n        }\n        \n        .mining-controls {\n          display: flex;\n          flex-direction: column;\n          gap: 8px;\n          margin-bottom: 12px;\n          background-color: #fafafa;\n          border-radius: 4px;\n          padding: 8px;\n        }\n        \n        .algorithm-selector {\n          display: flex;\n          gap: 8px;\n        }\n        \n        .algorithm-btn {\n          background: #f7f7f7;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          padding: 4px 8px;\n          font-size: 12px;\n          cursor: pointer;\n        }\n        \n        .algorithm-btn.active {\n          background: #666;\n          color: white;\n          border-color: #666;\n        }\n        \n        .thresholds-control {\n          display: flex;\n          flex-direction: column;\n          gap: 6px;\n        }\n        \n        .threshold-item {\n          display: flex;\n          flex-direction: column;\n          font-size: 11px;\n        }\n        \n        .threshold-item label {\n          margin-bottom: 2px;\n        }\n        \n        .threshold-item input {\n          width: 100%;\n        }\n        \n        .mining-tree-container {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: auto;\n          background-color: #ffffff;\n          flex-grow: 1;\n          min-height: 350px;  // Increased minimum height\n          padding: 10px;\n          box-shadow: inset 0 0 3px rgba(0,0,0,0.05);\n        }\n        \n        .mining-explanation {\n          margin-top: 10px;\n          font-size: 11px;\n          color: #666;\n          background-color: #f9f9f9;\n          border-radius: 4px;\n          padding: 6px 10px;\n        }\n        \n        .mining-explanation ul {\n          padding-left: 16px;\n          margin: 4px 0;\n        }\n        \n        .mining-explanation p {\n          margin: 4px 0;\n          font-weight: bold;\n        }\n        \n        .mining-explanation li {\n          margin-bottom: 2px;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default MiningView; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
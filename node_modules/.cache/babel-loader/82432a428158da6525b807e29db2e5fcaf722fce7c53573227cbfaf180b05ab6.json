{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js\";\nimport React from 'react';\nimport './SeparationClassifier.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DataDisplay = ({\n  processedData,\n  flattenData\n}) => {\n  if (!processedData) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"no-data\",\n      children: \"\\uCC98\\uB9AC\\uD560 \\uB370\\uC774\\uD130\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 12\n    }, this);\n  }\n\n  // Check if the text is a duplicated string (contains itself twice)\n  const isDuplicatedText = text => {\n    if (typeof text !== 'string' || text.length === 0) return false;\n    const halfLength = Math.floor(text.length / 2);\n    const firstHalf = text.substring(0, halfLength);\n    return text.includes(firstHalf + firstHalf);\n  };\n\n  // Remove duplicated text if needed\n  const cleanDuplicatedText = text => {\n    if (!isDuplicatedText(text)) return text;\n\n    // Try to find where the duplication starts\n    for (let i = 1; i < text.length / 2; i++) {\n      const firstPart = text.substring(0, i);\n      const secondPart = text.substring(i, i * 2);\n      if (firstPart === secondPart) {\n        // Check if this pattern repeats in the rest of the string\n        const pattern = firstPart;\n        const remaining = text.substring(i * 2);\n\n        // If the remaining part starts with the same pattern, we have duplication\n        if (remaining.startsWith(pattern)) {\n          return firstPart + remaining;\n        }\n      }\n    }\n\n    // Fallback: just take the first half if we can't find the exact pattern\n    const halfLength = Math.floor(text.length / 2);\n    return text.substring(0, halfLength);\n  };\n\n  // New function to render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = row => {\n    // Clean up potentially duplicated original text\n    let original = row.original;\n    if (isDuplicatedText(original)) {\n      original = cleanDuplicatedText(original);\n    }\n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row);\n    }\n\n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"unprocessed-tag\",\n        children: original\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 57,\n        columnNumber: 14\n      }, this);\n    }\n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n\n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"unprocessed-tag\",\n            children: unprocessedText\n          }, `unproc-${idx}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 74,\n            columnNumber: 13\n          }, this));\n        }\n\n        // Add the processed bracket content\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"value-tag bracket-source\",\n          children: match.value\n        }, `proc-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 80,\n          columnNumber: 11\n        }, this));\n        lastIndex = match.endIndex;\n      });\n\n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"unprocessed-tag\",\n          children: original.substring(lastIndex)\n        }, \"unproc-last\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 89,\n          columnNumber: 11\n        }, this));\n      }\n      return result;\n    } else if (row.type === 'delimiter-separation') {\n      // For delimiter separation, we need to reconstruct the sequence in original order\n\n      // Check for duplicated processing in the raw data\n      const originalTextClean = original.replace(/\\s+/g, '');\n      const combinedProcessedText = row.separated.map(item => typeof item === 'string' ? item : item.value).join('').replace(/\\s+/g, '');\n\n      // If processed text combined is approximately the same length as original,\n      // this means we may have duplicate data\n      if (combinedProcessedText.length > originalTextClean.length * 0.8) {\n        // For such cases, just show the processed values without trying to reconstruct sequence\n        return renderSeparatedValues(row);\n      }\n\n      // Create an array of all parts with their positions in the original text\n      const allPositionedParts = [];\n\n      // First add bracket parts (these have exact position info)\n      if (row.previous && row.previous.matchDetails) {\n        row.separated.forEach(item => {\n          if (item.source === 'bracket' && item.bracketInfo) {\n            allPositionedParts.push({\n              value: item.value,\n              source: 'bracket',\n              startIndex: item.bracketInfo.startIndex,\n              endIndex: item.bracketInfo.endIndex\n            });\n          }\n        });\n      }\n\n      // Get clean text parts (non-bracket parts)\n      const cleanTextParts = row.separated.filter(item => item.source === 'clean-text');\n\n      // Now, we'll attempt to position clean text parts in their approximate original positions\n\n      // Find possible positions for clean text items by checking the original text\n      // We'll look for each clean text item in the original text, ignoring brackets\n\n      // Create a copy of the original text where brackets are removed\n      const originalWithoutBrackets = original.replace(/\\[(.*?)\\]|\\((.*?)\\)|\\{(.*?)\\}/g, '');\n\n      // Try to find positions for clean text parts\n      cleanTextParts.forEach(item => {\n        const value = item.value.trim();\n        if (value.length === 0) return;\n\n        // Search for this text in the original\n        let position = originalWithoutBrackets.indexOf(value);\n        if (position >= 0) {\n          // Found a potential position\n          allPositionedParts.push({\n            value: item.value,\n            source: 'clean-text',\n            startIndex: position,\n            endIndex: position + value.length\n          });\n        } else {\n          // If exact match not found, add to end with a special marker\n          allPositionedParts.push({\n            value: item.value,\n            source: 'clean-text',\n            startIndex: Number.MAX_SAFE_INTEGER,\n            // This will put it at the end\n            endIndex: Number.MAX_SAFE_INTEGER\n          });\n        }\n      });\n\n      // Add any delimiter parts without clear position at the end\n      row.separated.forEach(item => {\n        if (item.source !== 'bracket' && item.source !== 'clean-text') {\n          allPositionedParts.push({\n            value: item.value,\n            source: item.source || 'delimiter',\n            startIndex: Number.MAX_SAFE_INTEGER,\n            // Put at end\n            endIndex: Number.MAX_SAFE_INTEGER\n          });\n        }\n      });\n\n      // Sort all parts by their start position in the original text\n      const sortedParts = [...allPositionedParts].sort((a, b) => a.startIndex - b.startIndex);\n\n      // Now create elements in the sorted order\n      let lastIndex = 0;\n      const orderedElements = [];\n\n      // Special case for parts that we couldn't position properly\n      const unpositionedParts = [];\n\n      // Process parts in order of appearance\n      sortedParts.forEach((part, idx) => {\n        if (part.startIndex === Number.MAX_SAFE_INTEGER) {\n          // This is an unpositioned part, save for the end\n          unpositionedParts.push(part);\n          return;\n        }\n\n        // Add unprocessed text between last part and this one\n        if (part.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, part.startIndex);\n          if (unprocessedText.trim().length > 0) {\n            orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"unprocessed-tag\",\n              children: unprocessedText\n            }, `unproc-${idx}`, false, {\n              fileName: _jsxFileName,\n              lineNumber: 202,\n              columnNumber: 15\n            }, this));\n          }\n        }\n\n        // Add the processed part with appropriate class\n        orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: `value-tag ${part.source === 'bracket' ? 'bracket-source' : part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n          children: part.value\n        }, `part-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 211,\n          columnNumber: 11\n        }, this));\n\n        // Update last processed position\n        lastIndex = part.endIndex;\n      });\n\n      // Add any remaining text\n      if (lastIndex < original.length) {\n        orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"unprocessed-tag\",\n          children: original.substring(lastIndex)\n        }, \"unproc-last\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 227,\n          columnNumber: 11\n        }, this));\n      }\n\n      // Add unpositioned parts at the end\n      unpositionedParts.forEach((part, idx) => {\n        orderedElements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: `value-tag ${part.source === 'bracket' ? 'bracket-source' : part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n          children: part.value\n        }, `unpos-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 236,\n          columnNumber: 11\n        }, this));\n      });\n      return orderedElements.length > 0 ? orderedElements : renderSeparatedValues(row);\n    }\n\n    // Fallback to original display method\n    return renderSeparatedValues(row);\n  };\n  const renderSeparatedValues = row => {\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"no-values\",\n        children: \"\\uCD94\\uCD9C\\uB41C \\uAC12 \\uC5C6\\uC74C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 255,\n        columnNumber: 14\n      }, this);\n    }\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"value-tag\",\n        children: val\n      }, idx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 261,\n        columnNumber: 9\n      }, this));\n    }\n\n    // New format (with metadata)\n    return row.separated.map((item, idx) => /*#__PURE__*/_jsxDEV(\"span\", {\n      className: `value-tag ${item.source === 'bracket' ? 'bracket-source' : item.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n      children: typeof item === 'string' ? item : item.value\n    }, idx, false, {\n      fileName: _jsxFileName,\n      lineNumber: 267,\n      columnNumber: 7\n    }, this));\n  };\n  return /*#__PURE__*/_jsxDEV(\"table\", {\n    className: \"data-table\",\n    children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n      children: flattenData(processedData).map((row, index) => /*#__PURE__*/_jsxDEV(\"tr\", {\n        children: /*#__PURE__*/_jsxDEV(\"td\", {\n          className: \"enhanced-view\",\n          children: renderEnhancedView(row)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 282,\n          columnNumber: 13\n        }, this)\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 281,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 279,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 278,\n    columnNumber: 5\n  }, this);\n};\n_c = DataDisplay;\nexport default DataDisplay;\nvar _c;\n$RefreshReg$(_c, \"DataDisplay\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","DataDisplay","processedData","flattenData","className","children","fileName","_jsxFileName","lineNumber","columnNumber","isDuplicatedText","text","length","halfLength","Math","floor","firstHalf","substring","includes","cleanDuplicatedText","i","firstPart","secondPart","pattern","remaining","startsWith","renderEnhancedView","row","original","renderSeparatedValues","separated","type","result","lastIndex","matchDetails","sortedMatches","sort","a","b","startIndex","forEach","match","idx","unprocessedText","push","value","endIndex","originalTextClean","replace","combinedProcessedText","map","item","join","allPositionedParts","previous","source","bracketInfo","cleanTextParts","filter","originalWithoutBrackets","trim","position","indexOf","Number","MAX_SAFE_INTEGER","sortedParts","orderedElements","unpositionedParts","part","Array","isArray","every","v","val","index","_c","$RefreshReg$"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js"],"sourcesContent":["import React from 'react';\nimport './SeparationClassifier.css';\n\nconst DataDisplay = ({ processedData, flattenData }) => {\n  if (!processedData) {\n    return <div className=\"no-data\">처리할 데이터가 없습니다</div>;\n  }\n\n  // Check if the text is a duplicated string (contains itself twice)\n  const isDuplicatedText = (text) => {\n    if (typeof text !== 'string' || text.length === 0) return false;\n    const halfLength = Math.floor(text.length / 2);\n    const firstHalf = text.substring(0, halfLength);\n    return text.includes(firstHalf + firstHalf);\n  };\n\n  // Remove duplicated text if needed\n  const cleanDuplicatedText = (text) => {\n    if (!isDuplicatedText(text)) return text;\n    \n    // Try to find where the duplication starts\n    for (let i = 1; i < text.length / 2; i++) {\n      const firstPart = text.substring(0, i);\n      const secondPart = text.substring(i, i * 2);\n      \n      if (firstPart === secondPart) {\n        // Check if this pattern repeats in the rest of the string\n        const pattern = firstPart;\n        const remaining = text.substring(i * 2);\n        \n        // If the remaining part starts with the same pattern, we have duplication\n        if (remaining.startsWith(pattern)) {\n          return firstPart + remaining;\n        }\n      }\n    }\n    \n    // Fallback: just take the first half if we can't find the exact pattern\n    const halfLength = Math.floor(text.length / 2);\n    return text.substring(0, halfLength);\n  };\n\n  // New function to render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = (row) => {\n    // Clean up potentially duplicated original text\n    let original = row.original;\n    if (isDuplicatedText(original)) {\n      original = cleanDuplicatedText(original);\n    }\n    \n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row);\n    }\n    \n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"unprocessed-tag\">{original}</span>;\n    }\n    \n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n      \n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      \n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(\n            <span key={`unproc-${idx}`} className=\"unprocessed-tag\">{unprocessedText}</span>\n          );\n        }\n        \n        // Add the processed bracket content\n        result.push(\n          <span key={`proc-${idx}`} className=\"value-tag bracket-source\">{match.value}</span>\n        );\n        \n        lastIndex = match.endIndex;\n      });\n      \n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(\n          <span key=\"unproc-last\" className=\"unprocessed-tag\">\n            {original.substring(lastIndex)}\n          </span>\n        );\n      }\n      \n      return result;\n    } else if (row.type === 'delimiter-separation') {\n      // For delimiter separation, we need to reconstruct the sequence in original order\n      \n      // Check for duplicated processing in the raw data\n      const originalTextClean = original.replace(/\\s+/g, '');\n      const combinedProcessedText = row.separated\n        .map(item => typeof item === 'string' ? item : item.value)\n        .join('')\n        .replace(/\\s+/g, '');\n      \n      // If processed text combined is approximately the same length as original,\n      // this means we may have duplicate data\n      if (combinedProcessedText.length > originalTextClean.length * 0.8) {\n        // For such cases, just show the processed values without trying to reconstruct sequence\n        return renderSeparatedValues(row);\n      }\n      \n      // Create an array of all parts with their positions in the original text\n      const allPositionedParts = [];\n      \n      // First add bracket parts (these have exact position info)\n      if (row.previous && row.previous.matchDetails) {\n        row.separated.forEach(item => {\n          if (item.source === 'bracket' && item.bracketInfo) {\n            allPositionedParts.push({\n              value: item.value,\n              source: 'bracket',\n              startIndex: item.bracketInfo.startIndex,\n              endIndex: item.bracketInfo.endIndex\n            });\n          }\n        });\n      }\n      \n      // Get clean text parts (non-bracket parts)\n      const cleanTextParts = row.separated.filter(item => item.source === 'clean-text');\n      \n      // Now, we'll attempt to position clean text parts in their approximate original positions\n      \n      // Find possible positions for clean text items by checking the original text\n      // We'll look for each clean text item in the original text, ignoring brackets\n      \n      // Create a copy of the original text where brackets are removed\n      const originalWithoutBrackets = original.replace(/\\[(.*?)\\]|\\((.*?)\\)|\\{(.*?)\\}/g, '');\n      \n      // Try to find positions for clean text parts\n      cleanTextParts.forEach(item => {\n        const value = item.value.trim();\n        if (value.length === 0) return;\n        \n        // Search for this text in the original\n        let position = originalWithoutBrackets.indexOf(value);\n        if (position >= 0) {\n          // Found a potential position\n          allPositionedParts.push({\n            value: item.value,\n            source: 'clean-text',\n            startIndex: position,\n            endIndex: position + value.length\n          });\n        } else {\n          // If exact match not found, add to end with a special marker\n          allPositionedParts.push({\n            value: item.value,\n            source: 'clean-text',\n            startIndex: Number.MAX_SAFE_INTEGER,  // This will put it at the end\n            endIndex: Number.MAX_SAFE_INTEGER\n          });\n        }\n      });\n      \n      // Add any delimiter parts without clear position at the end\n      row.separated.forEach(item => {\n        if (item.source !== 'bracket' && item.source !== 'clean-text') {\n          allPositionedParts.push({\n            value: item.value,\n            source: item.source || 'delimiter',\n            startIndex: Number.MAX_SAFE_INTEGER,  // Put at end\n            endIndex: Number.MAX_SAFE_INTEGER\n          });\n        }\n      });\n      \n      // Sort all parts by their start position in the original text\n      const sortedParts = [...allPositionedParts].sort((a, b) => a.startIndex - b.startIndex);\n      \n      // Now create elements in the sorted order\n      let lastIndex = 0;\n      const orderedElements = [];\n      \n      // Special case for parts that we couldn't position properly\n      const unpositionedParts = [];\n      \n      // Process parts in order of appearance\n      sortedParts.forEach((part, idx) => {\n        if (part.startIndex === Number.MAX_SAFE_INTEGER) {\n          // This is an unpositioned part, save for the end\n          unpositionedParts.push(part);\n          return;\n        }\n        \n        // Add unprocessed text between last part and this one\n        if (part.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, part.startIndex);\n          if (unprocessedText.trim().length > 0) {\n            orderedElements.push(\n              <span key={`unproc-${idx}`} className=\"unprocessed-tag\">\n                {unprocessedText}\n              </span>\n            );\n          }\n        }\n        \n        // Add the processed part with appropriate class\n        orderedElements.push(\n          <span \n            key={`part-${idx}`} \n            className={`value-tag ${part.source === 'bracket' ? 'bracket-source' : \n                                 part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n          >\n            {part.value}\n          </span>\n        );\n        \n        // Update last processed position\n        lastIndex = part.endIndex;\n      });\n      \n      // Add any remaining text\n      if (lastIndex < original.length) {\n        orderedElements.push(\n          <span key=\"unproc-last\" className=\"unprocessed-tag\">\n            {original.substring(lastIndex)}\n          </span>\n        );\n      }\n      \n      // Add unpositioned parts at the end\n      unpositionedParts.forEach((part, idx) => {\n        orderedElements.push(\n          <span \n            key={`unpos-${idx}`} \n            className={`value-tag ${part.source === 'bracket' ? 'bracket-source' : \n                                 part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n          >\n            {part.value}\n          </span>\n        );\n      });\n      \n      return orderedElements.length > 0 ? orderedElements : renderSeparatedValues(row);\n    }\n    \n    // Fallback to original display method\n    return renderSeparatedValues(row);\n  };\n\n  const renderSeparatedValues = (row) => {\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"no-values\">추출된 값 없음</span>;\n    }\n\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => (\n        <span key={idx} className=\"value-tag\">{val}</span>\n      ));\n    } \n    \n    // New format (with metadata)\n    return row.separated.map((item, idx) => (\n      <span \n        key={idx} \n        className={`value-tag ${item.source === 'bracket' ? 'bracket-source' : \n                              item.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n      >\n        {typeof item === 'string' ? item : item.value}\n      </span>\n    ));\n  };\n\n  return (\n    <table className=\"data-table\">\n      <tbody>\n        {flattenData(processedData).map((row, index) => (\n          <tr key={index}>\n            <td className=\"enhanced-view\">\n              {renderEnhancedView(row)}\n            </td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n};\n\nexport default DataDisplay; "],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAO,4BAA4B;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEpC,MAAMC,WAAW,GAAGA,CAAC;EAAEC,aAAa;EAAEC;AAAY,CAAC,KAAK;EACtD,IAAI,CAACD,aAAa,EAAE;IAClB,oBAAOF,OAAA;MAAKI,SAAS,EAAC,SAAS;MAAAC,QAAA,EAAC;IAAa;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAK,CAAC;EACrD;;EAEA;EACA,MAAMC,gBAAgB,GAAIC,IAAI,IAAK;IACjC,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE,OAAO,KAAK;IAC/D,MAAMC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACJ,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC;IAC9C,MAAMI,SAAS,GAAGL,IAAI,CAACM,SAAS,CAAC,CAAC,EAAEJ,UAAU,CAAC;IAC/C,OAAOF,IAAI,CAACO,QAAQ,CAACF,SAAS,GAAGA,SAAS,CAAC;EAC7C,CAAC;;EAED;EACA,MAAMG,mBAAmB,GAAIR,IAAI,IAAK;IACpC,IAAI,CAACD,gBAAgB,CAACC,IAAI,CAAC,EAAE,OAAOA,IAAI;;IAExC;IACA,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,IAAI,CAACC,MAAM,GAAG,CAAC,EAAEQ,CAAC,EAAE,EAAE;MACxC,MAAMC,SAAS,GAAGV,IAAI,CAACM,SAAS,CAAC,CAAC,EAAEG,CAAC,CAAC;MACtC,MAAME,UAAU,GAAGX,IAAI,CAACM,SAAS,CAACG,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;MAE3C,IAAIC,SAAS,KAAKC,UAAU,EAAE;QAC5B;QACA,MAAMC,OAAO,GAAGF,SAAS;QACzB,MAAMG,SAAS,GAAGb,IAAI,CAACM,SAAS,CAACG,CAAC,GAAG,CAAC,CAAC;;QAEvC;QACA,IAAII,SAAS,CAACC,UAAU,CAACF,OAAO,CAAC,EAAE;UACjC,OAAOF,SAAS,GAAGG,SAAS;QAC9B;MACF;IACF;;IAEA;IACA,MAAMX,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACJ,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC;IAC9C,OAAOD,IAAI,CAACM,SAAS,CAAC,CAAC,EAAEJ,UAAU,CAAC;EACtC,CAAC;;EAED;EACA,MAAMa,kBAAkB,GAAIC,GAAG,IAAK;IAClC;IACA,IAAIC,QAAQ,GAAGD,GAAG,CAACC,QAAQ;IAC3B,IAAIlB,gBAAgB,CAACkB,QAAQ,CAAC,EAAE;MAC9BA,QAAQ,GAAGT,mBAAmB,CAACS,QAAQ,CAAC;IAC1C;IAEA,IAAI,CAACA,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;MAC7C,OAAOC,qBAAqB,CAACF,GAAG,CAAC;IACnC;;IAEA;IACA,IAAI,CAACA,GAAG,CAACG,SAAS,IAAIH,GAAG,CAACG,SAAS,CAAClB,MAAM,KAAK,CAAC,EAAE;MAChD,oBAAOZ,OAAA;QAAMI,SAAS,EAAC,iBAAiB;QAAAC,QAAA,EAAEuB;MAAQ;QAAAtB,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAO,CAAC;IAC5D;IAEA,IAAIkB,GAAG,CAACI,IAAI,KAAK,oBAAoB,EAAE;MACrC;MACA,IAAIC,MAAM,GAAG,EAAE;MACf,IAAIC,SAAS,GAAG,CAAC;;MAEjB;MACA,MAAMC,YAAY,GAAGP,GAAG,CAACO,YAAY,IAAI,EAAE;MAC3C,MAAMC,aAAa,GAAG,CAAC,GAAGD,YAAY,CAAC,CAACE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,UAAU,GAAGD,CAAC,CAACC,UAAU,CAAC;MAEnFJ,aAAa,CAACK,OAAO,CAAC,CAACC,KAAK,EAAEC,GAAG,KAAK;QACpC;QACA,IAAID,KAAK,CAACF,UAAU,GAAGN,SAAS,EAAE;UAChC,MAAMU,eAAe,GAAGf,QAAQ,CAACX,SAAS,CAACgB,SAAS,EAAEQ,KAAK,CAACF,UAAU,CAAC;UACvEP,MAAM,CAACY,IAAI,cACT5C,OAAA;YAA4BI,SAAS,EAAC,iBAAiB;YAAAC,QAAA,EAAEsC;UAAe,GAA7D,UAAUD,GAAG,EAAE;YAAApC,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAqD,CACjF,CAAC;QACH;;QAEA;QACAuB,MAAM,CAACY,IAAI,cACT5C,OAAA;UAA0BI,SAAS,EAAC,0BAA0B;UAAAC,QAAA,EAAEoC,KAAK,CAACI;QAAK,GAAhE,QAAQH,GAAG,EAAE;UAAApC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAA0D,CACpF,CAAC;QAEDwB,SAAS,GAAGQ,KAAK,CAACK,QAAQ;MAC5B,CAAC,CAAC;;MAEF;MACA,IAAIb,SAAS,GAAGL,QAAQ,CAAChB,MAAM,EAAE;QAC/BoB,MAAM,CAACY,IAAI,cACT5C,OAAA;UAAwBI,SAAS,EAAC,iBAAiB;UAAAC,QAAA,EAChDuB,QAAQ,CAACX,SAAS,CAACgB,SAAS;QAAC,GADtB,aAAa;UAAA3B,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAEjB,CACR,CAAC;MACH;MAEA,OAAOuB,MAAM;IACf,CAAC,MAAM,IAAIL,GAAG,CAACI,IAAI,KAAK,sBAAsB,EAAE;MAC9C;;MAEA;MACA,MAAMgB,iBAAiB,GAAGnB,QAAQ,CAACoB,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;MACtD,MAAMC,qBAAqB,GAAGtB,GAAG,CAACG,SAAS,CACxCoB,GAAG,CAACC,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,GAAGA,IAAI,GAAGA,IAAI,CAACN,KAAK,CAAC,CACzDO,IAAI,CAAC,EAAE,CAAC,CACRJ,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;;MAEtB;MACA;MACA,IAAIC,qBAAqB,CAACrC,MAAM,GAAGmC,iBAAiB,CAACnC,MAAM,GAAG,GAAG,EAAE;QACjE;QACA,OAAOiB,qBAAqB,CAACF,GAAG,CAAC;MACnC;;MAEA;MACA,MAAM0B,kBAAkB,GAAG,EAAE;;MAE7B;MACA,IAAI1B,GAAG,CAAC2B,QAAQ,IAAI3B,GAAG,CAAC2B,QAAQ,CAACpB,YAAY,EAAE;QAC7CP,GAAG,CAACG,SAAS,CAACU,OAAO,CAACW,IAAI,IAAI;UAC5B,IAAIA,IAAI,CAACI,MAAM,KAAK,SAAS,IAAIJ,IAAI,CAACK,WAAW,EAAE;YACjDH,kBAAkB,CAACT,IAAI,CAAC;cACtBC,KAAK,EAAEM,IAAI,CAACN,KAAK;cACjBU,MAAM,EAAE,SAAS;cACjBhB,UAAU,EAAEY,IAAI,CAACK,WAAW,CAACjB,UAAU;cACvCO,QAAQ,EAAEK,IAAI,CAACK,WAAW,CAACV;YAC7B,CAAC,CAAC;UACJ;QACF,CAAC,CAAC;MACJ;;MAEA;MACA,MAAMW,cAAc,GAAG9B,GAAG,CAACG,SAAS,CAAC4B,MAAM,CAACP,IAAI,IAAIA,IAAI,CAACI,MAAM,KAAK,YAAY,CAAC;;MAEjF;;MAEA;MACA;;MAEA;MACA,MAAMI,uBAAuB,GAAG/B,QAAQ,CAACoB,OAAO,CAAC,gCAAgC,EAAE,EAAE,CAAC;;MAEtF;MACAS,cAAc,CAACjB,OAAO,CAACW,IAAI,IAAI;QAC7B,MAAMN,KAAK,GAAGM,IAAI,CAACN,KAAK,CAACe,IAAI,CAAC,CAAC;QAC/B,IAAIf,KAAK,CAACjC,MAAM,KAAK,CAAC,EAAE;;QAExB;QACA,IAAIiD,QAAQ,GAAGF,uBAAuB,CAACG,OAAO,CAACjB,KAAK,CAAC;QACrD,IAAIgB,QAAQ,IAAI,CAAC,EAAE;UACjB;UACAR,kBAAkB,CAACT,IAAI,CAAC;YACtBC,KAAK,EAAEM,IAAI,CAACN,KAAK;YACjBU,MAAM,EAAE,YAAY;YACpBhB,UAAU,EAAEsB,QAAQ;YACpBf,QAAQ,EAAEe,QAAQ,GAAGhB,KAAK,CAACjC;UAC7B,CAAC,CAAC;QACJ,CAAC,MAAM;UACL;UACAyC,kBAAkB,CAACT,IAAI,CAAC;YACtBC,KAAK,EAAEM,IAAI,CAACN,KAAK;YACjBU,MAAM,EAAE,YAAY;YACpBhB,UAAU,EAAEwB,MAAM,CAACC,gBAAgB;YAAG;YACtClB,QAAQ,EAAEiB,MAAM,CAACC;UACnB,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;;MAEF;MACArC,GAAG,CAACG,SAAS,CAACU,OAAO,CAACW,IAAI,IAAI;QAC5B,IAAIA,IAAI,CAACI,MAAM,KAAK,SAAS,IAAIJ,IAAI,CAACI,MAAM,KAAK,YAAY,EAAE;UAC7DF,kBAAkB,CAACT,IAAI,CAAC;YACtBC,KAAK,EAAEM,IAAI,CAACN,KAAK;YACjBU,MAAM,EAAEJ,IAAI,CAACI,MAAM,IAAI,WAAW;YAClChB,UAAU,EAAEwB,MAAM,CAACC,gBAAgB;YAAG;YACtClB,QAAQ,EAAEiB,MAAM,CAACC;UACnB,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;;MAEF;MACA,MAAMC,WAAW,GAAG,CAAC,GAAGZ,kBAAkB,CAAC,CAACjB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,UAAU,GAAGD,CAAC,CAACC,UAAU,CAAC;;MAEvF;MACA,IAAIN,SAAS,GAAG,CAAC;MACjB,MAAMiC,eAAe,GAAG,EAAE;;MAE1B;MACA,MAAMC,iBAAiB,GAAG,EAAE;;MAE5B;MACAF,WAAW,CAACzB,OAAO,CAAC,CAAC4B,IAAI,EAAE1B,GAAG,KAAK;QACjC,IAAI0B,IAAI,CAAC7B,UAAU,KAAKwB,MAAM,CAACC,gBAAgB,EAAE;UAC/C;UACAG,iBAAiB,CAACvB,IAAI,CAACwB,IAAI,CAAC;UAC5B;QACF;;QAEA;QACA,IAAIA,IAAI,CAAC7B,UAAU,GAAGN,SAAS,EAAE;UAC/B,MAAMU,eAAe,GAAGf,QAAQ,CAACX,SAAS,CAACgB,SAAS,EAAEmC,IAAI,CAAC7B,UAAU,CAAC;UACtE,IAAII,eAAe,CAACiB,IAAI,CAAC,CAAC,CAAChD,MAAM,GAAG,CAAC,EAAE;YACrCsD,eAAe,CAACtB,IAAI,cAClB5C,OAAA;cAA4BI,SAAS,EAAC,iBAAiB;cAAAC,QAAA,EACpDsC;YAAe,GADP,UAAUD,GAAG,EAAE;cAAApC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAEpB,CACR,CAAC;UACH;QACF;;QAEA;QACAyD,eAAe,CAACtB,IAAI,cAClB5C,OAAA;UAEEI,SAAS,EAAE,aAAagE,IAAI,CAACb,MAAM,KAAK,SAAS,GAAG,gBAAgB,GAC/Ca,IAAI,CAACb,MAAM,KAAK,YAAY,GAAG,aAAa,GAAG,kBAAkB,EAAG;UAAAlD,QAAA,EAExF+D,IAAI,CAACvB;QAAK,GAJN,QAAQH,GAAG,EAAE;UAAApC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAKd,CACR,CAAC;;QAED;QACAwB,SAAS,GAAGmC,IAAI,CAACtB,QAAQ;MAC3B,CAAC,CAAC;;MAEF;MACA,IAAIb,SAAS,GAAGL,QAAQ,CAAChB,MAAM,EAAE;QAC/BsD,eAAe,CAACtB,IAAI,cAClB5C,OAAA;UAAwBI,SAAS,EAAC,iBAAiB;UAAAC,QAAA,EAChDuB,QAAQ,CAACX,SAAS,CAACgB,SAAS;QAAC,GADtB,aAAa;UAAA3B,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAEjB,CACR,CAAC;MACH;;MAEA;MACA0D,iBAAiB,CAAC3B,OAAO,CAAC,CAAC4B,IAAI,EAAE1B,GAAG,KAAK;QACvCwB,eAAe,CAACtB,IAAI,cAClB5C,OAAA;UAEEI,SAAS,EAAE,aAAagE,IAAI,CAACb,MAAM,KAAK,SAAS,GAAG,gBAAgB,GAC/Ca,IAAI,CAACb,MAAM,KAAK,YAAY,GAAG,aAAa,GAAG,kBAAkB,EAAG;UAAAlD,QAAA,EAExF+D,IAAI,CAACvB;QAAK,GAJN,SAASH,GAAG,EAAE;UAAApC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAKf,CACR,CAAC;MACH,CAAC,CAAC;MAEF,OAAOyD,eAAe,CAACtD,MAAM,GAAG,CAAC,GAAGsD,eAAe,GAAGrC,qBAAqB,CAACF,GAAG,CAAC;IAClF;;IAEA;IACA,OAAOE,qBAAqB,CAACF,GAAG,CAAC;EACnC,CAAC;EAED,MAAME,qBAAqB,GAAIF,GAAG,IAAK;IACrC,IAAI,CAACA,GAAG,CAACG,SAAS,IAAIH,GAAG,CAACG,SAAS,CAAClB,MAAM,KAAK,CAAC,EAAE;MAChD,oBAAOZ,OAAA;QAAMI,SAAS,EAAC,WAAW;QAAAC,QAAA,EAAC;MAAQ;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAM,CAAC;IACpD;IAEA,IAAI4D,KAAK,CAACC,OAAO,CAAC3C,GAAG,CAACG,SAAS,CAAC,IAAIH,GAAG,CAACG,SAAS,CAACyC,KAAK,CAACC,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,CAAC,EAAE;MACnF;MACA,OAAO7C,GAAG,CAACG,SAAS,CAACoB,GAAG,CAAC,CAACuB,GAAG,EAAE/B,GAAG,kBAChC1C,OAAA;QAAgBI,SAAS,EAAC,WAAW;QAAAC,QAAA,EAAEoE;MAAG,GAA/B/B,GAAG;QAAApC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAmC,CAClD,CAAC;IACJ;;IAEA;IACA,OAAOkB,GAAG,CAACG,SAAS,CAACoB,GAAG,CAAC,CAACC,IAAI,EAAET,GAAG,kBACjC1C,OAAA;MAEEI,SAAS,EAAE,aAAa+C,IAAI,CAACI,MAAM,KAAK,SAAS,GAAG,gBAAgB,GAC9CJ,IAAI,CAACI,MAAM,KAAK,YAAY,GAAG,aAAa,GAAG,kBAAkB,EAAG;MAAAlD,QAAA,EAEzF,OAAO8C,IAAI,KAAK,QAAQ,GAAGA,IAAI,GAAGA,IAAI,CAACN;IAAK,GAJxCH,GAAG;MAAApC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAKJ,CACP,CAAC;EACJ,CAAC;EAED,oBACET,OAAA;IAAOI,SAAS,EAAC,YAAY;IAAAC,QAAA,eAC3BL,OAAA;MAAAK,QAAA,EACGF,WAAW,CAACD,aAAa,CAAC,CAACgD,GAAG,CAAC,CAACvB,GAAG,EAAE+C,KAAK,kBACzC1E,OAAA;QAAAK,QAAA,eACEL,OAAA;UAAII,SAAS,EAAC,eAAe;UAAAC,QAAA,EAC1BqB,kBAAkB,CAACC,GAAG;QAAC;UAAArB,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACtB;MAAC,GAHEiE,KAAK;QAAApE,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAIV,CACL;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACG;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACH,CAAC;AAEZ,CAAC;AAACkE,EAAA,GA9RI1E,WAAW;AAgSjB,eAAeA,WAAW;AAAC,IAAA0E,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/Documents/github/bunribunryu/src/components/browse/SeparationClassifier.js\";\nimport React from 'react';\nimport './SeparationClassifier.css';\n\n// Utility functions for text processing\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst textUtils = {\n  // String reversal utility\n  reverseString: str => str.split('').reverse().join(''),\n  // Extract tokens from data rows\n  extractTokens: dataRows => {\n    const bracketSet = new Set();\n    const valueSet = new Set();\n    dataRows.forEach(row => {\n      const cellValue = row[0];\n\n      // Skip empty/null values\n      if (cellValue === null || cellValue === undefined || String(cellValue).trim() === '') {\n        return;\n      }\n      const cellValueStr = String(cellValue);\n\n      // 1. Handle bracket content with regex\n      const bracketContentRegex = /\\(([^)]*)\\)|\\[([^\\]]*)\\]|\\{([^}]*)\\}/g;\n      let textWithoutBrackets = cellValueStr.replace(bracketContentRegex, (match, p1, p2, p3) => {\n        const content = p1 || p2 || p3;\n        if (content && content.trim()) {\n          bracketSet.add(content.trim());\n        }\n        return ' ';\n      });\n\n      // 2. Split by spaces and commas\n      const separatedValues = textWithoutBrackets.split(/[\\s,]+/).map(value => value.trim()).filter(value => value.length > 0);\n      separatedValues.forEach(value => {\n        if (value && value.trim()) {\n          valueSet.add(value.trim());\n        }\n      });\n    });\n    return {\n      bracketValues: Array.from(bracketSet).map(val => `[Í¥ÑÌò∏] ${val}`),\n      normalValues: Array.from(valueSet)\n    };\n  },\n  // Find common substring patterns\n  findCommonSubstrings: (tokens, minLength = 1, minCount = 2, direction = 'any') => {\n    // Track substring frequencies\n    const substringFreq = {};\n\n    // Analyze all tokens\n    tokens.forEach(token => {\n      const cleanToken = token.replace('[Í¥ÑÌò∏] ', '');\n\n      // Handle prefixes\n      if (direction === 'prefix' || direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          const substr = cleanToken.substring(0, len);\n          if (substr.length >= minLength) {\n            if (!substringFreq[substr]) {\n              substringFreq[substr] = {\n                count: 1,\n                tokens: [token],\n                direction: 'prefix'\n              };\n            } else if (!substringFreq[substr].tokens.includes(token)) {\n              substringFreq[substr].count++;\n              substringFreq[substr].tokens.push(token);\n              if (substringFreq[substr].direction !== 'prefix') {\n                substringFreq[substr].direction = 'both';\n              }\n            }\n          }\n        }\n      }\n\n      // Handle suffixes\n      if (direction === 'suffix' || direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          const substr = cleanToken.substring(cleanToken.length - len);\n          if (substr.length >= minLength) {\n            if (!substringFreq[substr]) {\n              substringFreq[substr] = {\n                count: 1,\n                tokens: [token],\n                direction: 'suffix'\n              };\n            } else if (!substringFreq[substr].tokens.includes(token)) {\n              substringFreq[substr].count++;\n              substringFreq[substr].tokens.push(token);\n              if (substringFreq[substr].direction !== 'suffix') {\n                substringFreq[substr].direction = 'both';\n              }\n            }\n          }\n        }\n      }\n\n      // Remove middle substring handling as requested - only prefix and suffix are allowed\n    });\n\n    // Filter and sort results - improved to better capture meaningful patterns\n    return Object.entries(substringFreq).filter(([substr, data]) => {\n      // Base filter: meet minimum count\n      const baseFilter = data.count >= minCount;\n\n      // Give priority to Korean character patterns and units\n      const isKorean = /[\\uAC00-\\uD7A3]/.test(substr);\n      const isUnit = /^[a-zA-Z]+$/.test(substr) && substr.length <= 3;\n\n      // Special handling for single characters\n      if (substr.length === 1) {\n        // For Korean single characters, they are more likely meaningful\n        if (isKorean) {\n          return baseFilter && data.count >= 2;\n        }\n        // For non-Korean, require higher frequency\n        const coverage = data.tokens.length / tokens.length * 100;\n        return baseFilter && (coverage >= 25 || data.count >= 3);\n      }\n\n      // Give more weight to units (like kg, g, etc.)\n      if (isUnit && data.count >= 2 && data.direction === 'suffix') {\n        return true;\n      }\n\n      // Give more weight to substrings with Korean characters\n      if (isKorean && substr.length >= 2) {\n        return baseFilter && data.count >= 2;\n      }\n      return baseFilter;\n    }).sort((a, b) => {\n      // First prioritize units like kg, g\n      const aIsUnit = /^[a-zA-Z]+$/.test(a[0]) && a[0].length <= 3 && a[1].direction === 'suffix';\n      const bIsUnit = /^[a-zA-Z]+$/.test(b[0]) && b[0].length <= 3 && b[1].direction === 'suffix';\n      if (aIsUnit && !bIsUnit) return -1;\n      if (!aIsUnit && bIsUnit) return 1;\n\n      // Then prioritize Korean patterns\n      const aIsKorean = /[\\uAC00-\\uD7A3]/.test(a[0]);\n      const bIsKorean = /[\\uAC00-\\uD7A3]/.test(b[0]);\n      if (aIsKorean && !bIsKorean) return -1;\n      if (!aIsKorean && bIsKorean) return 1;\n\n      // Then by token count (descending)\n      const countDiff = b[1].count - a[1].count;\n      if (countDiff !== 0) return countDiff;\n\n      // Then by length (descending)\n      const lengthDiff = b[0].length - a[0].length;\n      if (lengthDiff !== 0) return lengthDiff;\n\n      // Finally by alphabetical order\n      return a[0].localeCompare(b[0]);\n    }).map(([substr, data]) => ({\n      substring: substr,\n      count: data.count,\n      tokens: data.tokens,\n      direction: data.direction,\n      percentCoverage: data.tokens.length / tokens.length * 100,\n      isKorean: /[\\uAC00-\\uD7A3]/.test(substr),\n      isUnit: /^[a-zA-Z]+$/.test(substr) && substr.length <= 3 && data.direction === 'suffix'\n    }));\n  },\n  // Analyze compound word relationships\n  analyzeCompoundRelationships: tokens => {\n    const relationships = [];\n\n    // Compare all token pairs\n    for (let i = 0; i < tokens.length; i++) {\n      const token1 = tokens[i].replace('[Í¥ÑÌò∏] ', '');\n      for (let j = 0; j < tokens.length; j++) {\n        if (i === j) continue;\n        const token2 = tokens[j].replace('[Í¥ÑÌò∏] ', '');\n\n        // Check if token1 is part of token2\n        if (token2.includes(token1)) {\n          const position = token2.indexOf(token1);\n          const beforeChar = position > 0 ? token2[position - 1] : '';\n          const afterChar = position + token1.length < token2.length ? token2[position + token1.length] : '';\n\n          // Check if it's at a word boundary or Korean characters (more flexible for Korean)\n          const isKorean = /[\\uAC00-\\uD7A3]/.test(token1);\n          const isWordBoundary = (position === 0 || beforeChar === ' ' || beforeChar === '-') && (position + token1.length === token2.length || afterChar === ' ' || afterChar === '-');\n\n          // For Korean patterns, be more lenient\n          if (isWordBoundary || isKorean && token1.length >= 1 || !isKorean && token1.length >= 2) {\n            relationships.push({\n              parent: tokens[j],\n              // Compound\n              child: tokens[i],\n              // Component\n              position: position // Position\n            });\n          }\n        }\n      }\n    }\n    return relationships;\n  },\n  // Find common words in tokens\n  findCommonWords: tokens => {\n    // This function specifically finds common Korean words and units\n    const wordFreq = {};\n    const wordRelations = [];\n\n    // Find measurement units (g, kg, etc.)\n    const unitRegex = /(\\d+(?:\\.\\d+)?)\\s*([a-zA-Z]+)$/;\n\n    // First pass: extract all units and words - ONLY at prefix or suffix positions\n    tokens.forEach(token => {\n      const cleanToken = token.replace('[Í¥ÑÌò∏] ', '');\n\n      // Check for measurement units\n      const unitMatch = cleanToken.match(unitRegex);\n      if (unitMatch) {\n        const [_, value, unit] = unitMatch;\n        if (!wordFreq[unit]) {\n          wordFreq[unit] = {\n            count: 1,\n            tokens: [token],\n            isUnit: true\n          };\n        } else if (!wordFreq[unit].tokens.includes(token)) {\n          wordFreq[unit].count++;\n          wordFreq[unit].tokens.push(token);\n\n          // Record relationship\n          wordRelations.push({\n            word: unit,\n            token: token,\n            position: cleanToken.indexOf(unit),\n            isUnit: true\n          });\n        }\n      }\n\n      // Look for Korean character sequences - expand max length to 4 and improve detection\n      const MAX_KOREAN_WORD_LENGTH = 4;\n\n      // Check for known important Korean words specifically\n      const importantKoreanWords = ['ÏûêÏó∞', 'Îì±Í∏â', 'ÎÜçÏû•', 'ÌïúÏö∞', 'ÌïúÎèà', 'ÎèºÏßÄ', 'ÏÜåÍ≥†Í∏∞', 'ÎèºÏßÄÍ≥†Í∏∞'];\n      for (const koreanWord of importantKoreanWords) {\n        // Check prefix position (start of string)\n        if (cleanToken.startsWith(koreanWord)) {\n          if (!wordFreq[koreanWord]) {\n            wordFreq[koreanWord] = {\n              count: 1,\n              tokens: [token],\n              isUnit: false,\n              direction: 'prefix'\n            };\n          } else if (!wordFreq[koreanWord].tokens.includes(token)) {\n            wordFreq[koreanWord].count++;\n            wordFreq[koreanWord].tokens.push(token);\n\n            // Record relationship\n            wordRelations.push({\n              word: koreanWord,\n              token: token,\n              position: 0,\n              isUnit: false,\n              direction: 'prefix'\n            });\n          }\n        }\n\n        // Check suffix position (end of string)\n        if (cleanToken.endsWith(koreanWord)) {\n          if (!wordFreq[koreanWord]) {\n            wordFreq[koreanWord] = {\n              count: 1,\n              tokens: [token],\n              isUnit: false,\n              direction: 'suffix'\n            };\n          } else if (!wordFreq[koreanWord].tokens.includes(token)) {\n            wordFreq[koreanWord].count++;\n            wordFreq[koreanWord].tokens.push(token);\n\n            // Record relationship\n            wordRelations.push({\n              word: koreanWord,\n              token: token,\n              position: cleanToken.length - koreanWord.length,\n              isUnit: false,\n              direction: 'suffix'\n            });\n          }\n        }\n      }\n\n      // General approach - look for any Korean words of various lengths\n      for (let len = 2; len <= MAX_KOREAN_WORD_LENGTH; len++) {\n        if (len <= cleanToken.length) {\n          // Prefix (start position)\n          const prefixWord = cleanToken.substring(0, len);\n          if (/^[\\uAC00-\\uD7A3]+$/.test(prefixWord)) {\n            if (!wordFreq[prefixWord]) {\n              wordFreq[prefixWord] = {\n                count: 1,\n                tokens: [token],\n                isUnit: false,\n                direction: 'prefix'\n              };\n            } else if (!wordFreq[prefixWord].tokens.includes(token)) {\n              wordFreq[prefixWord].count++;\n              wordFreq[prefixWord].tokens.push(token);\n\n              // Record relationship\n              wordRelations.push({\n                word: prefixWord,\n                token: token,\n                position: 0,\n                // Always at start\n                isUnit: false,\n                direction: 'prefix'\n              });\n            }\n          }\n\n          // Suffix (end position)\n          const suffixWord = cleanToken.substring(cleanToken.length - len);\n          if (/^[\\uAC00-\\uD7A3]+$/.test(suffixWord)) {\n            if (!wordFreq[suffixWord]) {\n              wordFreq[suffixWord] = {\n                count: 1,\n                tokens: [token],\n                isUnit: false,\n                direction: 'suffix'\n              };\n            } else if (!wordFreq[suffixWord].tokens.includes(token)) {\n              wordFreq[suffixWord].count++;\n              wordFreq[suffixWord].tokens.push(token);\n\n              // Record relationship\n              wordRelations.push({\n                word: suffixWord,\n                token: token,\n                position: cleanToken.length - len,\n                // Position at end\n                isUnit: false,\n                direction: 'suffix'\n              });\n            }\n          }\n        }\n      }\n    });\n\n    // Filter to only keep words that appear in multiple tokens\n    const commonWords = Object.entries(wordFreq).filter(([word, data]) => data.count >= 2).sort((a, b) => {\n      // Prioritize units\n      if (a[1].isUnit && !b[1].isUnit) return -1;\n      if (!a[1].isUnit && b[1].isUnit) return 1;\n\n      // Prioritize important Korean words\n      const importantA = ['ÏûêÏó∞', 'Îì±Í∏â', 'ÎÜçÏû•', 'ÌïúÏö∞', 'ÌïúÎèà'].includes(a[0]);\n      const importantB = ['ÏûêÏó∞', 'Îì±Í∏â', 'ÎÜçÏû•', 'ÌïúÏö∞', 'ÌïúÎèà'].includes(b[0]);\n      if (importantA && !importantB) return -1;\n      if (!importantA && importantB) return 1;\n\n      // Sort by frequency first\n      const countDiff = b[1].count - a[1].count;\n      if (countDiff !== 0) return countDiff;\n\n      // Then by length (prefer longer words)\n      return b[0].length - a[0].length;\n    }).map(([word, data]) => ({\n      word,\n      count: data.count,\n      tokens: data.tokens,\n      isUnit: data.isUnit,\n      direction: data.direction\n    }));\n\n    // Group the relationships by common word\n    const wordGroups = [];\n    commonWords.forEach(commonWord => {\n      const relatedTokens = wordRelations.filter(rel => rel.word === commonWord.word).map(rel => ({\n        token: rel.token,\n        position: rel.position,\n        isUnit: rel.isUnit,\n        direction: rel.direction\n      }));\n      wordGroups.push({\n        word: commonWord.word,\n        count: commonWord.count,\n        tokens: commonWord.tokens,\n        relations: relatedTokens,\n        isUnit: commonWord.isUnit,\n        direction: commonWord.direction\n      });\n    });\n    return wordGroups;\n  },\n  // Select optimal substrings for grouping\n  selectOptimalSubstrings: (substrings, tokens, compoundRel, maxGroups = 15) => {\n    // First, identify important Korean substrings\n    const koreanSubstrings = substrings.filter(substr => substr.isKorean && substr.count >= 2);\n\n    // Sort by coverage and importance\n    const sortedSubstrings = [...substrings].sort((a, b) => {\n      // Prioritize Korean patterns\n      if (a.isKorean && !b.isKorean) return -1;\n      if (!a.isKorean && b.isKorean) return 1;\n\n      // Prioritize substrings that have compound relationships\n      const hasCompoundA = compoundRel.some(rel => rel.parent.includes(a.substring) || rel.child.includes(a.substring));\n      const hasCompoundB = compoundRel.some(rel => rel.parent.includes(b.substring) || rel.child.includes(b.substring));\n      if (hasCompoundA && !hasCompoundB) return -1;\n      if (!hasCompoundA && hasCompoundB) return 1;\n\n      // Score based on count and length\n      // Modified to give more weight to meaningful substrings (e.g., \"Îì±Í∏â\", \"ÏûêÏó∞\")\n      const scoreA = a.count * (a.isKorean ? Math.pow(a.substring.length, 1.5) : a.substring.length);\n      const scoreB = b.count * (b.isKorean ? Math.pow(b.substring.length, 1.5) : b.substring.length);\n      return scoreB - scoreA;\n    });\n    const selectedSubstrings = [];\n    const coveredTokens = new Set();\n\n    // First, include important Korean substrings\n    for (const substr of koreanSubstrings) {\n      if (substr.substring.length >= 1 && substr.count >= 2) {\n        // Check if this is a meaningful Korean term\n        if (/[Í∞Ä-Ìû£]{1,}/.test(substr.substring)) {\n          selectedSubstrings.push(substr);\n\n          // Update covered tokens\n          substr.tokens.forEach(token => coveredTokens.add(token));\n\n          // Limit Korean groups\n          if (selectedSubstrings.length >= Math.ceil(maxGroups * 0.6)) break;\n        }\n      }\n    }\n\n    // Then add other important substrings\n    for (const substr of sortedSubstrings) {\n      // Skip if already selected\n      if (selectedSubstrings.some(s => s.substring === substr.substring)) {\n        continue;\n      }\n\n      // Check if this covers new tokens\n      const newCoverage = substr.tokens.some(token => !coveredTokens.has(token));\n\n      // Selection criteria - relaxed for Korean patterns\n      const isImportantSubstr = substr.isKorean && substr.count >= 2 || substr.substring.length >= 2 && substr.count >= 3;\n      const isHighSupportSingleChar = substr.substring.length === 1 && substr.count >= Math.max(3, tokens.length * 0.15);\n      if (newCoverage || isImportantSubstr || isHighSupportSingleChar) {\n        selectedSubstrings.push(substr);\n\n        // Update covered tokens\n        substr.tokens.forEach(token => coveredTokens.add(token));\n      }\n\n      // Limit groups\n      if (selectedSubstrings.length >= maxGroups) break;\n    }\n    return selectedSubstrings;\n  },\n  // Form compound word relationship groups\n  formCompoundGroups: relationships => {\n    // Group by parent token\n    const compoundGroups = {};\n    relationships.forEach(rel => {\n      const parentToken = rel.parent;\n      if (!compoundGroups[parentToken]) {\n        compoundGroups[parentToken] = {\n          parent: parentToken,\n          children: [rel.child],\n          positions: [rel.position]\n        };\n      } else if (!compoundGroups[parentToken].children.includes(rel.child)) {\n        compoundGroups[parentToken].children.push(rel.child);\n        compoundGroups[parentToken].positions.push(rel.position);\n      }\n    });\n\n    // Sort by number of children (descending)\n    return Object.values(compoundGroups).sort((a, b) => b.children.length - a.children.length).filter(group => group.children.length >= 2) // At least 2 children\n    .slice(0, 5); // Top 5 only\n  }\n};\n\n// Main component for classification results\nconst SeparationClassifier = ({\n  data,\n  onReset\n}) => {\n  // Empty data handling\n  if (!data || !data.rows || data.rows.length === 0) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"separation-empty\",\n      children: \"No data to classify\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 511,\n      columnNumber: 12\n    }, this);\n  }\n\n  // Process and classify the data\n  const processData = () => {\n    const {\n      bracketValues,\n      normalValues\n    } = textUtils.extractTokens(data.rows);\n\n    // No results case\n    if (bracketValues.length === 0 && normalValues.length === 0) {\n      return {\n        headers: [\"Group\", \"Token\"],\n        rows: [[\"\", \"Î∂ÑÎ¶¨Îêú Í∞íÏù¥ ÏóÜÏäµÎãàÎã§\"]]\n      };\n    }\n\n    // All tokens\n    const allMinTokens = [...bracketValues, ...normalValues];\n\n    // Find common Korean words in tokens\n    const commonWordGroups = textUtils.findCommonWords(allMinTokens);\n\n    // Analyze compound relationships\n    const compoundRelationships = textUtils.analyzeCompoundRelationships(allMinTokens);\n\n    // Get directional substrings\n    const prefixSubstrings = textUtils.findCommonSubstrings(allMinTokens, 1, 2, 'prefix');\n    const suffixSubstrings = textUtils.findCommonSubstrings(allMinTokens, 1, 2, 'suffix');\n\n    // Select optimal substrings\n    const optimalPrefixSubstrings = textUtils.selectOptimalSubstrings(prefixSubstrings, allMinTokens, compoundRelationships, 8);\n    const optimalSuffixSubstrings = textUtils.selectOptimalSubstrings(suffixSubstrings, allMinTokens, compoundRelationships, 8);\n\n    // Build compound groups\n    const compoundGroups = textUtils.formCompoundGroups(compoundRelationships);\n\n    // Build results data structure\n    const finalRows = [];\n\n    // 1. Prefix groups\n    finalRows.push([\"üå≤ Ï†ëÎëêÏÇ¨ Í∏∞Ï§Ä Í∑∏Î£π (ÏïûÍ∏ÄÏûêÏàú)\", \"\"]);\n    optimalPrefixSubstrings.forEach(group => {\n      finalRows.push([`üìå ÏïûÎ∂ÄÎ∂Ñ: ${group.substring} (${group.count})`, \"\"]);\n      const groupTokens = group.tokens.sort((a, b) => {\n        const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n        const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n        if (aIsBracket && !bIsBracket) return -1;\n        if (!aIsBracket && bIsBracket) return 1;\n        return a.localeCompare(b);\n      });\n      groupTokens.forEach(token => {\n        finalRows.push([\"‚îî‚îÄ\", token]);\n      });\n      finalRows.push([\"\", \"\"]);\n    });\n\n    // 2. Suffix groups\n    finalRows.push([\"üå≤ Ï†ëÎØ∏ÏÇ¨ Í∏∞Ï§Ä Í∑∏Î£π (Îí∑Í∏ÄÏûêÏàú)\", \"\"]);\n    optimalSuffixSubstrings.forEach(group => {\n      finalRows.push([`üìå Îí∑Î∂ÄÎ∂Ñ: ${group.substring} (${group.count})`, \"\"]);\n      const groupTokens = group.tokens.sort((a, b) => {\n        const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n        const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n        if (aIsBracket && !bIsBracket) return -1;\n        if (!aIsBracket && bIsBracket) return 1;\n        return textUtils.reverseString(a.replace('[Í¥ÑÌò∏] ', '')).localeCompare(textUtils.reverseString(b.replace('[Í¥ÑÌò∏] ', '')));\n      });\n      groupTokens.forEach(token => {\n        finalRows.push([\"‚îî‚îÄ\", token]);\n      });\n      finalRows.push([\"\", \"\"]);\n    });\n\n    // 3. Common Korean word groups\n    if (commonWordGroups.length > 0) {\n      finalRows.push([\"üå≤ Îã®Ïñ¥ Í∏∞Ï§Ä Í∑∏Î£π\", \"\"]);\n      commonWordGroups.forEach(group => {\n        // Skip if too few tokens or already covered well by other groups\n        if (group.count < 2 || group.word.length < 1) return;\n        finalRows.push([`üìå Îã®Ïñ¥: ${group.word} (${group.count})`, \"\"]);\n\n        // Sort tokens\n        const sortedTokens = [...group.tokens].sort((a, b) => {\n          const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n          const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n          if (aIsBracket && !bIsBracket) return -1;\n          if (!aIsBracket && bIsBracket) return 1;\n          return a.localeCompare(b);\n        });\n        sortedTokens.forEach(token => {\n          // Find position\n          const relation = group.relations.find(r => r.token === token);\n          const position = relation ? relation.position : -1;\n          const cleanToken = token.replace('[Í¥ÑÌò∏] ', '');\n          let positionMarker = '';\n          if (position === 0) {\n            positionMarker = '‚¨ÖÔ∏è Ï≤òÏùå';\n          } else if (position + group.word.length === cleanToken.length) {\n            positionMarker = '‚û°Ô∏è ÎÅù';\n          } else if (position > 0) {\n            positionMarker = '‚¨áÔ∏è Ï§ëÍ∞Ñ';\n          }\n          finalRows.push([`‚îî‚îÄ ${positionMarker.length > 0 ? `[${positionMarker}]` : ''}`, token]);\n        });\n        finalRows.push([\"\", \"\"]);\n      });\n    }\n\n    // 4. Compound relationships\n    if (compoundGroups.length > 0) {\n      finalRows.push([\"üå≤ Î≥µÌï©Ïñ¥ Í¥ÄÍ≥Ñ Í∑∏Î£π\", \"\"]);\n      compoundGroups.forEach(group => {\n        finalRows.push([`üìå Î≥µÌï©Ïñ¥: ${group.parent.replace('[Í¥ÑÌò∏] ', '')} (${group.children.length})`, group.parent]);\n        group.children.forEach((child, idx) => {\n          const position = group.positions[idx];\n          const parentClean = group.parent.replace('[Í¥ÑÌò∏] ', '');\n          const childClean = child.replace('[Í¥ÑÌò∏] ', '');\n          let positionMarker = '';\n          if (position === 0) {\n            positionMarker = '‚¨ÖÔ∏è ÏãúÏûë Î∂ÄÎ∂Ñ';\n          } else if (position + childClean.length === parentClean.length) {\n            positionMarker = '‚û°Ô∏è ÎÅù Î∂ÄÎ∂Ñ';\n          } else {\n            positionMarker = '‚¨áÔ∏è Ï§ëÍ∞Ñ Î∂ÄÎ∂Ñ';\n          }\n          finalRows.push([`‚îî‚îÄ [${positionMarker}]`, child]);\n        });\n        finalRows.push([\"\", \"\"]);\n      });\n    }\n\n    // 5. Ungrouped tokens\n    const allGroupedTokens = new Set();\n    optimalPrefixSubstrings.forEach(group => group.tokens.forEach(token => allGroupedTokens.add(token)));\n    optimalSuffixSubstrings.forEach(group => group.tokens.forEach(token => allGroupedTokens.add(token)));\n    commonWordGroups.forEach(group => group.tokens.forEach(token => allGroupedTokens.add(token)));\n    compoundGroups.forEach(group => {\n      allGroupedTokens.add(group.parent);\n      group.children.forEach(child => allGroupedTokens.add(child));\n    });\n    const ungroupedTokens = allMinTokens.filter(token => !allGroupedTokens.has(token)).sort();\n    if (ungroupedTokens.length > 0) {\n      finalRows.push([\"üå≤ ÎØ∏Î∂ÑÎ•ò ÌÜ†ÌÅ∞\", \"\"]);\n      ungroupedTokens.forEach(token => {\n        finalRows.push([\"‚îî‚îÄ\", token]);\n      });\n    }\n    return {\n      prefixGroups: optimalPrefixSubstrings.map(group => ({\n        substring: group.substring,\n        count: group.count,\n        tokens: group.tokens.sort((a, b) => {\n          const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n          const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n          if (aIsBracket && !bIsBracket) return -1;\n          if (!aIsBracket && bIsBracket) return 1;\n          return a.localeCompare(b);\n        })\n      })),\n      suffixGroups: optimalSuffixSubstrings.map(group => ({\n        substring: group.substring,\n        count: group.count,\n        tokens: group.tokens.sort((a, b) => {\n          const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n          const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n          if (aIsBracket && !bIsBracket) return -1;\n          if (!aIsBracket && bIsBracket) return 1;\n          return textUtils.reverseString(a.replace('[Í¥ÑÌò∏] ', '')).localeCompare(textUtils.reverseString(b.replace('[Í¥ÑÌò∏] ', '')));\n        })\n      })),\n      wordGroups: commonWordGroups.filter(group => group.count >= 2 && group.word.length >= 1).map(group => ({\n        word: group.word,\n        count: group.count,\n        tokens: group.tokens.sort((a, b) => {\n          const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n          const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n          if (aIsBracket && !bIsBracket) return -1;\n          if (!aIsBracket && bIsBracket) return 1;\n          return a.localeCompare(b);\n        }),\n        relations: group.relations\n      })),\n      compoundGroups,\n      ungroupedTokens\n    };\n  };\n\n  // Processed classification data\n  const classificationData = processData();\n\n  // Render tree node with children\n  const renderTreeNode = (label, children, nodeType, nodeSubtype = '') => /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `tree-node ${nodeType} ${nodeSubtype}`,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"tree-node-label\",\n      children: label\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 762,\n      columnNumber: 7\n    }, this), children && children.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"tree-node-children\",\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 764,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 761,\n    columnNumber: 5\n  }, this);\n\n  // Render token node (leaf)\n  const renderTokenNode = token => {\n    const isBracketContent = String(token).startsWith('[Í¥ÑÌò∏]');\n    let displayContent = token;\n    if (isBracketContent) {\n      displayContent = /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"bracket-indicator\",\n          children: \"\\u2282\\u2283\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 779,\n          columnNumber: 11\n        }, this), String(token).replace('[Í¥ÑÌò∏] ', '')]\n      }, void 0, true);\n    }\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: `token-node ${isBracketContent ? 'bracket-content' : ''}`,\n      children: displayContent\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 786,\n      columnNumber: 7\n    }, this);\n  };\n\n  // Render position indicator for tokens\n  const renderPositionIndicator = (position, direction) => {\n    if (direction === 'prefix' || position === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"position-indicator position-start\",\n        children: \"\\u2B05\\uFE0F \\uCC98\\uC74C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 795,\n        columnNumber: 14\n      }, this);\n    } else if (direction === 'suffix') {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"position-indicator position-end\",\n        children: \"\\u27A1\\uFE0F \\uB05D\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 797,\n        columnNumber: 14\n      }, this);\n    }\n    return null;\n  };\n\n  // Render the classification results with dendrogram-style visualization\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"separation-classifier\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"classifier-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"\\uBD84\\uB9AC\\uBD84\\uB958 \\uACB0\\uACFC\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 806,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"reset-button\",\n        onClick: onReset,\n        title: \"\\uC6D0\\uBCF8 \\uB370\\uC774\\uD130\\uB85C \\uBCF5\\uC6D0\",\n        children: /*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\uD83D\\uDD04 \\uC6D0\\uBCF8\\uC73C\\uB85C \\uBCF5\\uC6D0\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 808,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 807,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 805,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"dendrogram-container\",\n      children: [classificationData.wordGroups && classificationData.wordGroups.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tree-category\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-category-header\",\n          children: /*#__PURE__*/_jsxDEV(\"h4\", {\n            children: \"\\uD83C\\uDF32 \\uB2E8\\uC5B4 \\uAE30\\uC900 \\uADF8\\uB8F9\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 817,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 816,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-content\",\n          children: classificationData.wordGroups.map((group, idx) => {\n            // Skip groups where the word is not at start or end of all tokens\n            if (!group.isUnit && !group.direction) {\n              return null;\n            }\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"group-tree\",\n              children: renderTreeNode(/*#__PURE__*/_jsxDEV(_Fragment, {\n                children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                  className: \"group-marker\",\n                  children: \"\\uD83D\\uDCCC\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 829,\n                  columnNumber: 25\n                }, this), \" \", group.isUnit ? `Îã®ÏúÑ: ${group.word}` : group.direction === 'prefix' ? `ÏïûÎ∂ÄÎ∂Ñ Îã®Ïñ¥: ${group.word}` : group.direction === 'suffix' ? `Îí∑Î∂ÄÎ∂Ñ Îã®Ïñ¥: ${group.word}` : `Îã®Ïñ¥: ${group.word}`, /*#__PURE__*/_jsxDEV(\"span\", {\n                  className: \"count-badge\",\n                  children: [\"(\", group.count, \")\"]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 832,\n                  columnNumber: 26\n                }, this)]\n              }, void 0, true), group.tokens.map((token, tokenIdx) => {\n                // Find position info\n                const relation = group.relations.find(r => r.token === token);\n                return /*#__PURE__*/_jsxDEV(\"div\", {\n                  className: \"tree-branch with-position\",\n                  children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                    className: \"branch-line\"\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 839,\n                    columnNumber: 29\n                  }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                    className: \"branch-content\",\n                    children: [!group.isUnit && relation && renderPositionIndicator(relation.position, relation.direction), renderTokenNode(token)]\n                  }, void 0, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 840,\n                    columnNumber: 29\n                  }, this)]\n                }, `word-${idx}-token-${tokenIdx}`, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 838,\n                  columnNumber: 27\n                }, this);\n              }), 'group-node', group.isUnit ? 'unit-group' : group.direction === 'prefix' ? 'prefix-word-group' : group.direction === 'suffix' ? 'suffix-word-group' : 'word-group')\n            }, `word-${idx}`, false, {\n              fileName: _jsxFileName,\n              lineNumber: 827,\n              columnNumber: 19\n            }, this);\n          })\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 819,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 815,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tree-category\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-category-header\",\n          children: /*#__PURE__*/_jsxDEV(\"h4\", {\n            children: \"\\uD83C\\uDF32 \\uC811\\uB450\\uC0AC \\uAE30\\uC900 \\uADF8\\uB8F9 (\\uC55E\\uAE00\\uC790\\uC21C)\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 862,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 861,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-content\",\n          children: classificationData.prefixGroups.map((group, idx) => /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"group-tree\",\n            children: renderTreeNode(/*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"group-marker\",\n                children: \"\\uD83D\\uDCCC\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 868,\n                columnNumber: 21\n              }, this), \" \\uC55E\\uBD80\\uBD84: \", group.substring, \" \", /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"count-badge\",\n                children: [\"(\", group.count, \")\"]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 868,\n                columnNumber: 85\n              }, this)]\n            }, void 0, true), group.tokens.map((token, tokenIdx) => /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"tree-branch\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"branch-line\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 871,\n                columnNumber: 23\n              }, this), renderTokenNode(token)]\n            }, `prefix-${idx}-token-${tokenIdx}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 870,\n              columnNumber: 21\n            }, this)), 'group-node', 'prefix-group')\n          }, `prefix-${idx}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 866,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 864,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 860,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tree-category\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-category-header\",\n          children: /*#__PURE__*/_jsxDEV(\"h4\", {\n            children: \"\\uD83C\\uDF32 \\uC811\\uBBF8\\uC0AC \\uAE30\\uC900 \\uADF8\\uB8F9 (\\uB4B7\\uAE00\\uC790\\uC21C)\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 886,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 885,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-content\",\n          children: classificationData.suffixGroups.map((group, idx) => /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"group-tree\",\n            children: renderTreeNode(/*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"group-marker\",\n                children: \"\\uD83D\\uDCCC\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 892,\n                columnNumber: 21\n              }, this), \" \\uB4B7\\uBD80\\uBD84: \", group.substring, \" \", /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"count-badge\",\n                children: [\"(\", group.count, \")\"]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 892,\n                columnNumber: 85\n              }, this)]\n            }, void 0, true), group.tokens.map((token, tokenIdx) => /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"tree-branch\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"branch-line\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 895,\n                columnNumber: 23\n              }, this), renderTokenNode(token)]\n            }, `suffix-${idx}-token-${tokenIdx}`, true, {\n              fileName: _jsxFileName,\n              lineNumber: 894,\n              columnNumber: 21\n            }, this)), 'group-node', 'suffix-group')\n          }, `suffix-${idx}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 890,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 888,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 884,\n        columnNumber: 9\n      }, this), classificationData.compoundGroups && classificationData.compoundGroups.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tree-category\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-category-header\",\n          children: /*#__PURE__*/_jsxDEV(\"h4\", {\n            children: \"\\uD83C\\uDF32 \\uBCF5\\uD569\\uC5B4 \\uAD00\\uACC4 \\uADF8\\uB8F9\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 911,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 910,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-content\",\n          children: classificationData.compoundGroups.map((group, idx) => {\n            const parentClean = group.parent.replace('[Í¥ÑÌò∏] ', '');\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"group-tree\",\n              children: renderTreeNode(/*#__PURE__*/_jsxDEV(_Fragment, {\n                children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                  className: \"group-marker\",\n                  children: \"\\uD83D\\uDCCC\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 920,\n                  columnNumber: 25\n                }, this), \" \\uBCF5\\uD569\\uC5B4: \", parentClean, \" \", /*#__PURE__*/_jsxDEV(\"span\", {\n                  className: \"count-badge\",\n                  children: [\"(\", group.children.length, \")\"]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 920,\n                  columnNumber: 85\n                }, this)]\n              }, void 0, true), group.children.map((child, childIdx) => {\n                const position = group.positions[childIdx];\n                const childClean = child.replace('[Í¥ÑÌò∏] ', '');\n                return /*#__PURE__*/_jsxDEV(\"div\", {\n                  className: \"tree-branch with-position\",\n                  children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                    className: \"branch-line\"\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 927,\n                    columnNumber: 29\n                  }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                    className: \"branch-content\",\n                    children: [position === 0 ? /*#__PURE__*/_jsxDEV(\"span\", {\n                      className: \"position-indicator position-start\",\n                      children: \"\\u2B05\\uFE0F \\uCC98\\uC74C\"\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 930,\n                      columnNumber: 33\n                    }, this) : position + childClean.length === parentClean.length ? /*#__PURE__*/_jsxDEV(\"span\", {\n                      className: \"position-indicator position-end\",\n                      children: \"\\u27A1\\uFE0F \\uB05D\"\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 932,\n                      columnNumber: 33\n                    }, this) : null, renderTokenNode(child)]\n                  }, void 0, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 928,\n                    columnNumber: 29\n                  }, this)]\n                }, `compound-${idx}-child-${childIdx}`, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 926,\n                  columnNumber: 27\n                }, this);\n              }), 'group-node', 'compound-group')\n            }, `compound-${idx}`, false, {\n              fileName: _jsxFileName,\n              lineNumber: 918,\n              columnNumber: 19\n            }, this);\n          })\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 913,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 909,\n        columnNumber: 11\n      }, this), classificationData.ungroupedTokens && classificationData.ungroupedTokens.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tree-category\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-category-header\",\n          children: /*#__PURE__*/_jsxDEV(\"h4\", {\n            children: \"\\uD83C\\uDF32 \\uBBF8\\uBD84\\uB958 \\uD1A0\\uD070\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 953,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 952,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tree-content ungrouped-content\",\n          children: classificationData.ungroupedTokens.map((token, idx) => /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"ungrouped-token\",\n            children: renderTokenNode(token)\n          }, `ungrouped-${idx}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 957,\n            columnNumber: 17\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 955,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 951,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 812,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 804,\n    columnNumber: 5\n  }, this);\n};\n_c = SeparationClassifier;\nexport default SeparationClassifier;\nvar _c;\n$RefreshReg$(_c, \"SeparationClassifier\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","Fragment","_Fragment","textUtils","reverseString","str","split","reverse","join","extractTokens","dataRows","bracketSet","Set","valueSet","forEach","row","cellValue","undefined","String","trim","cellValueStr","bracketContentRegex","textWithoutBrackets","replace","match","p1","p2","p3","content","add","separatedValues","map","value","filter","length","bracketValues","Array","from","val","normalValues","findCommonSubstrings","tokens","minLength","minCount","direction","substringFreq","token","cleanToken","len","substr","substring","count","includes","push","Object","entries","data","baseFilter","isKorean","test","isUnit","coverage","sort","a","b","aIsUnit","bIsUnit","aIsKorean","bIsKorean","countDiff","lengthDiff","localeCompare","percentCoverage","analyzeCompoundRelationships","relationships","i","token1","j","token2","position","indexOf","beforeChar","afterChar","isWordBoundary","parent","child","findCommonWords","wordFreq","wordRelations","unitRegex","unitMatch","_","unit","word","MAX_KOREAN_WORD_LENGTH","importantKoreanWords","koreanWord","startsWith","endsWith","prefixWord","suffixWord","commonWords","importantA","importantB","wordGroups","commonWord","relatedTokens","rel","relations","selectOptimalSubstrings","substrings","compoundRel","maxGroups","koreanSubstrings","sortedSubstrings","hasCompoundA","some","hasCompoundB","scoreA","Math","pow","scoreB","selectedSubstrings","coveredTokens","ceil","s","newCoverage","has","isImportantSubstr","isHighSupportSingleChar","max","formCompoundGroups","compoundGroups","parentToken","children","positions","values","group","slice","SeparationClassifier","onReset","rows","className","fileName","_jsxFileName","lineNumber","columnNumber","processData","headers","allMinTokens","commonWordGroups","compoundRelationships","prefixSubstrings","suffixSubstrings","optimalPrefixSubstrings","optimalSuffixSubstrings","finalRows","groupTokens","aIsBracket","bIsBracket","sortedTokens","relation","find","r","positionMarker","idx","parentClean","childClean","allGroupedTokens","ungroupedTokens","prefixGroups","suffixGroups","classificationData","renderTreeNode","label","nodeType","nodeSubtype","renderTokenNode","isBracketContent","displayContent","renderPositionIndicator","onClick","title","tokenIdx","childIdx","_c","$RefreshReg$"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/SeparationClassifier.js"],"sourcesContent":["import React from 'react';\nimport './SeparationClassifier.css';\n\n// Utility functions for text processing\nconst textUtils = {\n  // String reversal utility\n  reverseString: (str) => str.split('').reverse().join(''),\n  \n  // Extract tokens from data rows\n  extractTokens: (dataRows) => {\n    const bracketSet = new Set();\n    const valueSet = new Set();\n    \n    dataRows.forEach(row => {\n      const cellValue = row[0];\n      \n      // Skip empty/null values\n      if (cellValue === null || cellValue === undefined || String(cellValue).trim() === '') {\n        return;\n      }\n      \n      const cellValueStr = String(cellValue);\n      \n      // 1. Handle bracket content with regex\n      const bracketContentRegex = /\\(([^)]*)\\)|\\[([^\\]]*)\\]|\\{([^}]*)\\}/g;\n      let textWithoutBrackets = cellValueStr.replace(bracketContentRegex, (match, p1, p2, p3) => {\n        const content = p1 || p2 || p3; \n        if (content && content.trim()) {\n          bracketSet.add(content.trim());\n        }\n        return ' '; \n      });\n      \n      // 2. Split by spaces and commas\n      const separatedValues = textWithoutBrackets\n        .split(/[\\s,]+/)\n        .map(value => value.trim())\n        .filter(value => value.length > 0);\n      \n      separatedValues.forEach(value => {\n        if (value && value.trim()) {\n          valueSet.add(value.trim());\n        }\n      });\n    });\n    \n    return {\n      bracketValues: Array.from(bracketSet).map(val => `[Í¥ÑÌò∏] ${val}`),\n      normalValues: Array.from(valueSet),\n    };\n  },\n  \n  // Find common substring patterns\n  findCommonSubstrings: (tokens, minLength = 1, minCount = 2, direction = 'any') => {\n    // Track substring frequencies\n    const substringFreq = {};\n    \n    // Analyze all tokens\n    tokens.forEach(token => {\n      const cleanToken = token.replace('[Í¥ÑÌò∏] ', '');\n      \n      // Handle prefixes\n      if (direction === 'prefix' || direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          const substr = cleanToken.substring(0, len);\n          if (substr.length >= minLength) {\n            if (!substringFreq[substr]) {\n              substringFreq[substr] = { \n                count: 1, \n                tokens: [token],\n                direction: 'prefix'\n              };\n            } else if (!substringFreq[substr].tokens.includes(token)) {\n              substringFreq[substr].count++;\n              substringFreq[substr].tokens.push(token);\n              if (substringFreq[substr].direction !== 'prefix') {\n                substringFreq[substr].direction = 'both';\n              }\n            }\n          }\n        }\n      }\n      \n      // Handle suffixes\n      if (direction === 'suffix' || direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          const substr = cleanToken.substring(cleanToken.length - len);\n          if (substr.length >= minLength) {\n            if (!substringFreq[substr]) {\n              substringFreq[substr] = { \n                count: 1, \n                tokens: [token],\n                direction: 'suffix'\n              };\n            } else if (!substringFreq[substr].tokens.includes(token)) {\n              substringFreq[substr].count++;\n              substringFreq[substr].tokens.push(token);\n              if (substringFreq[substr].direction !== 'suffix') {\n                substringFreq[substr].direction = 'both';\n              }\n            }\n          }\n        }\n      }\n      \n      // Remove middle substring handling as requested - only prefix and suffix are allowed\n    });\n    \n    // Filter and sort results - improved to better capture meaningful patterns\n    return Object.entries(substringFreq)\n      .filter(([substr, data]) => {\n        // Base filter: meet minimum count\n        const baseFilter = data.count >= minCount;\n        \n        // Give priority to Korean character patterns and units\n        const isKorean = /[\\uAC00-\\uD7A3]/.test(substr);\n        const isUnit = /^[a-zA-Z]+$/.test(substr) && substr.length <= 3;\n        \n        // Special handling for single characters\n        if (substr.length === 1) {\n          // For Korean single characters, they are more likely meaningful\n          if (isKorean) {\n            return baseFilter && (data.count >= 2);\n          }\n          // For non-Korean, require higher frequency\n          const coverage = (data.tokens.length / tokens.length) * 100;\n          return baseFilter && (coverage >= 25 || data.count >= 3);\n        }\n        \n        // Give more weight to units (like kg, g, etc.)\n        if (isUnit && data.count >= 2 && data.direction === 'suffix') {\n          return true;\n        }\n        \n        // Give more weight to substrings with Korean characters\n        if (isKorean && substr.length >= 2) {\n          return baseFilter && data.count >= 2;\n        }\n        \n        return baseFilter;\n      })\n      .sort((a, b) => {\n        // First prioritize units like kg, g\n        const aIsUnit = /^[a-zA-Z]+$/.test(a[0]) && a[0].length <= 3 && a[1].direction === 'suffix';\n        const bIsUnit = /^[a-zA-Z]+$/.test(b[0]) && b[0].length <= 3 && b[1].direction === 'suffix';\n        \n        if (aIsUnit && !bIsUnit) return -1;\n        if (!aIsUnit && bIsUnit) return 1;\n        \n        // Then prioritize Korean patterns\n        const aIsKorean = /[\\uAC00-\\uD7A3]/.test(a[0]);\n        const bIsKorean = /[\\uAC00-\\uD7A3]/.test(b[0]);\n        \n        if (aIsKorean && !bIsKorean) return -1;\n        if (!aIsKorean && bIsKorean) return 1;\n        \n        // Then by token count (descending)\n        const countDiff = b[1].count - a[1].count;\n        if (countDiff !== 0) return countDiff;\n        \n        // Then by length (descending)\n        const lengthDiff = b[0].length - a[0].length;\n        if (lengthDiff !== 0) return lengthDiff;\n        \n        // Finally by alphabetical order\n        return a[0].localeCompare(b[0]);\n      })\n      .map(([substr, data]) => ({\n        substring: substr,\n        count: data.count,\n        tokens: data.tokens,\n        direction: data.direction,\n        percentCoverage: (data.tokens.length / tokens.length) * 100,\n        isKorean: /[\\uAC00-\\uD7A3]/.test(substr),\n        isUnit: /^[a-zA-Z]+$/.test(substr) && substr.length <= 3 && data.direction === 'suffix'\n      }));\n  },\n  \n  // Analyze compound word relationships\n  analyzeCompoundRelationships: (tokens) => {\n    const relationships = [];\n    \n    // Compare all token pairs\n    for (let i = 0; i < tokens.length; i++) {\n      const token1 = tokens[i].replace('[Í¥ÑÌò∏] ', '');\n      \n      for (let j = 0; j < tokens.length; j++) {\n        if (i === j) continue;\n        \n        const token2 = tokens[j].replace('[Í¥ÑÌò∏] ', '');\n        \n        // Check if token1 is part of token2\n        if (token2.includes(token1)) {\n          const position = token2.indexOf(token1);\n          const beforeChar = position > 0 ? token2[position - 1] : '';\n          const afterChar = position + token1.length < token2.length ? token2[position + token1.length] : '';\n          \n          // Check if it's at a word boundary or Korean characters (more flexible for Korean)\n          const isKorean = /[\\uAC00-\\uD7A3]/.test(token1);\n          const isWordBoundary = (position === 0 || beforeChar === ' ' || beforeChar === '-') &&\n                                (position + token1.length === token2.length || afterChar === ' ' || afterChar === '-');\n          \n          // For Korean patterns, be more lenient\n          if (isWordBoundary || (isKorean && token1.length >= 1) || (!isKorean && token1.length >= 2)) {\n            relationships.push({\n              parent: tokens[j],   // Compound\n              child: tokens[i],    // Component\n              position: position   // Position\n            });\n          }\n        }\n      }\n    }\n    \n    return relationships;\n  },\n  \n  // Find common words in tokens\n  findCommonWords: (tokens) => {\n    // This function specifically finds common Korean words and units\n    const wordFreq = {};\n    const wordRelations = [];\n    \n    // Find measurement units (g, kg, etc.)\n    const unitRegex = /(\\d+(?:\\.\\d+)?)\\s*([a-zA-Z]+)$/;\n    \n    // First pass: extract all units and words - ONLY at prefix or suffix positions\n    tokens.forEach(token => {\n      const cleanToken = token.replace('[Í¥ÑÌò∏] ', '');\n      \n      // Check for measurement units\n      const unitMatch = cleanToken.match(unitRegex);\n      if (unitMatch) {\n        const [_, value, unit] = unitMatch;\n        \n        if (!wordFreq[unit]) {\n          wordFreq[unit] = { count: 1, tokens: [token], isUnit: true };\n        } else if (!wordFreq[unit].tokens.includes(token)) {\n          wordFreq[unit].count++;\n          wordFreq[unit].tokens.push(token);\n          \n          // Record relationship\n          wordRelations.push({\n            word: unit,\n            token: token,\n            position: cleanToken.indexOf(unit),\n            isUnit: true\n          });\n        }\n      }\n      \n      // Look for Korean character sequences - expand max length to 4 and improve detection\n      const MAX_KOREAN_WORD_LENGTH = 4;\n      \n      // Check for known important Korean words specifically\n      const importantKoreanWords = ['ÏûêÏó∞', 'Îì±Í∏â', 'ÎÜçÏû•', 'ÌïúÏö∞', 'ÌïúÎèà', 'ÎèºÏßÄ', 'ÏÜåÍ≥†Í∏∞', 'ÎèºÏßÄÍ≥†Í∏∞'];\n      \n      for (const koreanWord of importantKoreanWords) {\n        // Check prefix position (start of string)\n        if (cleanToken.startsWith(koreanWord)) {\n          if (!wordFreq[koreanWord]) {\n            wordFreq[koreanWord] = { count: 1, tokens: [token], isUnit: false, direction: 'prefix' };\n          } else if (!wordFreq[koreanWord].tokens.includes(token)) {\n            wordFreq[koreanWord].count++;\n            wordFreq[koreanWord].tokens.push(token);\n            \n            // Record relationship\n            wordRelations.push({\n              word: koreanWord,\n              token: token,\n              position: 0,\n              isUnit: false,\n              direction: 'prefix'\n            });\n          }\n        }\n        \n        // Check suffix position (end of string)\n        if (cleanToken.endsWith(koreanWord)) {\n          if (!wordFreq[koreanWord]) {\n            wordFreq[koreanWord] = { count: 1, tokens: [token], isUnit: false, direction: 'suffix' };\n          } else if (!wordFreq[koreanWord].tokens.includes(token)) {\n            wordFreq[koreanWord].count++;\n            wordFreq[koreanWord].tokens.push(token);\n            \n            // Record relationship\n            wordRelations.push({\n              word: koreanWord,\n              token: token,\n              position: cleanToken.length - koreanWord.length,\n              isUnit: false,\n              direction: 'suffix'\n            });\n          }\n        }\n      }\n      \n      // General approach - look for any Korean words of various lengths\n      for (let len = 2; len <= MAX_KOREAN_WORD_LENGTH; len++) {\n        if (len <= cleanToken.length) {\n          // Prefix (start position)\n          const prefixWord = cleanToken.substring(0, len);\n          if (/^[\\uAC00-\\uD7A3]+$/.test(prefixWord)) {\n            if (!wordFreq[prefixWord]) {\n              wordFreq[prefixWord] = { count: 1, tokens: [token], isUnit: false, direction: 'prefix' };\n            } else if (!wordFreq[prefixWord].tokens.includes(token)) {\n              wordFreq[prefixWord].count++;\n              wordFreq[prefixWord].tokens.push(token);\n              \n              // Record relationship\n              wordRelations.push({\n                word: prefixWord,\n                token: token,\n                position: 0, // Always at start\n                isUnit: false,\n                direction: 'prefix'\n              });\n            }\n          }\n          \n          // Suffix (end position)\n          const suffixWord = cleanToken.substring(cleanToken.length - len);\n          if (/^[\\uAC00-\\uD7A3]+$/.test(suffixWord)) {\n            if (!wordFreq[suffixWord]) {\n              wordFreq[suffixWord] = { count: 1, tokens: [token], isUnit: false, direction: 'suffix' };\n            } else if (!wordFreq[suffixWord].tokens.includes(token)) {\n              wordFreq[suffixWord].count++;\n              wordFreq[suffixWord].tokens.push(token);\n              \n              // Record relationship\n              wordRelations.push({\n                word: suffixWord,\n                token: token,\n                position: cleanToken.length - len, // Position at end\n                isUnit: false,\n                direction: 'suffix'\n              });\n            }\n          }\n        }\n      }\n    });\n    \n    // Filter to only keep words that appear in multiple tokens\n    const commonWords = Object.entries(wordFreq)\n      .filter(([word, data]) => data.count >= 2)\n      .sort((a, b) => {\n        // Prioritize units\n        if (a[1].isUnit && !b[1].isUnit) return -1;\n        if (!a[1].isUnit && b[1].isUnit) return 1;\n        \n        // Prioritize important Korean words\n        const importantA = ['ÏûêÏó∞', 'Îì±Í∏â', 'ÎÜçÏû•', 'ÌïúÏö∞', 'ÌïúÎèà'].includes(a[0]);\n        const importantB = ['ÏûêÏó∞', 'Îì±Í∏â', 'ÎÜçÏû•', 'ÌïúÏö∞', 'ÌïúÎèà'].includes(b[0]);\n        if (importantA && !importantB) return -1;\n        if (!importantA && importantB) return 1;\n        \n        // Sort by frequency first\n        const countDiff = b[1].count - a[1].count;\n        if (countDiff !== 0) return countDiff;\n        \n        // Then by length (prefer longer words)\n        return b[0].length - a[0].length;\n      })\n      .map(([word, data]) => ({\n        word,\n        count: data.count,\n        tokens: data.tokens,\n        isUnit: data.isUnit,\n        direction: data.direction\n      }));\n    \n    // Group the relationships by common word\n    const wordGroups = [];\n    \n    commonWords.forEach(commonWord => {\n      const relatedTokens = wordRelations\n        .filter(rel => rel.word === commonWord.word)\n        .map(rel => ({\n          token: rel.token,\n          position: rel.position,\n          isUnit: rel.isUnit,\n          direction: rel.direction\n        }));\n      \n      wordGroups.push({\n        word: commonWord.word,\n        count: commonWord.count,\n        tokens: commonWord.tokens,\n        relations: relatedTokens,\n        isUnit: commonWord.isUnit,\n        direction: commonWord.direction\n      });\n    });\n    \n    return wordGroups;\n  },\n  \n  // Select optimal substrings for grouping\n  selectOptimalSubstrings: (substrings, tokens, compoundRel, maxGroups = 15) => {\n    // First, identify important Korean substrings\n    const koreanSubstrings = substrings.filter(substr => \n      substr.isKorean && substr.count >= 2);\n    \n    // Sort by coverage and importance\n    const sortedSubstrings = [...substrings]\n      .sort((a, b) => {\n        // Prioritize Korean patterns\n        if (a.isKorean && !b.isKorean) return -1;\n        if (!a.isKorean && b.isKorean) return 1;\n        \n        // Prioritize substrings that have compound relationships\n        const hasCompoundA = compoundRel.some(rel => \n          rel.parent.includes(a.substring) || rel.child.includes(a.substring));\n        const hasCompoundB = compoundRel.some(rel => \n          rel.parent.includes(b.substring) || rel.child.includes(b.substring));\n        \n        if (hasCompoundA && !hasCompoundB) return -1;\n        if (!hasCompoundA && hasCompoundB) return 1;\n        \n        // Score based on count and length\n        // Modified to give more weight to meaningful substrings (e.g., \"Îì±Í∏â\", \"ÏûêÏó∞\")\n        const scoreA = a.count * (a.isKorean ? Math.pow(a.substring.length, 1.5) : a.substring.length);\n        const scoreB = b.count * (b.isKorean ? Math.pow(b.substring.length, 1.5) : b.substring.length);\n        return scoreB - scoreA;\n      });\n    \n    const selectedSubstrings = [];\n    const coveredTokens = new Set();\n    \n    // First, include important Korean substrings\n    for (const substr of koreanSubstrings) {\n      if (substr.substring.length >= 1 && substr.count >= 2) {\n        // Check if this is a meaningful Korean term\n        if (/[Í∞Ä-Ìû£]{1,}/.test(substr.substring)) {\n          selectedSubstrings.push(substr);\n          \n          // Update covered tokens\n          substr.tokens.forEach(token => coveredTokens.add(token));\n          \n          // Limit Korean groups\n          if (selectedSubstrings.length >= Math.ceil(maxGroups * 0.6)) break;\n        }\n      }\n    }\n    \n    // Then add other important substrings\n    for (const substr of sortedSubstrings) {\n      // Skip if already selected\n      if (selectedSubstrings.some(s => s.substring === substr.substring)) {\n        continue;\n      }\n      \n      // Check if this covers new tokens\n      const newCoverage = substr.tokens.some(token => !coveredTokens.has(token));\n      \n      // Selection criteria - relaxed for Korean patterns\n      const isImportantSubstr = \n        (substr.isKorean && substr.count >= 2) || \n        (substr.substring.length >= 2 && substr.count >= 3);\n      \n      const isHighSupportSingleChar = \n        substr.substring.length === 1 && \n        substr.count >= Math.max(3, tokens.length * 0.15);\n      \n      if (newCoverage || isImportantSubstr || isHighSupportSingleChar) {\n        selectedSubstrings.push(substr);\n        \n        // Update covered tokens\n        substr.tokens.forEach(token => coveredTokens.add(token));\n      }\n      \n      // Limit groups\n      if (selectedSubstrings.length >= maxGroups) break;\n    }\n    \n    return selectedSubstrings;\n  },\n  \n  // Form compound word relationship groups\n  formCompoundGroups: (relationships) => {\n    // Group by parent token\n    const compoundGroups = {};\n    \n    relationships.forEach(rel => {\n      const parentToken = rel.parent;\n      if (!compoundGroups[parentToken]) {\n        compoundGroups[parentToken] = {\n          parent: parentToken,\n          children: [rel.child],\n          positions: [rel.position]\n        };\n      } else if (!compoundGroups[parentToken].children.includes(rel.child)) {\n        compoundGroups[parentToken].children.push(rel.child);\n        compoundGroups[parentToken].positions.push(rel.position);\n      }\n    });\n    \n    // Sort by number of children (descending)\n    return Object.values(compoundGroups)\n      .sort((a, b) => b.children.length - a.children.length)\n      .filter(group => group.children.length >= 2) // At least 2 children\n      .slice(0, 5); // Top 5 only\n  }\n};\n\n// Main component for classification results\nconst SeparationClassifier = ({ data, onReset }) => {\n  // Empty data handling\n  if (!data || !data.rows || data.rows.length === 0) {\n    return <div className=\"separation-empty\">No data to classify</div>;\n  }\n  \n  // Process and classify the data\n  const processData = () => {\n    const { bracketValues, normalValues } = textUtils.extractTokens(data.rows);\n    \n    // No results case\n    if (bracketValues.length === 0 && normalValues.length === 0) {\n      return {\n        headers: [\"Group\", \"Token\"],\n        rows: [[\"\", \"Î∂ÑÎ¶¨Îêú Í∞íÏù¥ ÏóÜÏäµÎãàÎã§\"]]\n      };\n    }\n    \n    // All tokens\n    const allMinTokens = [...bracketValues, ...normalValues];\n    \n    // Find common Korean words in tokens\n    const commonWordGroups = textUtils.findCommonWords(allMinTokens);\n    \n    // Analyze compound relationships\n    const compoundRelationships = textUtils.analyzeCompoundRelationships(allMinTokens);\n    \n    // Get directional substrings\n    const prefixSubstrings = textUtils.findCommonSubstrings(allMinTokens, 1, 2, 'prefix');\n    const suffixSubstrings = textUtils.findCommonSubstrings(allMinTokens, 1, 2, 'suffix');\n    \n    // Select optimal substrings\n    const optimalPrefixSubstrings = textUtils.selectOptimalSubstrings(\n      prefixSubstrings, allMinTokens, compoundRelationships, 8\n    );\n    const optimalSuffixSubstrings = textUtils.selectOptimalSubstrings(\n      suffixSubstrings, allMinTokens, compoundRelationships, 8\n    );\n    \n    // Build compound groups\n    const compoundGroups = textUtils.formCompoundGroups(compoundRelationships);\n    \n    // Build results data structure\n    const finalRows = [];\n    \n    // 1. Prefix groups\n    finalRows.push([\"üå≤ Ï†ëÎëêÏÇ¨ Í∏∞Ï§Ä Í∑∏Î£π (ÏïûÍ∏ÄÏûêÏàú)\", \"\"]);\n    \n    optimalPrefixSubstrings.forEach(group => {\n      finalRows.push([`üìå ÏïûÎ∂ÄÎ∂Ñ: ${group.substring} (${group.count})`, \"\"]);\n      \n      const groupTokens = group.tokens.sort((a, b) => {\n        const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n        const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n        \n        if (aIsBracket && !bIsBracket) return -1;\n        if (!aIsBracket && bIsBracket) return 1;\n        \n        return a.localeCompare(b);\n      });\n      \n      groupTokens.forEach(token => {\n        finalRows.push([\"‚îî‚îÄ\", token]);\n      });\n      \n      finalRows.push([\"\", \"\"]);\n    });\n    \n    // 2. Suffix groups\n    finalRows.push([\"üå≤ Ï†ëÎØ∏ÏÇ¨ Í∏∞Ï§Ä Í∑∏Î£π (Îí∑Í∏ÄÏûêÏàú)\", \"\"]);\n    \n    optimalSuffixSubstrings.forEach(group => {\n      finalRows.push([`üìå Îí∑Î∂ÄÎ∂Ñ: ${group.substring} (${group.count})`, \"\"]);\n      \n      const groupTokens = group.tokens.sort((a, b) => {\n        const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n        const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n        \n        if (aIsBracket && !bIsBracket) return -1;\n        if (!aIsBracket && bIsBracket) return 1;\n        \n        return textUtils.reverseString(a.replace('[Í¥ÑÌò∏] ', '')).localeCompare(\n          textUtils.reverseString(b.replace('[Í¥ÑÌò∏] ', ''))\n        );\n      });\n      \n      groupTokens.forEach(token => {\n        finalRows.push([\"‚îî‚îÄ\", token]);\n      });\n      \n      finalRows.push([\"\", \"\"]);\n    });\n    \n    // 3. Common Korean word groups\n    if (commonWordGroups.length > 0) {\n      finalRows.push([\"üå≤ Îã®Ïñ¥ Í∏∞Ï§Ä Í∑∏Î£π\", \"\"]);\n      \n      commonWordGroups.forEach(group => {\n        // Skip if too few tokens or already covered well by other groups\n        if (group.count < 2 || group.word.length < 1) return;\n        \n        finalRows.push([\n          `üìå Îã®Ïñ¥: ${group.word} (${group.count})`, \n          \"\"\n        ]);\n        \n        // Sort tokens\n        const sortedTokens = [...group.tokens].sort((a, b) => {\n          const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n          const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n          \n          if (aIsBracket && !bIsBracket) return -1;\n          if (!aIsBracket && bIsBracket) return 1;\n          \n          return a.localeCompare(b);\n        });\n        \n        sortedTokens.forEach(token => {\n          // Find position\n          const relation = group.relations.find(r => r.token === token);\n          const position = relation ? relation.position : -1;\n          const cleanToken = token.replace('[Í¥ÑÌò∏] ', '');\n          \n          let positionMarker = '';\n          if (position === 0) {\n            positionMarker = '‚¨ÖÔ∏è Ï≤òÏùå';\n          } else if (position + group.word.length === cleanToken.length) {\n            positionMarker = '‚û°Ô∏è ÎÅù';\n          } else if (position > 0) {\n            positionMarker = '‚¨áÔ∏è Ï§ëÍ∞Ñ';\n          }\n          \n          finalRows.push([`‚îî‚îÄ ${positionMarker.length > 0 ? `[${positionMarker}]` : ''}`, token]);\n        });\n        \n        finalRows.push([\"\", \"\"]);\n      });\n    }\n    \n    // 4. Compound relationships\n    if (compoundGroups.length > 0) {\n      finalRows.push([\"üå≤ Î≥µÌï©Ïñ¥ Í¥ÄÍ≥Ñ Í∑∏Î£π\", \"\"]);\n      \n      compoundGroups.forEach(group => {\n        finalRows.push([\n          `üìå Î≥µÌï©Ïñ¥: ${group.parent.replace('[Í¥ÑÌò∏] ', '')} (${group.children.length})`, \n          group.parent\n        ]);\n        \n        group.children.forEach((child, idx) => {\n          const position = group.positions[idx];\n          const parentClean = group.parent.replace('[Í¥ÑÌò∏] ', '');\n          const childClean = child.replace('[Í¥ÑÌò∏] ', '');\n          \n          let positionMarker = '';\n          if (position === 0) {\n            positionMarker = '‚¨ÖÔ∏è ÏãúÏûë Î∂ÄÎ∂Ñ';\n          } else if (position + childClean.length === parentClean.length) {\n            positionMarker = '‚û°Ô∏è ÎÅù Î∂ÄÎ∂Ñ';\n          } else {\n            positionMarker = '‚¨áÔ∏è Ï§ëÍ∞Ñ Î∂ÄÎ∂Ñ';\n          }\n          \n          finalRows.push([`‚îî‚îÄ [${positionMarker}]`, child]);\n        });\n        \n        finalRows.push([\"\", \"\"]);\n      });\n    }\n    \n    // 5. Ungrouped tokens\n    const allGroupedTokens = new Set();\n    \n    optimalPrefixSubstrings.forEach(group => \n      group.tokens.forEach(token => allGroupedTokens.add(token)));\n    \n    optimalSuffixSubstrings.forEach(group => \n      group.tokens.forEach(token => allGroupedTokens.add(token)));\n\n    commonWordGroups.forEach(group => \n      group.tokens.forEach(token => allGroupedTokens.add(token)));\n    \n    compoundGroups.forEach(group => {\n      allGroupedTokens.add(group.parent);\n      group.children.forEach(child => allGroupedTokens.add(child));\n    });\n    \n    const ungroupedTokens = allMinTokens\n      .filter(token => !allGroupedTokens.has(token))\n      .sort();\n    \n    if (ungroupedTokens.length > 0) {\n      finalRows.push([\"üå≤ ÎØ∏Î∂ÑÎ•ò ÌÜ†ÌÅ∞\", \"\"]);\n      ungroupedTokens.forEach(token => {\n        finalRows.push([\"‚îî‚îÄ\", token]);\n      });\n    }\n    \n    return {\n      prefixGroups: optimalPrefixSubstrings.map(group => ({\n        substring: group.substring,\n        count: group.count,\n        tokens: group.tokens.sort((a, b) => {\n          const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n          const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n          \n          if (aIsBracket && !bIsBracket) return -1;\n          if (!aIsBracket && bIsBracket) return 1;\n          \n          return a.localeCompare(b);\n        })\n      })),\n      suffixGroups: optimalSuffixSubstrings.map(group => ({\n        substring: group.substring,\n        count: group.count,\n        tokens: group.tokens.sort((a, b) => {\n          const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n          const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n          \n          if (aIsBracket && !bIsBracket) return -1;\n          if (!aIsBracket && bIsBracket) return 1;\n          \n          return textUtils.reverseString(a.replace('[Í¥ÑÌò∏] ', '')).localeCompare(\n            textUtils.reverseString(b.replace('[Í¥ÑÌò∏] ', ''))\n          );\n        })\n      })),\n      wordGroups: commonWordGroups\n        .filter(group => group.count >= 2 && group.word.length >= 1)\n        .map(group => ({\n          word: group.word,\n          count: group.count,\n          tokens: group.tokens.sort((a, b) => {\n            const aIsBracket = a.startsWith('[Í¥ÑÌò∏]');\n            const bIsBracket = b.startsWith('[Í¥ÑÌò∏]');\n            \n            if (aIsBracket && !bIsBracket) return -1;\n            if (!aIsBracket && bIsBracket) return 1;\n            \n            return a.localeCompare(b);\n          }),\n          relations: group.relations\n        })),\n      compoundGroups,\n      ungroupedTokens\n    };\n  };\n  \n  // Processed classification data\n  const classificationData = processData();\n  \n  // Render tree node with children\n  const renderTreeNode = (label, children, nodeType, nodeSubtype = '') => (\n    <div className={`tree-node ${nodeType} ${nodeSubtype}`}>\n      <div className=\"tree-node-label\">{label}</div>\n      {children && children.length > 0 && (\n        <div className=\"tree-node-children\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n\n  // Render token node (leaf)\n  const renderTokenNode = (token) => {\n    const isBracketContent = String(token).startsWith('[Í¥ÑÌò∏]');\n    let displayContent = token;\n    \n    if (isBracketContent) {\n      displayContent = (\n        <>\n          <span className=\"bracket-indicator\">‚äÇ‚äÉ</span>\n          {String(token).replace('[Í¥ÑÌò∏] ', '')}\n        </>\n      );\n    }\n    \n    return (\n      <div className={`token-node ${isBracketContent ? 'bracket-content' : ''}`}>\n        {displayContent}\n      </div>\n    );\n  };\n\n  // Render position indicator for tokens\n  const renderPositionIndicator = (position, direction) => {\n    if (direction === 'prefix' || position === 0) {\n      return <span className=\"position-indicator position-start\">‚¨ÖÔ∏è Ï≤òÏùå</span>;\n    } else if (direction === 'suffix') {\n      return <span className=\"position-indicator position-end\">‚û°Ô∏è ÎÅù</span>;\n    }\n    return null;\n  };\n  \n  // Render the classification results with dendrogram-style visualization\n  return (\n    <div className=\"separation-classifier\">\n      <div className=\"classifier-header\">\n        <h3>Î∂ÑÎ¶¨Î∂ÑÎ•ò Í≤∞Í≥º</h3>\n        <button className=\"reset-button\" onClick={onReset} title=\"ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞Î°ú Î≥µÏõê\">\n          <span>üîÑ ÏõêÎ≥∏ÏúºÎ°ú Î≥µÏõê</span>\n        </button>\n      </div>\n      \n      <div className=\"dendrogram-container\">\n        {/* Word Groups - NEW SECTION - Moved to top for importance */}\n        {classificationData.wordGroups && classificationData.wordGroups.length > 0 && (\n          <div className=\"tree-category\">\n            <div className=\"tree-category-header\">\n              <h4>üå≤ Îã®Ïñ¥ Í∏∞Ï§Ä Í∑∏Î£π</h4>\n            </div>\n            <div className=\"tree-content\">\n              {classificationData.wordGroups.map((group, idx) => {\n                // Skip groups where the word is not at start or end of all tokens\n                if (!group.isUnit && !group.direction) {\n                  return null;\n                }\n\n                return (\n                  <div key={`word-${idx}`} className=\"group-tree\">\n                    {renderTreeNode(\n                      <><span className=\"group-marker\">üìå</span> {group.isUnit ? `Îã®ÏúÑ: ${group.word}` : \n                        (group.direction === 'prefix' ? `ÏïûÎ∂ÄÎ∂Ñ Îã®Ïñ¥: ${group.word}` : \n                         group.direction === 'suffix' ? `Îí∑Î∂ÄÎ∂Ñ Îã®Ïñ¥: ${group.word}` : `Îã®Ïñ¥: ${group.word}`)} \n                         <span className=\"count-badge\">({group.count})</span></>,\n                      group.tokens.map((token, tokenIdx) => {\n                        // Find position info\n                        const relation = group.relations.find(r => r.token === token);\n                        \n                        return (\n                          <div key={`word-${idx}-token-${tokenIdx}`} className=\"tree-branch with-position\">\n                            <div className=\"branch-line\"></div>\n                            <div className=\"branch-content\">\n                              {!group.isUnit && relation && renderPositionIndicator(relation.position, relation.direction)}\n                              {renderTokenNode(token)}\n                            </div>\n                          </div>\n                        );\n                      }),\n                      'group-node',\n                      group.isUnit ? 'unit-group' : \n                        (group.direction === 'prefix' ? 'prefix-word-group' : \n                         group.direction === 'suffix' ? 'suffix-word-group' : 'word-group')\n                    )}\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n        \n        {/* Prefix Groups */}\n        <div className=\"tree-category\">\n          <div className=\"tree-category-header\">\n            <h4>üå≤ Ï†ëÎëêÏÇ¨ Í∏∞Ï§Ä Í∑∏Î£π (ÏïûÍ∏ÄÏûêÏàú)</h4>\n          </div>\n          <div className=\"tree-content\">\n            {classificationData.prefixGroups.map((group, idx) => (\n              <div key={`prefix-${idx}`} className=\"group-tree\">\n                {renderTreeNode(\n                  <><span className=\"group-marker\">üìå</span> ÏïûÎ∂ÄÎ∂Ñ: {group.substring} <span className=\"count-badge\">({group.count})</span></>,\n                  group.tokens.map((token, tokenIdx) => (\n                    <div key={`prefix-${idx}-token-${tokenIdx}`} className=\"tree-branch\">\n                      <div className=\"branch-line\"></div>\n                      {renderTokenNode(token)}\n                    </div>\n                  )),\n                  'group-node',\n                  'prefix-group'\n                )}\n              </div>\n            ))}\n          </div>\n        </div>\n        \n        {/* Suffix Groups */}\n        <div className=\"tree-category\">\n          <div className=\"tree-category-header\">\n            <h4>üå≤ Ï†ëÎØ∏ÏÇ¨ Í∏∞Ï§Ä Í∑∏Î£π (Îí∑Í∏ÄÏûêÏàú)</h4>\n          </div>\n          <div className=\"tree-content\">\n            {classificationData.suffixGroups.map((group, idx) => (\n              <div key={`suffix-${idx}`} className=\"group-tree\">\n                {renderTreeNode(\n                  <><span className=\"group-marker\">üìå</span> Îí∑Î∂ÄÎ∂Ñ: {group.substring} <span className=\"count-badge\">({group.count})</span></>,\n                  group.tokens.map((token, tokenIdx) => (\n                    <div key={`suffix-${idx}-token-${tokenIdx}`} className=\"tree-branch\">\n                      <div className=\"branch-line\"></div>\n                      {renderTokenNode(token)}\n                    </div>\n                  )),\n                  'group-node',\n                  'suffix-group'\n                )}\n              </div>\n            ))}\n          </div>\n        </div>\n        \n        {/* Compound Groups */}\n        {classificationData.compoundGroups && classificationData.compoundGroups.length > 0 && (\n          <div className=\"tree-category\">\n            <div className=\"tree-category-header\">\n              <h4>üå≤ Î≥µÌï©Ïñ¥ Í¥ÄÍ≥Ñ Í∑∏Î£π</h4>\n            </div>\n            <div className=\"tree-content\">\n              {classificationData.compoundGroups.map((group, idx) => {\n                const parentClean = group.parent.replace('[Í¥ÑÌò∏] ', '');\n                \n                return (\n                  <div key={`compound-${idx}`} className=\"group-tree\">\n                    {renderTreeNode(\n                      <><span className=\"group-marker\">üìå</span> Î≥µÌï©Ïñ¥: {parentClean} <span className=\"count-badge\">({group.children.length})</span></>,\n                      group.children.map((child, childIdx) => {\n                        const position = group.positions[childIdx];\n                        const childClean = child.replace('[Í¥ÑÌò∏] ', '');\n                        \n                        return (\n                          <div key={`compound-${idx}-child-${childIdx}`} className=\"tree-branch with-position\">\n                            <div className=\"branch-line\"></div>\n                            <div className=\"branch-content\">\n                              {position === 0 ? (\n                                <span className=\"position-indicator position-start\">‚¨ÖÔ∏è Ï≤òÏùå</span>\n                              ) : position + childClean.length === parentClean.length ? (\n                                <span className=\"position-indicator position-end\">‚û°Ô∏è ÎÅù</span>\n                              ) : null}\n                              {renderTokenNode(child)}\n                            </div>\n                          </div>\n                        );\n                      }),\n                      'group-node',\n                      'compound-group'\n                    )}\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n        \n        {/* Ungrouped Tokens */}\n        {classificationData.ungroupedTokens && classificationData.ungroupedTokens.length > 0 && (\n          <div className=\"tree-category\">\n            <div className=\"tree-category-header\">\n              <h4>üå≤ ÎØ∏Î∂ÑÎ•ò ÌÜ†ÌÅ∞</h4>\n            </div>\n            <div className=\"tree-content ungrouped-content\">\n              {classificationData.ungroupedTokens.map((token, idx) => (\n                <div key={`ungrouped-${idx}`} className=\"ungrouped-token\">\n                  {renderTokenNode(token)}\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default SeparationClassifier; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/**\n * Process text to extract bracket content\n */\nexport const processBracketSeparation = input => {\n  if (typeof input === 'string') {\n    const bracketRegex = /\\[(.*?)\\]|\\((.*?)\\)|\\{(.*?)\\}/g;\n    const matches = [];\n    const matchDetails = [];\n    let match;\n    while ((match = bracketRegex.exec(input)) !== null) {\n      const value = match[1] || match[2] || match[3];\n      if (value) {\n        matches.push(value);\n\n        // Store metadata about the match\n        matchDetails.push({\n          value,\n          bracketType: match[1] ? 'square' : match[2] ? 'round' : 'curly',\n          fullMatch: match[0],\n          // The full match including brackets\n          startIndex: match.index,\n          endIndex: match.index + match[0].length\n        });\n      }\n    }\n\n    // Clean the original string by removing all brackets\n    const cleanedOriginal = input.replace(/\\[.*?\\]|\\(.*?\\)|\\{.*?\\}/g, '').replace(/\\s+/g, ' ').trim();\n    return {\n      original: input,\n      cleaned: cleanedOriginal,\n      separated: matches,\n      matchDetails: matchDetails,\n      type: 'bracket-separation'\n    };\n  } else if (Array.isArray(input)) {\n    return input.map(item => processBracketSeparation(item));\n  } else if (typeof input === 'object' && input !== null) {\n    const result = {};\n    for (const key in input) {\n      result[key] = processBracketSeparation(input[key]);\n    }\n    return result;\n  }\n  return input;\n};\n\n/**\n * Process text to separate by delimiters\n */\nexport const processDelimiterSeparation = (input, delimiters) => {\n  if (typeof input === 'string') {\n    // Create a regex pattern from the delimiters\n    const delimiterPattern = delimiters.map(d =>\n    // Escape special regex characters in delimiters\n    d.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).join('|');\n    const regex = new RegExp(`(${delimiterPattern})`, 'g');\n\n    // Split the string by the delimiters and filter out empty strings\n    const parts = input.split(regex).filter(part => part.trim() !== '' && !delimiters.includes(part.trim()));\n    return {\n      original: input,\n      separated: parts.map(part => ({\n        value: part,\n        source: 'delimiter'\n      })),\n      type: 'delimiter-separation'\n    };\n  } else if (input && input.type === 'bracket-separation') {\n    // Process the original text with delimiter separation\n    const delimiterPattern = delimiters.map(d => d.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).join('|');\n    const regex = new RegExp(`(${delimiterPattern})`, 'g');\n\n    // Use the cleaned text (without brackets) if available\n    const textToProcess = input.cleaned || input.original;\n\n    // Split the original text and filter\n    const partsFromOriginal = textToProcess.split(regex).filter(part => part.trim() !== '' && !delimiters.includes(part.trim()));\n\n    // Process each bracket value\n    const partsFromBrackets = [];\n    if (input.separated) {\n      input.separated.forEach((val, index) => {\n        const parts = val.split(regex).filter(part => part.trim() !== '' && !delimiters.includes(part.trim()));\n\n        // Add each part with source metadata\n        parts.forEach(part => {\n          partsFromBrackets.push({\n            value: part,\n            source: 'bracket',\n            bracketInfo: input.matchDetails ? input.matchDetails[index] : null\n          });\n        });\n      });\n    }\n\n    // Add clean text parts with source metadata\n    const cleanTextParts = partsFromOriginal.map(part => ({\n      value: part,\n      source: 'clean-text'\n    }));\n\n    // Combine all parts (without deduplication to preserve metadata)\n    const allParts = [...cleanTextParts, ...partsFromBrackets];\n    return {\n      original: input.original,\n      cleaned: input.cleaned,\n      separated: allParts,\n      type: 'delimiter-separation',\n      previous: {\n        type: input.type,\n        separated: input.separated,\n        matchDetails: input.matchDetails\n      }\n    };\n  } else if (Array.isArray(input)) {\n    return input.map(item => processDelimiterSeparation(item, delimiters));\n  } else if (typeof input === 'object' && input !== null) {\n    const result = {};\n    for (const key in input) {\n      result[key] = processDelimiterSeparation(input[key], delimiters);\n    }\n    return result;\n  }\n  return input;\n};\n\n/**\n * Flatten data structure to generate simple rows for display\n */\nexport const flattenData = (data, path = '', rows = []) => {\n  if (!data) return rows;\n  if (data.type === 'bracket-separation' || data.type === 'delimiter-separation') {\n    rows.push({\n      path,\n      original: data.original,\n      separated: data.separated,\n      type: data.type,\n      previous: data.previous\n    });\n  } else if (Array.isArray(data)) {\n    data.forEach((item, index) => {\n      const itemPath = path ? `${path}[${index}]` : `[${index}]`;\n      flattenData(item, itemPath, rows);\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    Object.entries(data).forEach(([key, value]) => {\n      const keyPath = path ? `${path}.${key}` : key;\n      flattenData(value, keyPath, rows);\n    });\n  } else if (path) {\n    // Simple value\n    rows.push({\n      path,\n      original: data,\n      separated: []\n    });\n  }\n  return rows;\n};","map":{"version":3,"names":["processBracketSeparation","input","bracketRegex","matches","matchDetails","match","exec","value","push","bracketType","fullMatch","startIndex","index","endIndex","length","cleanedOriginal","replace","trim","original","cleaned","separated","type","Array","isArray","map","item","result","key","processDelimiterSeparation","delimiters","delimiterPattern","d","join","regex","RegExp","parts","split","filter","part","includes","source","textToProcess","partsFromOriginal","partsFromBrackets","forEach","val","bracketInfo","cleanTextParts","allParts","previous","flattenData","data","path","rows","itemPath","Object","entries","keyPath"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/dataProcessors.js"],"sourcesContent":["/**\n * Process text to extract bracket content\n */\nexport const processBracketSeparation = (input) => {\n  if (typeof input === 'string') {\n    const bracketRegex = /\\[(.*?)\\]|\\((.*?)\\)|\\{(.*?)\\}/g;\n    const matches = [];\n    const matchDetails = [];\n    let match;\n    \n    while ((match = bracketRegex.exec(input)) !== null) {\n      const value = match[1] || match[2] || match[3];\n      if (value) {\n        matches.push(value);\n        \n        // Store metadata about the match\n        matchDetails.push({\n          value,\n          bracketType: match[1] ? 'square' : match[2] ? 'round' : 'curly',\n          fullMatch: match[0], // The full match including brackets\n          startIndex: match.index,\n          endIndex: match.index + match[0].length\n        });\n      }\n    }\n    \n    // Clean the original string by removing all brackets\n    const cleanedOriginal = input.replace(/\\[.*?\\]|\\(.*?\\)|\\{.*?\\}/g, '').replace(/\\s+/g, ' ').trim();\n    \n    return {\n      original: input,\n      cleaned: cleanedOriginal,\n      separated: matches,\n      matchDetails: matchDetails,\n      type: 'bracket-separation'\n    };\n  } else if (Array.isArray(input)) {\n    return input.map(item => processBracketSeparation(item));\n  } else if (typeof input === 'object' && input !== null) {\n    const result = {};\n    for (const key in input) {\n      result[key] = processBracketSeparation(input[key]);\n    }\n    return result;\n  }\n  \n  return input;\n};\n\n/**\n * Process text to separate by delimiters\n */\nexport const processDelimiterSeparation = (input, delimiters) => {\n  if (typeof input === 'string') {\n    // Create a regex pattern from the delimiters\n    const delimiterPattern = delimiters.map(d => \n      // Escape special regex characters in delimiters\n      d.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    ).join('|');\n    \n    const regex = new RegExp(`(${delimiterPattern})`, 'g');\n    \n    // Split the string by the delimiters and filter out empty strings\n    const parts = input.split(regex).filter(part => \n      part.trim() !== '' && !delimiters.includes(part.trim())\n    );\n    \n    return {\n      original: input,\n      separated: parts.map(part => ({\n        value: part,\n        source: 'delimiter'\n      })),\n      type: 'delimiter-separation'\n    };\n  } else if (input && input.type === 'bracket-separation') {\n    // Process the original text with delimiter separation\n    const delimiterPattern = delimiters.map(d => \n      d.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    ).join('|');\n    \n    const regex = new RegExp(`(${delimiterPattern})`, 'g');\n    \n    // Use the cleaned text (without brackets) if available\n    const textToProcess = input.cleaned || input.original;\n    \n    // Split the original text and filter\n    const partsFromOriginal = textToProcess.split(regex).filter(part => \n      part.trim() !== '' && !delimiters.includes(part.trim())\n    );\n    \n    // Process each bracket value\n    const partsFromBrackets = [];\n    if (input.separated) {\n      input.separated.forEach((val, index) => {\n        const parts = val.split(regex).filter(part => \n          part.trim() !== '' && !delimiters.includes(part.trim())\n        );\n        \n        // Add each part with source metadata\n        parts.forEach(part => {\n          partsFromBrackets.push({\n            value: part,\n            source: 'bracket',\n            bracketInfo: input.matchDetails ? input.matchDetails[index] : null\n          });\n        });\n      });\n    }\n    \n    // Add clean text parts with source metadata\n    const cleanTextParts = partsFromOriginal.map(part => ({\n      value: part,\n      source: 'clean-text'\n    }));\n    \n    // Combine all parts (without deduplication to preserve metadata)\n    const allParts = [...cleanTextParts, ...partsFromBrackets];\n    \n    return {\n      original: input.original,\n      cleaned: input.cleaned,\n      separated: allParts,\n      type: 'delimiter-separation',\n      previous: {\n        type: input.type,\n        separated: input.separated,\n        matchDetails: input.matchDetails\n      }\n    };\n  } else if (Array.isArray(input)) {\n    return input.map(item => processDelimiterSeparation(item, delimiters));\n  } else if (typeof input === 'object' && input !== null) {\n    const result = {};\n    for (const key in input) {\n      result[key] = processDelimiterSeparation(input[key], delimiters);\n    }\n    return result;\n  }\n  \n  return input;\n};\n\n/**\n * Flatten data structure to generate simple rows for display\n */\nexport const flattenData = (data, path = '', rows = []) => {\n  if (!data) return rows;\n  \n  if (data.type === 'bracket-separation' || data.type === 'delimiter-separation') {\n    rows.push({\n      path,\n      original: data.original,\n      separated: data.separated,\n      type: data.type,\n      previous: data.previous\n    });\n  } else if (Array.isArray(data)) {\n    data.forEach((item, index) => {\n      const itemPath = path ? `${path}[${index}]` : `[${index}]`;\n      flattenData(item, itemPath, rows);\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    Object.entries(data).forEach(([key, value]) => {\n      const keyPath = path ? `${path}.${key}` : key;\n      flattenData(value, keyPath, rows);\n    });\n  } else if (path) {\n    // Simple value\n    rows.push({\n      path,\n      original: data,\n      separated: []\n    });\n  }\n  \n  return rows;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
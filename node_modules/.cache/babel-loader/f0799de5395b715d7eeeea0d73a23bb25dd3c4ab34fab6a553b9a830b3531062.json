{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/Documents/github/bunribunryu/src/components/browse/SeparationClassifier.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport PipelineStep from './PipelineStep';\nimport DataDisplay from './DataDisplay';\nimport GroupPanel from './GroupPanel';\nimport { processBracketSeparation, processDelimiterSeparation, processSubstringSegmentation, processSegmentationGrouping, flattenData } from './dataProcessors';\nimport './SeparationClassifier.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SeparationClassifier = ({\n  data,\n  onReset\n}) => {\n  _s();\n  var _pipeline$find, _pipeline$find2;\n  const [processedData, setProcessedData] = useState(null);\n  const [segmentationData, setSegmentationData] = useState(null);\n  const [groupingData, setGroupingData] = useState(null);\n  const [previousStepData, setPreviousStepData] = useState(null); // Store data from previous steps\n  const [pipeline, setPipeline] = useState([{\n    id: 'bracket-separation',\n    name: '괄호값 분리',\n    active: true\n  }, {\n    id: 'delimiter-separation',\n    name: '구분자 분리',\n    active: true,\n    config: {\n      delimiters: [{\n        value: ',',\n        enabled: true,\n        order: 1\n      }, {\n        value: ' ',\n        enabled: true,\n        order: 2\n      }]\n    }\n  }, {\n    id: 'substring-segmentation',\n    name: '상호부분문자열 분절',\n    active: true,\n    config: {\n      minSubstringLength: 2,\n      minOccurrence: 2\n    }\n  }, {\n    id: 'segmentation-grouping',\n    name: '분절값 그룹핑',\n    active: true,\n    config: {\n      groups: [],\n      replaceNumbers: false\n    }\n  }]);\n  const [selectedStep, setSelectedStep] = useState('delimiter-separation');\n\n  // Check if segmentation grouping is active\n  const isGroupingActive = ((_pipeline$find = pipeline.find(step => step.id === 'segmentation-grouping')) === null || _pipeline$find === void 0 ? void 0 : _pipeline$find.active) || false;\n\n  // Check if substring segmentation is active\n  const isSubstringSegmentationActive = ((_pipeline$find2 = pipeline.find(step => step.id === 'substring-segmentation')) === null || _pipeline$find2 === void 0 ? void 0 : _pipeline$find2.active) || false;\n\n  // Process data through pipeline steps\n  useEffect(() => {\n    if (data) {\n      // Clean up duplicated data before processing\n      let cleanedData = {\n        ...data\n      };\n\n      // Check if data is already a processed result with duplicate content\n      const isDuplicated = input => {\n        if (typeof input === 'string') {\n          const halfLength = Math.floor(input.length / 2);\n          for (let i = 1; i <= halfLength; i++) {\n            if (input.substring(0, i) === input.substring(i, i * 2)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n\n      // Clean up data if it's duplicated\n      const cleanData = input => {\n        if (typeof input === 'string' && isDuplicated(input)) {\n          // Try to find a reasonable split point\n          const halfLength = Math.floor(input.length / 2);\n          return input.substring(0, halfLength);\n        } else if (Array.isArray(input)) {\n          return input.map(cleanData);\n        } else if (typeof input === 'object' && input !== null) {\n          const result = {};\n          for (const key in input) {\n            result[key] = cleanData(input[key]);\n          }\n          return result;\n        }\n        return input;\n      };\n\n      // Only clean if it appears to be duplicated\n      if (Object.values(cleanedData).some(val => typeof val === 'string' && isDuplicated(val))) {\n        cleanedData = cleanData(cleanedData);\n      }\n\n      // Process data through pipeline steps\n      let result = {\n        ...cleanedData\n      };\n\n      // Process bracket and delimiter steps\n      pipeline.forEach(step => {\n        if (step.active) {\n          if (step.id === 'bracket-separation') {\n            result = processBracketSeparation(result);\n          } else if (step.id === 'delimiter-separation') {\n            result = processDelimiterSeparation(result, step.config.delimiters);\n          }\n        }\n      });\n\n      // Store data after bracket and delimiter processing\n      setPreviousStepData(result);\n\n      // Process substring segmentation separately if active\n      const segmentationStep = pipeline.find(step => step.id === 'substring-segmentation');\n      if (segmentationStep && segmentationStep.active) {\n        const segmentResult = processSubstringSegmentation(result, segmentationStep.config);\n        setSegmentationData(segmentResult);\n\n        // Process segmentation grouping if active\n        const groupingStep = pipeline.find(step => step.id === 'segmentation-grouping');\n        if (groupingStep && groupingStep.active) {\n          // Extract substring segments\n          const extractSubstringSegments = data => {\n            const segments = new Set();\n\n            // Function to extract segments from the processed data\n            const extractSegments = item => {\n              if (!item) return;\n              if (item.processed && typeof item.processed === 'object') {\n                extractSegments(item.processed);\n              } else if (Array.isArray(item)) {\n                item.forEach(subItem => extractSegments(subItem));\n              } else if (item && typeof item === 'object') {\n                // For segmentation data with segments\n                if (item.segments && Array.isArray(item.segments)) {\n                  item.segments.forEach(segment => {\n                    if (segment && segment.text) {\n                      segments.add(segment.text);\n                    }\n                  });\n                }\n\n                // Process separated items for nested segmentation\n                if (item.separated && Array.isArray(item.separated)) {\n                  item.separated.forEach(sepItem => {\n                    if (sepItem && sepItem.segments) {\n                      sepItem.segments.forEach(segment => {\n                        if (segment && segment.text) {\n                          segments.add(segment.text);\n                        }\n                      });\n                    }\n                  });\n                }\n\n                // Process other object properties\n                Object.values(item).forEach(val => {\n                  if (typeof val === 'object') {\n                    extractSegments(val);\n                  }\n                });\n              }\n            };\n\n            // Extract segments from candidateSubstrings\n            if (data.candidateSubstrings && Array.isArray(data.candidateSubstrings)) {\n              data.candidateSubstrings.forEach(item => {\n                if (item && item.substring) {\n                  segments.add(item.substring);\n                }\n              });\n            }\n\n            // Extract segments from processed data\n            extractSegments(data.processed);\n            return Array.from(segments);\n          };\n\n          // Extract segment values from the segmentation result\n          const segmentValues = extractSubstringSegments(segmentResult);\n\n          // Create grouping data with the correct segment values\n          const groupingResult = {\n            uniqueValues: segmentValues,\n            groups: groupingStep.config.groups || [],\n            replaceNumbers: groupingStep.config.replaceNumbers || false,\n            original: result.original || null,\n            previous: {\n              type: 'substring-segmentation',\n              segmentationData: segmentResult\n            }\n          };\n          setGroupingData(groupingResult);\n        } else {\n          setGroupingData(null);\n        }\n      } else {\n        setSegmentationData(null);\n\n        // If substring segmentation is not active, but grouping is,\n        // create grouping data from previous step data\n        const groupingStep = pipeline.find(step => step.id === 'segmentation-grouping');\n        if (groupingStep && groupingStep.active && result) {\n          // Extract unique values from the previous step\n          const extractValues = data => {\n            const values = new Set();\n            if (typeof data === 'string') {\n              values.add(data);\n            } else if (Array.isArray(data)) {\n              data.forEach(item => {\n                const itemValues = extractValues(item);\n                itemValues.forEach(val => values.add(val));\n              });\n            } else if (data && typeof data === 'object') {\n              if (data.separated && Array.isArray(data.separated)) {\n                // For delimiter or bracket separation results\n                data.separated.forEach(item => {\n                  if (typeof item === 'string') {\n                    values.add(item);\n                  } else if (item && typeof item === 'object' && item.value) {\n                    values.add(item.value);\n                  }\n                });\n              } else {\n                // For other object types, recursively extract values\n                Object.values(data).forEach(val => {\n                  const valValues = extractValues(val);\n                  valValues.forEach(v => values.add(v));\n                });\n              }\n            }\n            return values;\n          };\n          const uniqueValues = Array.from(extractValues(result));\n\n          // Create grouping data structure similar to what processSegmentationGrouping would create\n          const simpleGroupingData = {\n            uniqueValues,\n            groups: groupingStep.config.groups || [],\n            replaceNumbers: groupingStep.config.replaceNumbers || false,\n            original: result.original || null,\n            previous: {\n              type: 'previous-steps',\n              data: result\n            }\n          };\n          setGroupingData(simpleGroupingData);\n        } else {\n          setGroupingData(null);\n        }\n      }\n      setProcessedData(result);\n    } else {\n      setProcessedData(null);\n      setSegmentationData(null);\n      setGroupingData(null);\n      setPreviousStepData(null);\n    }\n  }, [data, pipeline]);\n  const toggleStepActive = stepId => {\n    setPipeline(pipeline.map(step => step.id === stepId ? {\n      ...step,\n      active: !step.active\n    } : step));\n  };\n  const selectStep = stepId => {\n    setSelectedStep(stepId);\n  };\n\n  // Update delimiter configuration\n  const updateDelimiters = delimitersInput => {\n    setPipeline(pipeline.map(step => {\n      if (step.id === 'delimiter-separation') {\n        // If input is a string, convert to delimiter objects\n        if (typeof delimitersInput === 'string') {\n          const delimiters = delimitersInput.split('').map((char, idx) => ({\n            value: char,\n            enabled: true,\n            order: idx + 1\n          }));\n          return {\n            ...step,\n            config: {\n              ...step.config,\n              delimiters\n            }\n          };\n        }\n\n        // Input is already an array of delimiter objects\n        return {\n          ...step,\n          config: {\n            ...step.config,\n            delimiters: delimitersInput\n          }\n        };\n      }\n      return step;\n    }));\n  };\n\n  // Update substring segmentation configuration\n  const updateSegmentationConfig = configUpdate => {\n    setPipeline(pipeline.map(step => {\n      if (step.id === 'substring-segmentation') {\n        return {\n          ...step,\n          config: {\n            ...step.config,\n            ...configUpdate\n          }\n        };\n      }\n      return step;\n    }));\n  };\n\n  // Update segmentation grouping configuration\n  const updateGroupingConfig = configUpdate => {\n    setPipeline(pipeline.map(step => {\n      if (step.id === 'segmentation-grouping') {\n        return {\n          ...step,\n          config: {\n            ...step.config,\n            ...configUpdate\n          }\n        };\n      }\n      return step;\n    }));\n  };\n\n  // Toggle number replacement feature\n  const toggleNumberReplacement = () => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      updateGroupingConfig({\n        replaceNumbers: !groupStep.config.replaceNumbers\n      });\n    }\n  };\n\n  // Add a new empty group to the grouping step\n  const addEmptyGroup = () => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      const newGroup = {\n        id: `group-${Date.now()}`,\n        name: `Group ${groupStep.config.groups.length + 1}`,\n        items: []\n      };\n      updateGroupingConfig({\n        groups: [...groupStep.config.groups, newGroup]\n      });\n    }\n  };\n\n  // Update a group's name\n  const updateGroupName = (groupId, newName) => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      const updatedGroups = groupStep.config.groups.map(group => group.id === groupId ? {\n        ...group,\n        name: newName\n      } : group);\n      updateGroupingConfig({\n        groups: updatedGroups\n      });\n    }\n  };\n\n  // Add a value to a specific group\n  const addValueToGroup = (groupId, value) => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      const updatedGroups = groupStep.config.groups.map(group => {\n        if (group.id === groupId) {\n          // Only add if not already in the group\n          if (!group.items.includes(value)) {\n            return {\n              ...group,\n              items: [...group.items, value]\n            };\n          }\n        }\n        return group;\n      });\n      updateGroupingConfig({\n        groups: updatedGroups\n      });\n    }\n  };\n\n  // Remove a value from a specific group\n  const removeValueFromGroup = (groupId, value) => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      const updatedGroups = groupStep.config.groups.map(group => {\n        if (group.id === groupId) {\n          return {\n            ...group,\n            items: group.items.filter(item => item !== value)\n          };\n        }\n        return group;\n      });\n      updateGroupingConfig({\n        groups: updatedGroups\n      });\n    }\n  };\n\n  // Prepare pipeline steps with callbacks\n  const preparedPipeline = pipeline.map(step => {\n    if (step.id === 'delimiter-separation') {\n      return {\n        ...step,\n        onUpdateDelimiters: updateDelimiters\n      };\n    } else if (step.id === 'substring-segmentation') {\n      return {\n        ...step,\n        onUpdateConfig: updateSegmentationConfig\n      };\n    } else if (step.id === 'segmentation-grouping') {\n      return {\n        ...step,\n        onUpdateConfig: updateGroupingConfig,\n        onAddGroup: addEmptyGroup,\n        onUpdateGroupName: updateGroupName,\n        onToggleNumberReplacement: toggleNumberReplacement,\n        onAddValueToGroup: addValueToGroup,\n        onRemoveValueFromGroup: removeValueFromGroup\n      };\n    }\n    return step;\n  });\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"separation-classifier\",\n    style: {\n      height: '100%',\n      overflow: 'hidden'\n    },\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"classifier-layout\",\n      style: {\n        height: '100%',\n        display: 'flex'\n      },\n      children: [!isGroupingActive && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"data-view\",\n        style: {\n          flex: 1,\n          overflow: 'hidden',\n          display: 'flex',\n          flexDirection: 'column'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"\\uCC98\\uB9AC\\uB41C \\uB370\\uC774\\uD130 (\\uD68C\\uC0C9: \\uBBF8\\uCC98\\uB9AC \\uC601\\uC5ED)\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 449,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"data-content\",\n          style: {\n            flex: 1,\n            overflow: 'auto'\n          },\n          children: /*#__PURE__*/_jsxDEV(DataDisplay, {\n            processedData: processedData,\n            flattenData: flattenData,\n            segmentationData: segmentationData,\n            groupingData: null\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 451,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 450,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 448,\n        columnNumber: 11\n      }, this), groupingData && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"group-panel-container\",\n        style: {\n          width: isGroupingActive ? '70%' : '300px',\n          overflow: 'hidden',\n          display: 'flex',\n          flexDirection: 'column',\n          borderLeft: '1px solid #ccc',\n          borderRight: '1px solid #ccc'\n        },\n        children: /*#__PURE__*/_jsxDEV(GroupPanel, {\n          groupingData: {\n            ...groupingData,\n            onAddGroup: addEmptyGroup,\n            onUpdateGroupName: updateGroupName,\n            onAddValueToGroup: addValueToGroup,\n            onRemoveValueFromGroup: removeValueFromGroup\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 464,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 463,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"pipeline-panel\",\n        style: {\n          width: '300px',\n          overflow: 'hidden',\n          display: 'flex',\n          flexDirection: 'column'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"\\uD30C\\uC774\\uD504\\uB77C\\uC778\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 478,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"pipeline-list\",\n          style: {\n            flex: 1,\n            overflow: 'auto'\n          },\n          children: [preparedPipeline.map((step, index) => /*#__PURE__*/_jsxDEV(PipelineStep, {\n            step: step,\n            index: index,\n            isSelected: selectedStep === step.id,\n            onSelect: selectStep,\n            onToggle: toggleStepActive\n          }, step.id, false, {\n            fileName: _jsxFileName,\n            lineNumber: 481,\n            columnNumber: 15\n          }, this)), /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"add-step\",\n            children: \"+ \\uCC98\\uB9AC \\uB2E8\\uACC4 \\uCD94\\uAC00\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 491,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 479,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"pipeline-actions\",\n          children: /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"reset-button\",\n            onClick: onReset,\n            children: \"\\uCD08\\uAE30\\uD654\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 497,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 496,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 477,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 445,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 444,\n    columnNumber: 5\n  }, this);\n};\n_s(SeparationClassifier, \"oBXIJCft8f/KdepSRlKrPxAfiUE=\");\n_c = SeparationClassifier;\nexport default SeparationClassifier;\nvar _c;\n$RefreshReg$(_c, \"SeparationClassifier\");","map":{"version":3,"names":["React","useState","useEffect","PipelineStep","DataDisplay","GroupPanel","processBracketSeparation","processDelimiterSeparation","processSubstringSegmentation","processSegmentationGrouping","flattenData","jsxDEV","_jsxDEV","SeparationClassifier","data","onReset","_s","_pipeline$find","_pipeline$find2","processedData","setProcessedData","segmentationData","setSegmentationData","groupingData","setGroupingData","previousStepData","setPreviousStepData","pipeline","setPipeline","id","name","active","config","delimiters","value","enabled","order","minSubstringLength","minOccurrence","groups","replaceNumbers","selectedStep","setSelectedStep","isGroupingActive","find","step","isSubstringSegmentationActive","cleanedData","isDuplicated","input","halfLength","Math","floor","length","i","substring","cleanData","Array","isArray","map","result","key","Object","values","some","val","forEach","segmentationStep","segmentResult","groupingStep","extractSubstringSegments","segments","Set","extractSegments","item","processed","subItem","segment","text","add","separated","sepItem","candidateSubstrings","from","segmentValues","groupingResult","uniqueValues","original","previous","type","extractValues","itemValues","valValues","v","simpleGroupingData","toggleStepActive","stepId","selectStep","updateDelimiters","delimitersInput","split","char","idx","updateSegmentationConfig","configUpdate","updateGroupingConfig","toggleNumberReplacement","groupStep","addEmptyGroup","newGroup","Date","now","items","updateGroupName","groupId","newName","updatedGroups","group","addValueToGroup","includes","removeValueFromGroup","filter","preparedPipeline","onUpdateDelimiters","onUpdateConfig","onAddGroup","onUpdateGroupName","onToggleNumberReplacement","onAddValueToGroup","onRemoveValueFromGroup","className","style","height","overflow","children","display","flex","flexDirection","fileName","_jsxFileName","lineNumber","columnNumber","width","borderLeft","borderRight","index","isSelected","onSelect","onToggle","onClick","_c","$RefreshReg$"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/SeparationClassifier.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport PipelineStep from './PipelineStep';\nimport DataDisplay from './DataDisplay';\nimport GroupPanel from './GroupPanel';\nimport { processBracketSeparation, processDelimiterSeparation, processSubstringSegmentation, processSegmentationGrouping, flattenData } from './dataProcessors';\nimport './SeparationClassifier.css';\n\nconst SeparationClassifier = ({ data, onReset }) => {\n  const [processedData, setProcessedData] = useState(null);\n  const [segmentationData, setSegmentationData] = useState(null);\n  const [groupingData, setGroupingData] = useState(null);\n  const [previousStepData, setPreviousStepData] = useState(null); // Store data from previous steps\n  const [pipeline, setPipeline] = useState([\n    { id: 'bracket-separation', name: '괄호값 분리', active: true },\n    { \n      id: 'delimiter-separation', \n      name: '구분자 분리', \n      active: true,\n      config: {\n        delimiters: [\n          { value: ',', enabled: true, order: 1 },\n          { value: ' ', enabled: true, order: 2 }\n        ]\n      }\n    },\n    {\n      id: 'substring-segmentation',\n      name: '상호부분문자열 분절',\n      active: true,\n      config: {\n        minSubstringLength: 2,\n        minOccurrence: 2\n      }\n    },\n    {\n      id: 'segmentation-grouping',\n      name: '분절값 그룹핑',\n      active: true,\n      config: {\n        groups: [],\n        replaceNumbers: false\n      }\n    }\n  ]);\n  const [selectedStep, setSelectedStep] = useState('delimiter-separation');\n  \n  // Check if segmentation grouping is active\n  const isGroupingActive = pipeline.find(step => step.id === 'segmentation-grouping')?.active || false;\n  \n  // Check if substring segmentation is active\n  const isSubstringSegmentationActive = pipeline.find(step => step.id === 'substring-segmentation')?.active || false;\n  \n  // Process data through pipeline steps\n  useEffect(() => {\n    if (data) {\n      // Clean up duplicated data before processing\n      let cleanedData = { ...data };\n      \n      // Check if data is already a processed result with duplicate content\n      const isDuplicated = (input) => {\n        if (typeof input === 'string') {\n          const halfLength = Math.floor(input.length / 2);\n          for (let i = 1; i <= halfLength; i++) {\n            if (input.substring(0, i) === input.substring(i, i * 2)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n\n      // Clean up data if it's duplicated\n      const cleanData = (input) => {\n        if (typeof input === 'string' && isDuplicated(input)) {\n          // Try to find a reasonable split point\n          const halfLength = Math.floor(input.length / 2);\n          return input.substring(0, halfLength);\n        } else if (Array.isArray(input)) {\n          return input.map(cleanData);\n        } else if (typeof input === 'object' && input !== null) {\n          const result = {};\n          for (const key in input) {\n            result[key] = cleanData(input[key]);\n          }\n          return result;\n        }\n        return input;\n      };\n      \n      // Only clean if it appears to be duplicated\n      if (Object.values(cleanedData).some(val => \n        typeof val === 'string' && isDuplicated(val)\n      )) {\n        cleanedData = cleanData(cleanedData);\n      }\n      \n      // Process data through pipeline steps\n      let result = { ...cleanedData };\n      \n      // Process bracket and delimiter steps\n      pipeline.forEach(step => {\n        if (step.active) {\n          if (step.id === 'bracket-separation') {\n            result = processBracketSeparation(result);\n          } else if (step.id === 'delimiter-separation') {\n            result = processDelimiterSeparation(result, step.config.delimiters);\n          }\n        }\n      });\n      \n      // Store data after bracket and delimiter processing\n      setPreviousStepData(result);\n      \n      // Process substring segmentation separately if active\n      const segmentationStep = pipeline.find(step => step.id === 'substring-segmentation');\n      if (segmentationStep && segmentationStep.active) {\n        const segmentResult = processSubstringSegmentation(result, segmentationStep.config);\n        setSegmentationData(segmentResult);\n        \n        // Process segmentation grouping if active\n        const groupingStep = pipeline.find(step => step.id === 'segmentation-grouping');\n        if (groupingStep && groupingStep.active) {\n          // Extract substring segments\n          const extractSubstringSegments = (data) => {\n            const segments = new Set();\n            \n            // Function to extract segments from the processed data\n            const extractSegments = (item) => {\n              if (!item) return;\n              \n              if (item.processed && typeof item.processed === 'object') {\n                extractSegments(item.processed);\n              } else if (Array.isArray(item)) {\n                item.forEach(subItem => extractSegments(subItem));\n              } else if (item && typeof item === 'object') {\n                // For segmentation data with segments\n                if (item.segments && Array.isArray(item.segments)) {\n                  item.segments.forEach(segment => {\n                    if (segment && segment.text) {\n                      segments.add(segment.text);\n                    }\n                  });\n                }\n                \n                // Process separated items for nested segmentation\n                if (item.separated && Array.isArray(item.separated)) {\n                  item.separated.forEach(sepItem => {\n                    if (sepItem && sepItem.segments) {\n                      sepItem.segments.forEach(segment => {\n                        if (segment && segment.text) {\n                          segments.add(segment.text);\n                        }\n                      });\n                    }\n                  });\n                }\n                \n                // Process other object properties\n                Object.values(item).forEach(val => {\n                  if (typeof val === 'object') {\n                    extractSegments(val);\n                  }\n                });\n              }\n            };\n            \n            // Extract segments from candidateSubstrings\n            if (data.candidateSubstrings && Array.isArray(data.candidateSubstrings)) {\n              data.candidateSubstrings.forEach(item => {\n                if (item && item.substring) {\n                  segments.add(item.substring);\n                }\n              });\n            }\n            \n            // Extract segments from processed data\n            extractSegments(data.processed);\n            \n            return Array.from(segments);\n          };\n          \n          // Extract segment values from the segmentation result\n          const segmentValues = extractSubstringSegments(segmentResult);\n          \n          // Create grouping data with the correct segment values\n          const groupingResult = {\n            uniqueValues: segmentValues,\n            groups: groupingStep.config.groups || [],\n            replaceNumbers: groupingStep.config.replaceNumbers || false,\n            original: result.original || null,\n            previous: {\n              type: 'substring-segmentation',\n              segmentationData: segmentResult\n            }\n          };\n          \n          setGroupingData(groupingResult);\n        } else {\n          setGroupingData(null);\n        }\n      } else {\n        setSegmentationData(null);\n        \n        // If substring segmentation is not active, but grouping is,\n        // create grouping data from previous step data\n        const groupingStep = pipeline.find(step => step.id === 'segmentation-grouping');\n        if (groupingStep && groupingStep.active && result) {\n          // Extract unique values from the previous step\n          const extractValues = (data) => {\n            const values = new Set();\n            \n            if (typeof data === 'string') {\n              values.add(data);\n            } else if (Array.isArray(data)) {\n              data.forEach(item => {\n                const itemValues = extractValues(item);\n                itemValues.forEach(val => values.add(val));\n              });\n            } else if (data && typeof data === 'object') {\n              if (data.separated && Array.isArray(data.separated)) {\n                // For delimiter or bracket separation results\n                data.separated.forEach(item => {\n                  if (typeof item === 'string') {\n                    values.add(item);\n                  } else if (item && typeof item === 'object' && item.value) {\n                    values.add(item.value);\n                  }\n                });\n              } else {\n                // For other object types, recursively extract values\n                Object.values(data).forEach(val => {\n                  const valValues = extractValues(val);\n                  valValues.forEach(v => values.add(v));\n                });\n              }\n            }\n            \n            return values;\n          };\n          \n          const uniqueValues = Array.from(extractValues(result));\n          \n          // Create grouping data structure similar to what processSegmentationGrouping would create\n          const simpleGroupingData = {\n            uniqueValues,\n            groups: groupingStep.config.groups || [],\n            replaceNumbers: groupingStep.config.replaceNumbers || false,\n            original: result.original || null,\n            previous: {\n              type: 'previous-steps',\n              data: result\n            }\n          };\n          \n          setGroupingData(simpleGroupingData);\n        } else {\n          setGroupingData(null);\n        }\n      }\n      \n      setProcessedData(result);\n    } else {\n      setProcessedData(null);\n      setSegmentationData(null);\n      setGroupingData(null);\n      setPreviousStepData(null);\n    }\n  }, [data, pipeline]);\n\n  const toggleStepActive = (stepId) => {\n    setPipeline(pipeline.map(step => \n      step.id === stepId ? { ...step, active: !step.active } : step\n    ));\n  };\n\n  const selectStep = (stepId) => {\n    setSelectedStep(stepId);\n  };\n\n  // Update delimiter configuration\n  const updateDelimiters = (delimitersInput) => {\n    setPipeline(pipeline.map(step => {\n      if (step.id === 'delimiter-separation') {\n        // If input is a string, convert to delimiter objects\n        if (typeof delimitersInput === 'string') {\n          const delimiters = delimitersInput.split('').map((char, idx) => ({\n            value: char,\n            enabled: true,\n            order: idx + 1\n          }));\n          \n          return { \n            ...step, \n            config: { \n              ...step.config, \n              delimiters\n            } \n          };\n        }\n        \n        // Input is already an array of delimiter objects\n        return { \n          ...step, \n          config: { \n            ...step.config, \n            delimiters: delimitersInput\n          } \n        };\n      }\n      return step;\n    }));\n  };\n\n  // Update substring segmentation configuration\n  const updateSegmentationConfig = (configUpdate) => {\n    setPipeline(pipeline.map(step => {\n      if (step.id === 'substring-segmentation') {\n        return { \n          ...step, \n          config: { \n            ...step.config, \n            ...configUpdate \n          } \n        };\n      }\n      return step;\n    }));\n  };\n\n  // Update segmentation grouping configuration\n  const updateGroupingConfig = (configUpdate) => {\n    setPipeline(pipeline.map(step => {\n      if (step.id === 'segmentation-grouping') {\n        return { \n          ...step, \n          config: { \n            ...step.config, \n            ...configUpdate \n          } \n        };\n      }\n      return step;\n    }));\n  };\n\n  // Toggle number replacement feature\n  const toggleNumberReplacement = () => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      updateGroupingConfig({\n        replaceNumbers: !groupStep.config.replaceNumbers\n      });\n    }\n  };\n\n  // Add a new empty group to the grouping step\n  const addEmptyGroup = () => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      const newGroup = {\n        id: `group-${Date.now()}`,\n        name: `Group ${groupStep.config.groups.length + 1}`,\n        items: []\n      };\n      \n      updateGroupingConfig({\n        groups: [...groupStep.config.groups, newGroup]\n      });\n    }\n  };\n\n  // Update a group's name\n  const updateGroupName = (groupId, newName) => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      const updatedGroups = groupStep.config.groups.map(group => \n        group.id === groupId ? { ...group, name: newName } : group\n      );\n      \n      updateGroupingConfig({ groups: updatedGroups });\n    }\n  };\n\n  // Add a value to a specific group\n  const addValueToGroup = (groupId, value) => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      const updatedGroups = groupStep.config.groups.map(group => {\n        if (group.id === groupId) {\n          // Only add if not already in the group\n          if (!group.items.includes(value)) {\n            return { ...group, items: [...group.items, value] };\n          }\n        }\n        return group;\n      });\n      \n      updateGroupingConfig({ groups: updatedGroups });\n    }\n  };\n\n  // Remove a value from a specific group\n  const removeValueFromGroup = (groupId, value) => {\n    const groupStep = pipeline.find(step => step.id === 'segmentation-grouping');\n    if (groupStep) {\n      const updatedGroups = groupStep.config.groups.map(group => {\n        if (group.id === groupId) {\n          return { ...group, items: group.items.filter(item => item !== value) };\n        }\n        return group;\n      });\n      \n      updateGroupingConfig({ groups: updatedGroups });\n    }\n  };\n\n  // Prepare pipeline steps with callbacks\n  const preparedPipeline = pipeline.map(step => {\n    if (step.id === 'delimiter-separation') {\n      return {\n        ...step,\n        onUpdateDelimiters: updateDelimiters\n      };\n    } else if (step.id === 'substring-segmentation') {\n      return {\n        ...step,\n        onUpdateConfig: updateSegmentationConfig\n      };\n    } else if (step.id === 'segmentation-grouping') {\n      return {\n        ...step,\n        onUpdateConfig: updateGroupingConfig,\n        onAddGroup: addEmptyGroup,\n        onUpdateGroupName: updateGroupName,\n        onToggleNumberReplacement: toggleNumberReplacement,\n        onAddValueToGroup: addValueToGroup,\n        onRemoveValueFromGroup: removeValueFromGroup\n      };\n    }\n    return step;\n  });\n\n  return (\n    <div className=\"separation-classifier\" style={{ height: '100%', overflow: 'hidden' }}>\n      <div className=\"classifier-layout\" style={{ height: '100%', display: 'flex' }}>\n        {/* Data View - Hide when grouping is active */}\n        {!isGroupingActive && (\n          <div className=\"data-view\" style={{ flex: 1, overflow: 'hidden', display: 'flex', flexDirection: 'column' }}>\n            <h3>처리된 데이터 (회색: 미처리 영역)</h3>\n            <div className=\"data-content\" style={{ flex: 1, overflow: 'auto' }}>\n              <DataDisplay \n                processedData={processedData} \n                flattenData={flattenData}\n                segmentationData={segmentationData}\n                groupingData={null}\n              />\n            </div>\n          </div>\n        )}\n\n        {/* Middle - Group Panel */}\n        {groupingData && (\n          <div className=\"group-panel-container\" style={{ width: isGroupingActive ? '70%' : '300px', overflow: 'hidden', display: 'flex', flexDirection: 'column', borderLeft: '1px solid #ccc', borderRight: '1px solid #ccc' }}>\n            <GroupPanel \n              groupingData={{\n                ...groupingData,\n                onAddGroup: addEmptyGroup,\n                onUpdateGroupName: updateGroupName,\n                onAddValueToGroup: addValueToGroup,\n                onRemoveValueFromGroup: removeValueFromGroup\n              }}\n            />\n          </div>\n        )}\n        \n        {/* Right side - Pipeline */}\n        <div className=\"pipeline-panel\" style={{ width: '300px', overflow: 'hidden', display: 'flex', flexDirection: 'column' }}>\n          <h3>파이프라인</h3>\n          <div className=\"pipeline-list\" style={{ flex: 1, overflow: 'auto' }}>\n            {preparedPipeline.map((step, index) => (\n              <PipelineStep \n                key={step.id}\n                step={step}\n                index={index}\n                isSelected={selectedStep === step.id}\n                onSelect={selectStep}\n                onToggle={toggleStepActive}\n              />\n            ))}\n            \n            <button className=\"add-step\">\n              + 처리 단계 추가\n            </button>\n          </div>\n          \n          <div className=\"pipeline-actions\">\n            <button className=\"reset-button\" onClick={onReset}>\n              초기화\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SeparationClassifier; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
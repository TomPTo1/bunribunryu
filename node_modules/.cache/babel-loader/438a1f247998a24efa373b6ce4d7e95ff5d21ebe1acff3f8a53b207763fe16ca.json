{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/reorganize/channel-list-app/src/components/HeaderCombinationList.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { fetchHeaderCombinationList } from '../services/api';\nimport './Column.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HeaderCombinationList = ({\n  channel,\n  selectedHeader,\n  onCombinationSelect,\n  selectedCombination\n}) => {\n  _s();\n  const [combinationHeaders, setCombinationHeaders] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [activeTab, setActiveTab] = useState('combination'); // 'combination' or 'mining'\n  const [testMode, setTestMode] = useState(false); // Add test mode state\n  const [miningData, setMiningData] = useState(null);\n  const [expandedNodes, setExpandedNodes] = useState({});\n  const [highlightedPattern, setHighlightedPattern] = useState(null);\n  const [algorithm, setAlgorithm] = useState('eclat'); // 'eclat' or 'fpgrowth'\n  const [minSupport, setMinSupport] = useState(0.1); // 10% default\n  const [minConfidence, setMinConfidence] = useState(0.5); // 50% default\n  const svgRef = useRef(null);\n  useEffect(() => {\n    const getCombinationHeaders = async () => {\n      // Test mode can work without channel or header selection\n      if (!testMode && (!channel || !selectedHeader)) return;\n      setLoading(true);\n      try {\n        if (testMode) {\n          // Use sample data in test mode\n          const response = await import('../sample_data/header_combination.json');\n          console.log('Using sample data for combination headers:', response);\n          setCombinationHeaders(response.list || []);\n\n          // Generate mining data for test mode with selected algorithm\n          generateMiningData(response.list || [], algorithm);\n        } else if (channel && selectedHeader) {\n          // Use API in normal mode only if channel and header are selected\n          const headers = Array.isArray(selectedHeader) ? selectedHeader : [selectedHeader];\n          const response = await fetchHeaderCombinationList(channel, headers);\n          console.log('Combination headers response:', response);\n          setCombinationHeaders(response.list || []);\n\n          // Generate mining data from actual response with selected algorithm\n          generateMiningData(response.list || [], algorithm);\n        } else {\n          // Clear data if test mode is turned off and no channel/header is selected\n          setCombinationHeaders([]);\n          setMiningData(null);\n        }\n        setError(null);\n      } catch (err) {\n        setError(err.message);\n        setCombinationHeaders([]);\n        setMiningData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n    getCombinationHeaders();\n  }, [channel, selectedHeader, testMode, algorithm, minSupport, minConfidence]);\n\n  // Effect to update SVG visualization when mining data changes\n  useEffect(() => {\n    if (activeTab === 'mining' && miningData && svgRef.current) {\n      renderMiningTree();\n    }\n  }, [miningData, activeTab, expandedNodes, highlightedPattern]);\n\n  // Function to render a unified hierarchical tree visualization\n  const renderMiningTree = () => {\n    if (!svgRef.current || !miningData) return;\n    const svg = svgRef.current;\n    // Clear previous content\n    while (svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n    const CONTAINER_WIDTH = svg.clientWidth || 300;\n    const NODE_HEIGHT = 26;\n    const NODE_SPACING = 2;\n    const LEVEL_INDENT = 20;\n\n    // Calculate tree structure based on expanded nodes\n    const treeNodes = [];\n    let yOffset = 20; // Initial top padding\n\n    // Add root node first\n    treeNodes.push({\n      id: 'root',\n      name: '전체 패턴',\n      support: miningData.reduce((sum, item) => sum + item.support, 0),\n      confidence: 1,\n      level: 0,\n      x: 10,\n      y: yOffset,\n      isExpanded: true,\n      parent: null\n    });\n    yOffset += NODE_HEIGHT + NODE_SPACING;\n\n    // Recursive function to add child nodes\n    const addNodesRecursively = (nodes, parentId, level, isVisible) => {\n      if (!nodes || nodes.length === 0) return;\n\n      // Sort nodes by support for better visualization\n      const sortedNodes = [...nodes].sort((a, b) => b.support - a.support);\n      sortedNodes.forEach(node => {\n        // Skip if parent is collapsed\n        if (!isVisible) return;\n        const isExpanded = expandedNodes[node.id] || false;\n\n        // Add current node\n        treeNodes.push({\n          ...node,\n          level,\n          x: 10 + level * LEVEL_INDENT,\n          y: yOffset,\n          isExpanded,\n          parent: parentId\n        });\n\n        // Increment y-position for next node\n        yOffset += NODE_HEIGHT + NODE_SPACING;\n\n        // Process children if any\n        if (node.children && node.children.length > 0) {\n          addNodesRecursively(node.children, node.id, level + 1, isVisible && isExpanded);\n        }\n      });\n    };\n\n    // Add all nodes from mining data starting from the root\n    addNodesRecursively(miningData, 'root', 1, true);\n\n    // Set SVG height based on content\n    svg.setAttribute('height', `${yOffset + 20}px`); // Add bottom padding\n\n    // Create a container for the SVG elements\n    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    svg.appendChild(container);\n\n    // Draw connections between nodes\n    treeNodes.forEach(node => {\n      if (node.parent) {\n        const parent = treeNodes.find(n => n.id === node.parent);\n        if (parent) {\n          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n          const startX = parent.x + 8; // Start from parent indentation + offset\n          const startY = parent.y + NODE_HEIGHT / 2;\n          const endX = node.x;\n          const endY = node.y + NODE_HEIGHT / 2;\n\n          // Create an elbow connector (straight lines with 90-degree turn)\n          const d = `M ${startX} ${startY} L ${startX + 5} ${startY} L ${startX + 5} ${endY} L ${endX} ${endY}`;\n          path.setAttribute('d', d);\n          path.setAttribute('fill', 'none');\n\n          // Highlight path if node is part of highlighted pattern\n          const isHighlighted = highlightedPattern && highlightedPattern.includes(node.id) && highlightedPattern.includes(parent.id);\n          path.setAttribute('stroke', isHighlighted ? '#ff7f0e' : '#ccc');\n          path.setAttribute('stroke-width', isHighlighted ? '2' : '1.5');\n          container.appendChild(path);\n        }\n      }\n    });\n\n    // Draw nodes\n    treeNodes.forEach(node => {\n      const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      nodeGroup.setAttribute('transform', `translate(${node.x}, ${node.y})`);\n\n      // Node background (rectangle)\n      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n\n      // Calculate width based on content and level\n      const baseWidth = CONTAINER_WIDTH - node.x - 30;\n      const width = Math.min(baseWidth, 220); // Limit max width\n\n      rect.setAttribute('width', width);\n      rect.setAttribute('height', NODE_HEIGHT);\n      rect.setAttribute('rx', 4); // Rounded corners\n\n      // Determine fill color based on level and highlight state\n      const isHighlighted = highlightedPattern && highlightedPattern.includes(node.id);\n      const levelColors = ['#e9f5fe', '#f0f0ff', '#f8f0ff', '#fff0f8', '#fff8f0'];\n      let fillColor = levelColors[Math.min(node.level, levelColors.length - 1)];\n      if (isHighlighted) {\n        fillColor = '#fff0e0';\n      }\n      rect.setAttribute('fill', fillColor);\n      rect.setAttribute('stroke', isHighlighted ? '#ff7f0e' : '#ddd');\n      rect.setAttribute('stroke-width', isHighlighted ? '2' : '1');\n\n      // Make nodes interactive\n      if (node.children && node.children.length > 0 || node.id === 'root') {\n        nodeGroup.style.cursor = 'pointer';\n\n        // Toggle expansion on click\n        nodeGroup.addEventListener('click', () => {\n          toggleNode(node.id);\n        });\n      }\n\n      // Hover effect for highlighting patterns\n      nodeGroup.addEventListener('mouseenter', () => {\n        // Find all ancestors and highlight the path\n        const pattern = [node.id];\n        let currentNode = node;\n        while (currentNode.parent) {\n          pattern.push(currentNode.parent);\n          currentNode = treeNodes.find(n => n.id === currentNode.parent);\n          if (!currentNode) break;\n        }\n        setHighlightedPattern(pattern);\n      });\n      nodeGroup.addEventListener('mouseleave', () => {\n        setHighlightedPattern(null);\n      });\n\n      // Add expansion indicator if node has children\n      if (node.children && node.children.length > 0 || node.id === 'root') {\n        const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        indicator.textContent = node.isExpanded ? '−' : '+';\n        indicator.setAttribute('x', width - 15);\n        indicator.setAttribute('y', NODE_HEIGHT / 2 + 4);\n        indicator.setAttribute('font-size', '12px');\n        indicator.setAttribute('font-weight', 'bold');\n        indicator.setAttribute('fill', '#999');\n        nodeGroup.appendChild(indicator);\n      }\n\n      // Node label - truncate if needed\n      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttribute('x', 8);\n      text.setAttribute('y', NODE_HEIGHT / 2 + 4);\n      text.setAttribute('font-size', node.id === 'root' ? '12px' : '11px');\n      text.setAttribute('font-weight', node.id === 'root' ? 'bold' : 'normal');\n      text.setAttribute('fill', '#333');\n\n      // For root, show the name directly\n      if (node.id === 'root') {\n        text.textContent = node.name;\n      } else {\n        // For regular nodes, make sure text fits\n        const maxTextWidth = width - 60; // Leave room for support and indicator\n        let displayText = node.name;\n        if (displayText.length > 20) {\n          displayText = displayText.substring(0, 18) + '...';\n        }\n        text.textContent = displayText;\n      }\n\n      // Support count\n      const supportText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      supportText.setAttribute('x', width - 30);\n      supportText.setAttribute('y', NODE_HEIGHT / 2 + 4);\n      supportText.setAttribute('font-size', '11px');\n      supportText.setAttribute('text-anchor', 'end');\n      supportText.setAttribute('fill', '#666');\n      supportText.textContent = node.support;\n      nodeGroup.appendChild(rect);\n      nodeGroup.appendChild(text);\n      nodeGroup.appendChild(supportText);\n      container.appendChild(nodeGroup);\n    });\n  };\n\n  // Function to generate mining data using Eclat or FP Growth algorithm\n  const generateMiningData = (combinationData, algo = 'eclat') => {\n    if (!combinationData || combinationData.length === 0) {\n      setMiningData(null);\n      return;\n    }\n\n    // Step 1: Create transactions from header combinations\n    const transactions = combinationData.filter(item => item.header_group).map(item => item.header_group.split('|'));\n\n    // Step 2: Count item frequencies for both algorithms\n    const itemCounts = {};\n    const totalTransactions = transactions.length;\n    transactions.forEach(transaction => {\n      transaction.forEach(item => {\n        itemCounts[item] = (itemCounts[item] || 0) + 1;\n      });\n    });\n\n    // Calculate minimum support threshold\n    const minSupportCount = Math.max(2, Math.floor(totalTransactions * minSupport));\n\n    // Get frequent items sorted by frequency\n    const frequentItems = Object.keys(itemCounts).filter(item => itemCounts[item] >= minSupportCount).sort((a, b) => itemCounts[b] - itemCounts[a]);\n    if (algo === 'eclat') {\n      // ECLAT ALGORITHM IMPLEMENTATION\n\n      // Step 1: Build vertical tid-lists (transaction ID lists) for each item\n      const tidLists = {};\n      frequentItems.forEach(item => {\n        tidLists[item] = new Set();\n      });\n      transactions.forEach((transaction, tid) => {\n        transaction.forEach(item => {\n          if (frequentItems.includes(item)) {\n            tidLists[item].add(tid);\n          }\n        });\n      });\n\n      // Step 2: Find frequent itemsets using ECLAT recursion\n      const frequentItemsets = {};\n\n      // Initialize with single items\n      frequentItems.forEach(item => {\n        const support = tidLists[item].size;\n        frequentItemsets[item] = {\n          support,\n          confidence: support / totalTransactions,\n          tids: tidLists[item],\n          children: {}\n        };\n      });\n\n      // Recursive function to find frequent itemsets (allowing deeper patterns)\n      const eclat = (prefix, tidList, level, parent) => {\n        if (level > 5) return; // Allow up to depth 5 for richer pattern exploration\n\n        // Find extensions with all items that come after the prefix's last item\n        const lastItem = prefix[prefix.length - 1];\n        const lastItemIndex = frequentItems.indexOf(lastItem);\n        for (let i = lastItemIndex + 1; i < frequentItems.length; i++) {\n          const item = frequentItems[i];\n          const itemTids = tidLists[item];\n\n          // Compute intersection\n          const intersection = new Set([...tidList].filter(tid => itemTids.has(tid)));\n          const support = intersection.size;\n\n          // If support is high enough, add to frequent itemsets\n          if (support >= minSupportCount) {\n            const newPrefix = [...prefix, item];\n            const newPrefixStr = item; // Just use the extension item as key\n\n            // Calculate confidence (support of extended pattern / support of prefix)\n            const confidence = support / tidList.size;\n\n            // Add only if confidence meets threshold\n            if (confidence >= minConfidence) {\n              parent.children[newPrefixStr] = {\n                support,\n                confidence,\n                tids: intersection,\n                children: {}\n              };\n\n              // Recursively find extensions of this new prefix\n              eclat(newPrefix, intersection, level + 1, parent.children[newPrefixStr]);\n            }\n          }\n        }\n      };\n\n      // Start ECLAT recursion for each single item\n      frequentItems.forEach(item => {\n        eclat([item], tidLists[item], 1, frequentItemsets[item]);\n      });\n\n      // Convert to array format for visualization\n      const result = frequentItems.map(item => ({\n        id: item,\n        name: item,\n        support: tidLists[item].size,\n        confidence: tidLists[item].size / totalTransactions,\n        children: Object.keys(frequentItemsets[item].children).map(child => ({\n          id: `${item}-${child}`,\n          name: child,\n          support: frequentItemsets[item].children[child].support,\n          confidence: frequentItemsets[item].children[child].confidence,\n          children: Object.keys(frequentItemsets[item].children[child].children || {}).map(grandchild => ({\n            id: `${item}-${child}-${grandchild}`,\n            name: grandchild,\n            support: frequentItemsets[item].children[child].children[grandchild].support,\n            confidence: frequentItemsets[item].children[child].children[grandchild].confidence,\n            children: Object.keys(frequentItemsets[item].children[child].children[grandchild].children || {}).map(greatGrandchild => ({\n              id: `${item}-${child}-${grandchild}-${greatGrandchild}`,\n              name: greatGrandchild,\n              support: frequentItemsets[item].children[child].children[grandchild].children[greatGrandchild].support,\n              confidence: frequentItemsets[item].children[child].children[grandchild].children[greatGrandchild].confidence,\n              children: []\n            }))\n          }))\n        }))\n      }));\n      setMiningData(result);\n    } else {\n      // FP GROWTH ALGORITHM - UNIFIED TREE IMPLEMENTATION\n\n      // Step 3: Reorder transactions based on frequency\n      const orderedTransactions = transactions.map(transaction => {\n        return transaction.filter(item => frequentItems.includes(item)).sort((a, b) => itemCounts[b] - itemCounts[a]);\n      }).filter(transaction => transaction.length > 0);\n\n      // Step 4: Build unified FP-Tree\n      const fpTree = {\n        name: \"root\",\n        count: 0,\n        children: {},\n        nodeLinks: {} // Header table node links\n      };\n\n      // Initialize header table\n      const headerTable = {};\n      frequentItems.forEach(item => {\n        headerTable[item] = {\n          count: itemCounts[item],\n          nodeLink: null\n        };\n      });\n\n      // Insert a transaction into the FP-Tree\n      const insertTransaction = (transaction, tree, count = 1) => {\n        if (transaction.length === 0) return;\n        const item = transaction[0];\n\n        // Create node if it doesn't exist\n        if (!tree.children[item]) {\n          tree.children[item] = {\n            name: item,\n            count: 0,\n            children: {},\n            parent: tree,\n            nextSameItem: null\n          };\n\n          // Update header table node links\n          if (!headerTable[item].nodeLink) {\n            headerTable[item].nodeLink = tree.children[item];\n          } else {\n            let current = headerTable[item].nodeLink;\n            while (current.nextSameItem) {\n              current = current.nextSameItem;\n            }\n            current.nextSameItem = tree.children[item];\n          }\n        }\n\n        // Increment count\n        tree.children[item].count += count;\n\n        // Insert remaining items\n        if (transaction.length > 1) {\n          insertTransaction(transaction.slice(1), tree.children[item], count);\n        }\n      };\n\n      // Insert all transactions\n      orderedTransactions.forEach(transaction => {\n        insertTransaction(transaction, fpTree);\n      });\n\n      // Step 5: Mine patterns using FP-Growth\n      const patterns = {};\n\n      // Mine patterns with a suffix\n      const minePatterns = (headerTable, conditionalBase, suffix = [], parentSupport = totalTransactions) => {\n        // Get items in descending order of frequency\n        const items = Object.keys(headerTable).sort((a, b) => headerTable[b].count - headerTable[a].count);\n        for (const item of items) {\n          // New frequent itemset found\n          const newSuffix = [item, ...suffix];\n          const supportCount = headerTable[item].count;\n\n          // Calculate confidence for patterns with len > 1\n          const confidence = newSuffix.length > 1 ? supportCount / parentSupport : supportCount / totalTransactions;\n\n          // Only include if confidence meets threshold\n          if (confidence >= minConfidence) {\n            // Store pattern\n            const patternKey = newSuffix.join('-');\n            patterns[patternKey] = {\n              items: newSuffix,\n              support: supportCount,\n              confidence: confidence\n            };\n\n            // Build conditional pattern base\n            const conditionalPatternBase = [];\n            let node = headerTable[item].nodeLink;\n            while (node) {\n              // Traverse upward to get the path\n              const path = [];\n              let prefixSupport = node.count;\n              let parent = node.parent;\n              while (parent && parent.name !== \"root\") {\n                path.unshift(parent.name);\n                parent = parent.parent;\n              }\n              if (path.length > 0) {\n                conditionalPatternBase.push({\n                  path,\n                  count: prefixSupport\n                });\n              }\n              node = node.nextSameItem;\n            }\n\n            // Build conditional FP-Tree\n            if (conditionalPatternBase.length > 0) {\n              const newConditionalBase = {};\n\n              // Count items in the conditional pattern base\n              conditionalPatternBase.forEach(({\n                path,\n                count\n              }) => {\n                path.forEach(pathItem => {\n                  newConditionalBase[pathItem] = (newConditionalBase[pathItem] || 0) + count;\n                });\n              });\n\n              // Filter items by minimum support\n              const newHeaderTable = {};\n              Object.keys(newConditionalBase).forEach(item => {\n                if (newConditionalBase[item] >= minSupportCount) {\n                  newHeaderTable[item] = {\n                    count: newConditionalBase[item],\n                    nodeLink: null\n                  };\n                }\n              });\n\n              // Recursively mine with the new conditional tree, up to depth 5\n              if (Object.keys(newHeaderTable).length > 0 && newSuffix.length < 5) {\n                minePatterns(newHeaderTable, conditionalPatternBase, newSuffix, supportCount);\n              }\n            }\n          }\n        }\n      };\n\n      // Start mining\n      minePatterns(headerTable, []);\n\n      // Build tree from patterns\n      const buildTree = patterns => {\n        const result = [];\n        const itemMap = {};\n\n        // Group by first item\n        Object.values(patterns).forEach(pattern => {\n          if (pattern.items.length > 0) {\n            const firstItem = pattern.items[0];\n            if (!itemMap[firstItem]) {\n              itemMap[firstItem] = {\n                id: firstItem,\n                name: firstItem,\n                support: itemCounts[firstItem],\n                confidence: itemCounts[firstItem] / totalTransactions,\n                children: []\n              };\n              result.push(itemMap[firstItem]);\n            }\n\n            // Add subsequent items as children\n            if (pattern.items.length > 1) {\n              let currentNode = itemMap[firstItem];\n              let currentPath = firstItem;\n              for (let i = 1; i < pattern.items.length; i++) {\n                const currentItem = pattern.items[i];\n                currentPath = `${currentPath}-${currentItem}`;\n\n                // Check if child already exists\n                let childNode = currentNode.children.find(child => child.name === currentItem);\n                if (!childNode) {\n                  childNode = {\n                    id: currentPath,\n                    name: currentItem,\n                    support: pattern.support,\n                    confidence: pattern.confidence,\n                    children: []\n                  };\n                  currentNode.children.push(childNode);\n                }\n                currentNode = childNode;\n              }\n            }\n          }\n        });\n        return result;\n      };\n      const result = buildTree(patterns);\n      setMiningData(result);\n    }\n\n    // Initialize expanded state for visualization\n    const initialExpanded = {\n      'root': true\n    };\n    // Auto-expand some top nodes for better initial view\n    if (miningData && miningData.length > 0) {\n      // Expand first 3 level 1 nodes\n      miningData.slice(0, 3).forEach(node => {\n        initialExpanded[node.id] = true;\n      });\n    }\n    setExpandedNodes(initialExpanded);\n  };\n\n  // Switch between algorithms\n  const switchAlgorithm = algo => {\n    setAlgorithm(algo);\n  };\n\n  // Change minimum support threshold\n  const handleSupportChange = e => {\n    const value = parseFloat(e.target.value);\n    if (!isNaN(value) && value > 0 && value <= 1) {\n      setMinSupport(value);\n    }\n  };\n\n  // Change minimum confidence threshold\n  const handleConfidenceChange = e => {\n    const value = parseFloat(e.target.value);\n    if (!isNaN(value) && value > 0 && value <= 1) {\n      setMinConfidence(value);\n    }\n  };\n  const handleCombinationClick = combination => {\n    if (onCombinationSelect) {\n      onCombinationSelect(combination);\n    }\n  };\n\n  // Function to toggle node expansion\n  const toggleNode = nodeId => {\n    setExpandedNodes(prev => ({\n      ...prev,\n      [nodeId]: !prev[nodeId]\n    }));\n  };\n\n  // Function to render header_group as tags\n  const renderHeaderGroupAsTags = headerGroup => {\n    if (!headerGroup) return null;\n    const headers = headerGroup.split('|');\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"header-tags\",\n      children: headers.map((header, index) => /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"similarity-tag\",\n        children: header\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 685,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 683,\n      columnNumber: 7\n    }, this);\n  };\n  const toggleTestMode = () => {\n    const newTestMode = !testMode;\n    setTestMode(newTestMode);\n\n    // Log the test mode state change\n    console.log(`Test mode ${newTestMode ? 'enabled' : 'disabled'}`);\n\n    // Clear combination data when turning off test mode if no channel/header selected\n    if (!newTestMode && (!channel || !selectedHeader)) {\n      setCombinationHeaders([]);\n      setMiningData(null);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"column-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"column-title-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        className: \"column-title\",\n        children: !testMode && selectedHeader ? `헤더명 조합 목록: ${selectedHeader}` : '헤더명 조합 목록'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 708,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"test-mode-toggle\",\n        children: /*#__PURE__*/_jsxDEV(\"label\", {\n          className: \"toggle-label\",\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            children: [\"Test Mode \", testMode ? 'ON' : 'OFF']\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 715,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"checkbox\",\n            checked: testMode,\n            onChange: toggleTestMode\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 716,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"toggle-slider\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 721,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 714,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 713,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 707,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"tabs\",\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        className: `tab ${activeTab === 'combination' ? 'active' : ''}`,\n        onClick: () => setActiveTab('combination'),\n        children: \"\\uC870\\uD569\\uBDF0\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 727,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: `tab ${activeTab === 'mining' ? 'active' : ''}`,\n        onClick: () => setActiveTab('mining'),\n        children: \"\\uB9C8\\uC774\\uB2DD\\uBDF0\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 733,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 726,\n      columnNumber: 7\n    }, this), activeTab === 'combination' ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"tab-content\",\n      children: loading ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"loading\",\n        children: \"\\uB85C\\uB529 \\uC911...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 744,\n        columnNumber: 13\n      }, this) : error ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"error\",\n        children: [\"\\uC5D0\\uB7EC: \", error]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 746,\n        columnNumber: 13\n      }, this) : combinationHeaders.length > 0 ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"column-content\",\n        children: combinationHeaders.map((item, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `column-item ${selectedCombination === item.header_group ? 'selected' : ''}`,\n          onClick: () => handleCombinationClick(item.header_group),\n          children: renderHeaderGroupAsTags(item.header_group)\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 750,\n          columnNumber: 17\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 748,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"column-empty\",\n        children: testMode ? \"테스트 모드가 활성화되었습니다.\" : \"채널과 헤더를 선택해주세요.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 760,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 742,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"tab-content\",\n      children: loading ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"loading\",\n        children: \"\\uB85C\\uB529 \\uC911...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 770,\n        columnNumber: 13\n      }, this) : error ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"error\",\n        children: [\"\\uC5D0\\uB7EC: \", error]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 772,\n        columnNumber: 13\n      }, this) : miningData ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"mining-view\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"mining-controls\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"algorithm-selector\",\n            children: [/*#__PURE__*/_jsxDEV(\"button\", {\n              className: `algorithm-btn ${algorithm === 'eclat' ? 'active' : ''}`,\n              onClick: () => switchAlgorithm('eclat'),\n              children: \"Eclat \\uC54C\\uACE0\\uB9AC\\uC998\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 777,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n              className: `algorithm-btn ${algorithm === 'fpgrowth' ? 'active' : ''}`,\n              onClick: () => switchAlgorithm('fpgrowth'),\n              children: \"FP-Growth \\uC54C\\uACE0\\uB9AC\\uC998\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 783,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 776,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"thresholds-control\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"threshold-item\",\n              children: [/*#__PURE__*/_jsxDEV(\"label\", {\n                children: [\"\\uCD5C\\uC18C \\uC9C0\\uC9C0\\uB3C4: \", (minSupport * 100).toFixed(0), \"%\"]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 792,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n                type: \"range\",\n                min: \"0.05\",\n                max: \"0.5\",\n                step: \"0.05\",\n                value: minSupport,\n                onChange: handleSupportChange\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 793,\n                columnNumber: 21\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 791,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"threshold-item\",\n              children: [/*#__PURE__*/_jsxDEV(\"label\", {\n                children: [\"\\uCD5C\\uC18C \\uC2E0\\uB8B0\\uB3C4: \", (minConfidence * 100).toFixed(0), \"%\"]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 803,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n                type: \"range\",\n                min: \"0.1\",\n                max: \"0.9\",\n                step: \"0.1\",\n                value: minConfidence,\n                onChange: handleConfidenceChange\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 804,\n                columnNumber: 21\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 802,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 790,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 775,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"mining-tree-container\",\n          children: /*#__PURE__*/_jsxDEV(\"svg\", {\n            className: \"mining-tree-svg\",\n            ref: svgRef,\n            width: \"100%\",\n            height: \"400\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 817,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 816,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"mining-explanation\",\n          children: [/*#__PURE__*/_jsxDEV(\"p\", {\n            children: [algorithm === 'eclat' ? 'Eclat' : 'FP-Growth', \" \\uC54C\\uACE0\\uB9AC\\uC998 \\uD328\\uD134 \\uC2DC\\uAC01\\uD654:\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 826,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n            children: [/*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"\\uD328\\uD134 \\uD074\\uB9AD: \\uD558\\uC704 \\uD328\\uD134 \\uD655\\uC7A5/\\uCD95\\uC18C\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 828,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"\\uB9C8\\uC6B0\\uC2A4 \\uC624\\uBC84: \\uD328\\uD134 \\uACBD\\uB85C \\uD558\\uC774\\uB77C\\uC774\\uD2B8\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 829,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"\\uC22B\\uC790: \\uD328\\uD134 \\uBC1C\\uC0DD \\uBE48\\uB3C4\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 830,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"\\uB2E8\\uACC4\\uBCC4 \\uC0C9\\uC0C1: \\uD328\\uD134\\uC758 \\uAE4A\\uC774(\\uD56D\\uBAA9 \\uAC1C\\uC218)\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 831,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 827,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 825,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 774,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"column-empty\",\n        children: testMode ? \"마이닝 데이터를 로딩 중입니다...\" : \"채널과 헤더를 선택하면 마이닝 결과가 표시됩니다.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 836,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 768,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"style\", {\n      jsx: true,\n      children: `\n        .mining-view {\n          height: 100%;\n          display: flex;\n          flex-direction: column;\n        }\n        \n        .mining-controls {\n          display: flex;\n          flex-direction: column;\n          gap: 8px;\n          margin-bottom: 12px;\n          background-color: #f8f8f8;\n          border-radius: 4px;\n          padding: 8px;\n        }\n        \n        .algorithm-selector {\n          display: flex;\n          gap: 8px;\n        }\n        \n        .algorithm-btn {\n          background: #f0f0f0;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          padding: 4px 8px;\n          font-size: 12px;\n          cursor: pointer;\n        }\n        \n        .algorithm-btn.active {\n          background: #4682b4;\n          color: white;\n          border-color: #4682b4;\n        }\n        \n        .thresholds-control {\n          display: flex;\n          flex-direction: column;\n          gap: 6px;\n        }\n        \n        .threshold-item {\n          display: flex;\n          flex-direction: column;\n          font-size: 11px;\n        }\n        \n        .threshold-item label {\n          margin-bottom: 2px;\n        }\n        \n        .threshold-item input {\n          width: 100%;\n        }\n        \n        .mining-tree-container {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: auto;\n          background-color: #fafafa;\n          flex-grow: 1;\n          min-height: 300px;\n        }\n        \n        .mining-explanation {\n          margin-top: 10px;\n          font-size: 11px;\n          color: #666;\n          background-color: #f9f9f9;\n          border-radius: 4px;\n          padding: 6px 10px;\n        }\n        \n        .mining-explanation ul {\n          padding-left: 16px;\n          margin: 4px 0;\n        }\n        \n        .mining-explanation p {\n          margin: 4px 0;\n          font-weight: bold;\n        }\n        \n        .mining-explanation li {\n          margin-bottom: 2px;\n        }\n      `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 845,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 706,\n    columnNumber: 5\n  }, this);\n};\n_s(HeaderCombinationList, \"vpH5W2yqHt0jYC7rb31sWrbAwPA=\");\n_c = HeaderCombinationList;\nexport default HeaderCombinationList;\nvar _c;\n$RefreshReg$(_c, \"HeaderCombinationList\");","map":{"version":3,"names":["React","useState","useEffect","useRef","fetchHeaderCombinationList","jsxDEV","_jsxDEV","HeaderCombinationList","channel","selectedHeader","onCombinationSelect","selectedCombination","_s","combinationHeaders","setCombinationHeaders","loading","setLoading","error","setError","activeTab","setActiveTab","testMode","setTestMode","miningData","setMiningData","expandedNodes","setExpandedNodes","highlightedPattern","setHighlightedPattern","algorithm","setAlgorithm","minSupport","setMinSupport","minConfidence","setMinConfidence","svgRef","getCombinationHeaders","response","console","log","list","generateMiningData","headers","Array","isArray","err","message","current","renderMiningTree","svg","firstChild","removeChild","CONTAINER_WIDTH","clientWidth","NODE_HEIGHT","NODE_SPACING","LEVEL_INDENT","treeNodes","yOffset","push","id","name","support","reduce","sum","item","confidence","level","x","y","isExpanded","parent","addNodesRecursively","nodes","parentId","isVisible","length","sortedNodes","sort","a","b","forEach","node","children","setAttribute","container","document","createElementNS","appendChild","find","n","path","startX","startY","endX","endY","d","isHighlighted","includes","nodeGroup","rect","baseWidth","width","Math","min","levelColors","fillColor","style","cursor","addEventListener","toggleNode","pattern","currentNode","indicator","textContent","text","maxTextWidth","displayText","substring","supportText","combinationData","algo","transactions","filter","header_group","map","split","itemCounts","totalTransactions","transaction","minSupportCount","max","floor","frequentItems","Object","keys","tidLists","Set","tid","add","frequentItemsets","size","tids","eclat","prefix","tidList","lastItem","lastItemIndex","indexOf","i","itemTids","intersection","has","newPrefix","newPrefixStr","result","child","grandchild","greatGrandchild","orderedTransactions","fpTree","count","nodeLinks","headerTable","nodeLink","insertTransaction","tree","nextSameItem","slice","patterns","minePatterns","conditionalBase","suffix","parentSupport","items","newSuffix","supportCount","patternKey","join","conditionalPatternBase","prefixSupport","unshift","newConditionalBase","pathItem","newHeaderTable","buildTree","itemMap","values","firstItem","currentPath","currentItem","childNode","initialExpanded","switchAlgorithm","handleSupportChange","e","value","parseFloat","target","isNaN","handleConfidenceChange","handleCombinationClick","combination","nodeId","prev","renderHeaderGroupAsTags","headerGroup","className","header","index","fileName","_jsxFileName","lineNumber","columnNumber","toggleTestMode","newTestMode","type","checked","onChange","onClick","toFixed","step","ref","height","jsx","_c","$RefreshReg$"],"sources":["/Users/francesson/reorganize/channel-list-app/src/components/HeaderCombinationList.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { fetchHeaderCombinationList } from '../services/api';\nimport './Column.css';\n\nconst HeaderCombinationList = ({ channel, selectedHeader, onCombinationSelect, selectedCombination }) => {\n  const [combinationHeaders, setCombinationHeaders] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [activeTab, setActiveTab] = useState('combination'); // 'combination' or 'mining'\n  const [testMode, setTestMode] = useState(false); // Add test mode state\n  const [miningData, setMiningData] = useState(null);\n  const [expandedNodes, setExpandedNodes] = useState({});\n  const [highlightedPattern, setHighlightedPattern] = useState(null);\n  const [algorithm, setAlgorithm] = useState('eclat'); // 'eclat' or 'fpgrowth'\n  const [minSupport, setMinSupport] = useState(0.1); // 10% default\n  const [minConfidence, setMinConfidence] = useState(0.5); // 50% default\n  const svgRef = useRef(null);\n\n  useEffect(() => {\n    const getCombinationHeaders = async () => {\n      // Test mode can work without channel or header selection\n      if (!testMode && (!channel || !selectedHeader)) return;\n      \n      setLoading(true);\n      try {\n        if (testMode) {\n          // Use sample data in test mode\n          const response = await import('../sample_data/header_combination.json');\n          console.log('Using sample data for combination headers:', response);\n          setCombinationHeaders(response.list || []);\n          \n          // Generate mining data for test mode with selected algorithm\n          generateMiningData(response.list || [], algorithm);\n        } else if (channel && selectedHeader) {\n          // Use API in normal mode only if channel and header are selected\n          const headers = Array.isArray(selectedHeader) ? selectedHeader : [selectedHeader];\n          const response = await fetchHeaderCombinationList(channel, headers);\n          console.log('Combination headers response:', response);\n          setCombinationHeaders(response.list || []);\n          \n          // Generate mining data from actual response with selected algorithm\n          generateMiningData(response.list || [], algorithm);\n        } else {\n          // Clear data if test mode is turned off and no channel/header is selected\n          setCombinationHeaders([]);\n          setMiningData(null);\n        }\n        setError(null);\n      } catch (err) {\n        setError(err.message);\n        setCombinationHeaders([]);\n        setMiningData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    getCombinationHeaders();\n  }, [channel, selectedHeader, testMode, algorithm, minSupport, minConfidence]); \n\n  // Effect to update SVG visualization when mining data changes\n  useEffect(() => {\n    if (activeTab === 'mining' && miningData && svgRef.current) {\n      renderMiningTree();\n    }\n  }, [miningData, activeTab, expandedNodes, highlightedPattern]);\n\n  // Function to render a unified hierarchical tree visualization\n  const renderMiningTree = () => {\n    if (!svgRef.current || !miningData) return;\n\n    const svg = svgRef.current;\n    // Clear previous content\n    while (svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n\n    const CONTAINER_WIDTH = svg.clientWidth || 300;\n    const NODE_HEIGHT = 26;\n    const NODE_SPACING = 2;\n    const LEVEL_INDENT = 20;\n    \n    // Calculate tree structure based on expanded nodes\n    const treeNodes = [];\n    let yOffset = 20;  // Initial top padding\n    \n    // Add root node first\n    treeNodes.push({\n      id: 'root',\n      name: '전체 패턴',\n      support: miningData.reduce((sum, item) => sum + item.support, 0),\n      confidence: 1,\n      level: 0,\n      x: 10,\n      y: yOffset,\n      isExpanded: true,\n      parent: null\n    });\n    \n    yOffset += NODE_HEIGHT + NODE_SPACING;\n    \n    // Recursive function to add child nodes\n    const addNodesRecursively = (nodes, parentId, level, isVisible) => {\n      if (!nodes || nodes.length === 0) return;\n      \n      // Sort nodes by support for better visualization\n      const sortedNodes = [...nodes].sort((a, b) => b.support - a.support);\n      \n      sortedNodes.forEach(node => {\n        // Skip if parent is collapsed\n        if (!isVisible) return;\n        \n        const isExpanded = expandedNodes[node.id] || false;\n        \n        // Add current node\n        treeNodes.push({\n          ...node,\n          level,\n          x: 10 + (level * LEVEL_INDENT),\n          y: yOffset,\n          isExpanded,\n          parent: parentId\n        });\n        \n        // Increment y-position for next node\n        yOffset += NODE_HEIGHT + NODE_SPACING;\n        \n        // Process children if any\n        if (node.children && node.children.length > 0) {\n          addNodesRecursively(node.children, node.id, level + 1, isVisible && isExpanded);\n        }\n      });\n    };\n    \n    // Add all nodes from mining data starting from the root\n    addNodesRecursively(miningData, 'root', 1, true);\n    \n    // Set SVG height based on content\n    svg.setAttribute('height', `${yOffset + 20}px`);  // Add bottom padding\n    \n    // Create a container for the SVG elements\n    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    svg.appendChild(container);\n    \n    // Draw connections between nodes\n    treeNodes.forEach(node => {\n      if (node.parent) {\n        const parent = treeNodes.find(n => n.id === node.parent);\n        if (parent) {\n          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n          \n          const startX = parent.x + 8;  // Start from parent indentation + offset\n          const startY = parent.y + (NODE_HEIGHT / 2);\n          const endX = node.x;\n          const endY = node.y + (NODE_HEIGHT / 2);\n          \n          // Create an elbow connector (straight lines with 90-degree turn)\n          const d = `M ${startX} ${startY} L ${startX + 5} ${startY} L ${startX + 5} ${endY} L ${endX} ${endY}`;\n          \n          path.setAttribute('d', d);\n          path.setAttribute('fill', 'none');\n          \n          // Highlight path if node is part of highlighted pattern\n          const isHighlighted = highlightedPattern && (\n            highlightedPattern.includes(node.id) && highlightedPattern.includes(parent.id)\n          );\n          \n          path.setAttribute('stroke', isHighlighted ? '#ff7f0e' : '#ccc');\n          path.setAttribute('stroke-width', isHighlighted ? '2' : '1.5');\n          \n          container.appendChild(path);\n        }\n      }\n    });\n    \n    // Draw nodes\n    treeNodes.forEach(node => {\n      const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      nodeGroup.setAttribute('transform', `translate(${node.x}, ${node.y})`);\n      \n      // Node background (rectangle)\n      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n      \n      // Calculate width based on content and level\n      const baseWidth = CONTAINER_WIDTH - node.x - 30;\n      const width = Math.min(baseWidth, 220);  // Limit max width\n      \n      rect.setAttribute('width', width);\n      rect.setAttribute('height', NODE_HEIGHT);\n      rect.setAttribute('rx', 4);  // Rounded corners\n      \n      // Determine fill color based on level and highlight state\n      const isHighlighted = highlightedPattern && highlightedPattern.includes(node.id);\n      const levelColors = ['#e9f5fe', '#f0f0ff', '#f8f0ff', '#fff0f8', '#fff8f0'];\n      let fillColor = levelColors[Math.min(node.level, levelColors.length - 1)];\n      \n      if (isHighlighted) {\n        fillColor = '#fff0e0';\n      }\n      \n      rect.setAttribute('fill', fillColor);\n      rect.setAttribute('stroke', isHighlighted ? '#ff7f0e' : '#ddd');\n      rect.setAttribute('stroke-width', isHighlighted ? '2' : '1');\n      \n      // Make nodes interactive\n      if ((node.children && node.children.length > 0) || node.id === 'root') {\n        nodeGroup.style.cursor = 'pointer';\n        \n        // Toggle expansion on click\n        nodeGroup.addEventListener('click', () => {\n          toggleNode(node.id);\n        });\n      }\n      \n      // Hover effect for highlighting patterns\n      nodeGroup.addEventListener('mouseenter', () => {\n        // Find all ancestors and highlight the path\n        const pattern = [node.id];\n        let currentNode = node;\n        \n        while (currentNode.parent) {\n          pattern.push(currentNode.parent);\n          currentNode = treeNodes.find(n => n.id === currentNode.parent);\n          if (!currentNode) break;\n        }\n        \n        setHighlightedPattern(pattern);\n      });\n      \n      nodeGroup.addEventListener('mouseleave', () => {\n        setHighlightedPattern(null);\n      });\n      \n      // Add expansion indicator if node has children\n      if ((node.children && node.children.length > 0) || node.id === 'root') {\n        const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        indicator.textContent = node.isExpanded ? '−' : '+';\n        indicator.setAttribute('x', width - 15);\n        indicator.setAttribute('y', NODE_HEIGHT / 2 + 4);\n        indicator.setAttribute('font-size', '12px');\n        indicator.setAttribute('font-weight', 'bold');\n        indicator.setAttribute('fill', '#999');\n        nodeGroup.appendChild(indicator);\n      }\n      \n      // Node label - truncate if needed\n      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttribute('x', 8);\n      text.setAttribute('y', NODE_HEIGHT / 2 + 4);\n      text.setAttribute('font-size', node.id === 'root' ? '12px' : '11px');\n      text.setAttribute('font-weight', node.id === 'root' ? 'bold' : 'normal');\n      text.setAttribute('fill', '#333');\n      \n      // For root, show the name directly\n      if (node.id === 'root') {\n        text.textContent = node.name;\n      } else {\n        // For regular nodes, make sure text fits\n        const maxTextWidth = width - 60;  // Leave room for support and indicator\n        let displayText = node.name;\n        \n        if (displayText.length > 20) {\n          displayText = displayText.substring(0, 18) + '...';\n        }\n        \n        text.textContent = displayText;\n      }\n      \n      // Support count\n      const supportText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      supportText.setAttribute('x', width - 30);\n      supportText.setAttribute('y', NODE_HEIGHT / 2 + 4);\n      supportText.setAttribute('font-size', '11px');\n      supportText.setAttribute('text-anchor', 'end');\n      supportText.setAttribute('fill', '#666');\n      supportText.textContent = node.support;\n      \n      nodeGroup.appendChild(rect);\n      nodeGroup.appendChild(text);\n      nodeGroup.appendChild(supportText);\n      container.appendChild(nodeGroup);\n    });\n  };\n  \n  // Function to generate mining data using Eclat or FP Growth algorithm\n  const generateMiningData = (combinationData, algo = 'eclat') => {\n    if (!combinationData || combinationData.length === 0) {\n      setMiningData(null);\n      return;\n    }\n\n    // Step 1: Create transactions from header combinations\n    const transactions = combinationData\n      .filter(item => item.header_group)\n      .map(item => item.header_group.split('|'));\n\n    // Step 2: Count item frequencies for both algorithms\n    const itemCounts = {};\n    const totalTransactions = transactions.length;\n    \n    transactions.forEach(transaction => {\n      transaction.forEach(item => {\n        itemCounts[item] = (itemCounts[item] || 0) + 1;\n      });\n    });\n\n    // Calculate minimum support threshold\n    const minSupportCount = Math.max(2, Math.floor(totalTransactions * minSupport));\n    \n    // Get frequent items sorted by frequency\n    const frequentItems = Object.keys(itemCounts)\n      .filter(item => itemCounts[item] >= minSupportCount)\n      .sort((a, b) => itemCounts[b] - itemCounts[a]);\n    \n    if (algo === 'eclat') {\n      // ECLAT ALGORITHM IMPLEMENTATION\n      \n      // Step 1: Build vertical tid-lists (transaction ID lists) for each item\n      const tidLists = {};\n      frequentItems.forEach(item => {\n        tidLists[item] = new Set();\n      });\n      \n      transactions.forEach((transaction, tid) => {\n        transaction.forEach(item => {\n          if (frequentItems.includes(item)) {\n            tidLists[item].add(tid);\n          }\n        });\n      });\n      \n      // Step 2: Find frequent itemsets using ECLAT recursion\n      const frequentItemsets = {};\n      \n      // Initialize with single items\n      frequentItems.forEach(item => {\n        const support = tidLists[item].size;\n        frequentItemsets[item] = {\n          support,\n          confidence: support / totalTransactions,\n          tids: tidLists[item],\n          children: {}\n        };\n      });\n      \n      // Recursive function to find frequent itemsets (allowing deeper patterns)\n      const eclat = (prefix, tidList, level, parent) => {\n        if (level > 5) return; // Allow up to depth 5 for richer pattern exploration\n        \n        // Find extensions with all items that come after the prefix's last item\n        const lastItem = prefix[prefix.length - 1];\n        const lastItemIndex = frequentItems.indexOf(lastItem);\n        \n        for (let i = lastItemIndex + 1; i < frequentItems.length; i++) {\n          const item = frequentItems[i];\n          const itemTids = tidLists[item];\n          \n          // Compute intersection\n          const intersection = new Set([...tidList].filter(tid => itemTids.has(tid)));\n          const support = intersection.size;\n          \n          // If support is high enough, add to frequent itemsets\n          if (support >= minSupportCount) {\n            const newPrefix = [...prefix, item];\n            const newPrefixStr = item; // Just use the extension item as key\n            \n            // Calculate confidence (support of extended pattern / support of prefix)\n            const confidence = support / tidList.size;\n            \n            // Add only if confidence meets threshold\n            if (confidence >= minConfidence) {\n              parent.children[newPrefixStr] = {\n                support,\n                confidence,\n                tids: intersection,\n                children: {}\n              };\n              \n              // Recursively find extensions of this new prefix\n              eclat(newPrefix, intersection, level + 1, parent.children[newPrefixStr]);\n            }\n          }\n        }\n      };\n      \n      // Start ECLAT recursion for each single item\n      frequentItems.forEach(item => {\n        eclat([item], tidLists[item], 1, frequentItemsets[item]);\n      });\n      \n      // Convert to array format for visualization\n      const result = frequentItems.map(item => ({\n        id: item,\n        name: item,\n        support: tidLists[item].size,\n        confidence: tidLists[item].size / totalTransactions,\n        children: Object.keys(frequentItemsets[item].children).map(child => ({\n          id: `${item}-${child}`,\n          name: child,\n          support: frequentItemsets[item].children[child].support,\n          confidence: frequentItemsets[item].children[child].confidence,\n          children: Object.keys(frequentItemsets[item].children[child].children || {}).map(grandchild => ({\n            id: `${item}-${child}-${grandchild}`,\n            name: grandchild,\n            support: frequentItemsets[item].children[child].children[grandchild].support,\n            confidence: frequentItemsets[item].children[child].children[grandchild].confidence,\n            children: Object.keys(frequentItemsets[item].children[child].children[grandchild].children || {}).map(greatGrandchild => ({\n              id: `${item}-${child}-${grandchild}-${greatGrandchild}`,\n              name: greatGrandchild,\n              support: frequentItemsets[item].children[child].children[grandchild].children[greatGrandchild].support,\n              confidence: frequentItemsets[item].children[child].children[grandchild].children[greatGrandchild].confidence,\n              children: []\n            }))\n          }))\n        }))\n      }));\n      \n      setMiningData(result);\n      \n    } else {\n      // FP GROWTH ALGORITHM - UNIFIED TREE IMPLEMENTATION\n      \n      // Step 3: Reorder transactions based on frequency\n      const orderedTransactions = transactions.map(transaction => {\n        return transaction\n          .filter(item => frequentItems.includes(item))\n          .sort((a, b) => itemCounts[b] - itemCounts[a]);\n      }).filter(transaction => transaction.length > 0);\n      \n      // Step 4: Build unified FP-Tree\n      const fpTree = { \n        name: \"root\", \n        count: 0,\n        children: {},\n        nodeLinks: {} // Header table node links\n      };\n      \n      // Initialize header table\n      const headerTable = {};\n      frequentItems.forEach(item => {\n        headerTable[item] = {\n          count: itemCounts[item],\n          nodeLink: null\n        };\n      });\n      \n      // Insert a transaction into the FP-Tree\n      const insertTransaction = (transaction, tree, count = 1) => {\n        if (transaction.length === 0) return;\n        \n        const item = transaction[0];\n        \n        // Create node if it doesn't exist\n        if (!tree.children[item]) {\n          tree.children[item] = {\n            name: item,\n            count: 0,\n            children: {},\n            parent: tree,\n            nextSameItem: null\n          };\n          \n          // Update header table node links\n          if (!headerTable[item].nodeLink) {\n            headerTable[item].nodeLink = tree.children[item];\n          } else {\n            let current = headerTable[item].nodeLink;\n            while (current.nextSameItem) {\n              current = current.nextSameItem;\n            }\n            current.nextSameItem = tree.children[item];\n          }\n        }\n        \n        // Increment count\n        tree.children[item].count += count;\n        \n        // Insert remaining items\n        if (transaction.length > 1) {\n          insertTransaction(transaction.slice(1), tree.children[item], count);\n        }\n      };\n      \n      // Insert all transactions\n      orderedTransactions.forEach(transaction => {\n        insertTransaction(transaction, fpTree);\n      });\n      \n      // Step 5: Mine patterns using FP-Growth\n      const patterns = {};\n      \n      // Mine patterns with a suffix\n      const minePatterns = (headerTable, conditionalBase, suffix = [], parentSupport = totalTransactions) => {\n        // Get items in descending order of frequency\n        const items = Object.keys(headerTable).sort((a, b) => headerTable[b].count - headerTable[a].count);\n        \n        for (const item of items) {\n          // New frequent itemset found\n          const newSuffix = [item, ...suffix];\n          const supportCount = headerTable[item].count;\n          \n          // Calculate confidence for patterns with len > 1\n          const confidence = newSuffix.length > 1 ? supportCount / parentSupport : supportCount / totalTransactions;\n          \n          // Only include if confidence meets threshold\n          if (confidence >= minConfidence) {\n            // Store pattern\n            const patternKey = newSuffix.join('-');\n            patterns[patternKey] = {\n              items: newSuffix,\n              support: supportCount,\n              confidence: confidence\n            };\n            \n            // Build conditional pattern base\n            const conditionalPatternBase = [];\n            let node = headerTable[item].nodeLink;\n            \n            while (node) {\n              // Traverse upward to get the path\n              const path = [];\n              let prefixSupport = node.count;\n              let parent = node.parent;\n              \n              while (parent && parent.name !== \"root\") {\n                path.unshift(parent.name);\n                parent = parent.parent;\n              }\n              \n              if (path.length > 0) {\n                conditionalPatternBase.push({\n                  path,\n                  count: prefixSupport\n                });\n              }\n              \n              node = node.nextSameItem;\n            }\n            \n            // Build conditional FP-Tree\n            if (conditionalPatternBase.length > 0) {\n              const newConditionalBase = {};\n              \n              // Count items in the conditional pattern base\n              conditionalPatternBase.forEach(({path, count}) => {\n                path.forEach(pathItem => {\n                  newConditionalBase[pathItem] = (newConditionalBase[pathItem] || 0) + count;\n                });\n              });\n              \n              // Filter items by minimum support\n              const newHeaderTable = {};\n              Object.keys(newConditionalBase).forEach(item => {\n                if (newConditionalBase[item] >= minSupportCount) {\n                  newHeaderTable[item] = {\n                    count: newConditionalBase[item],\n                    nodeLink: null\n                  };\n                }\n              });\n              \n              // Recursively mine with the new conditional tree, up to depth 5\n              if (Object.keys(newHeaderTable).length > 0 && newSuffix.length < 5) {\n                minePatterns(newHeaderTable, conditionalPatternBase, newSuffix, supportCount);\n              }\n            }\n          }\n        }\n      };\n      \n      // Start mining\n      minePatterns(headerTable, []);\n      \n      // Build tree from patterns\n      const buildTree = (patterns) => {\n        const result = [];\n        const itemMap = {};\n        \n        // Group by first item\n        Object.values(patterns).forEach(pattern => {\n          if (pattern.items.length > 0) {\n            const firstItem = pattern.items[0];\n            if (!itemMap[firstItem]) {\n              itemMap[firstItem] = {\n                id: firstItem,\n                name: firstItem,\n                support: itemCounts[firstItem],\n                confidence: itemCounts[firstItem] / totalTransactions,\n                children: []\n              };\n              result.push(itemMap[firstItem]);\n            }\n            \n            // Add subsequent items as children\n            if (pattern.items.length > 1) {\n              let currentNode = itemMap[firstItem];\n              let currentPath = firstItem;\n              \n              for (let i = 1; i < pattern.items.length; i++) {\n                const currentItem = pattern.items[i];\n                currentPath = `${currentPath}-${currentItem}`;\n                \n                // Check if child already exists\n                let childNode = currentNode.children.find(child => child.name === currentItem);\n                \n                if (!childNode) {\n                  childNode = {\n                    id: currentPath,\n                    name: currentItem,\n                    support: pattern.support,\n                    confidence: pattern.confidence,\n                    children: []\n                  };\n                  currentNode.children.push(childNode);\n                }\n                \n                currentNode = childNode;\n              }\n            }\n          }\n        });\n        \n        return result;\n      };\n      \n      const result = buildTree(patterns);\n      setMiningData(result);\n    }\n    \n    // Initialize expanded state for visualization\n    const initialExpanded = { 'root': true };\n    // Auto-expand some top nodes for better initial view\n    if (miningData && miningData.length > 0) {\n      // Expand first 3 level 1 nodes\n      miningData.slice(0, 3).forEach(node => {\n        initialExpanded[node.id] = true;\n      });\n    }\n    setExpandedNodes(initialExpanded);\n  };\n\n  // Switch between algorithms\n  const switchAlgorithm = (algo) => {\n    setAlgorithm(algo);\n  };\n  \n  // Change minimum support threshold\n  const handleSupportChange = (e) => {\n    const value = parseFloat(e.target.value);\n    if (!isNaN(value) && value > 0 && value <= 1) {\n      setMinSupport(value);\n    }\n  };\n  \n  // Change minimum confidence threshold\n  const handleConfidenceChange = (e) => {\n    const value = parseFloat(e.target.value);\n    if (!isNaN(value) && value > 0 && value <= 1) {\n      setMinConfidence(value);\n    }\n  };\n\n  const handleCombinationClick = (combination) => {\n    if (onCombinationSelect) {\n      onCombinationSelect(combination);\n    }\n  };\n\n  // Function to toggle node expansion\n  const toggleNode = (nodeId) => {\n    setExpandedNodes(prev => ({\n      ...prev,\n      [nodeId]: !prev[nodeId]\n    }));\n  };\n\n  // Function to render header_group as tags\n  const renderHeaderGroupAsTags = (headerGroup) => {\n    if (!headerGroup) return null;\n    \n    const headers = headerGroup.split('|');\n    return (\n      <div className=\"header-tags\">\n        {headers.map((header, index) => (\n          <span key={index} className=\"similarity-tag\">{header}</span>\n        ))}\n      </div>\n    );\n  };\n\n  const toggleTestMode = () => {\n    const newTestMode = !testMode;\n    setTestMode(newTestMode);\n    \n    // Log the test mode state change\n    console.log(`Test mode ${newTestMode ? 'enabled' : 'disabled'}`);\n    \n    // Clear combination data when turning off test mode if no channel/header selected\n    if (!newTestMode && (!channel || !selectedHeader)) {\n      setCombinationHeaders([]);\n      setMiningData(null);\n    }\n  };\n\n  return (\n    <div className=\"column-container\">\n      <div className=\"column-title-container\">\n        <h2 className=\"column-title\">\n          {!testMode && selectedHeader \n            ? `헤더명 조합 목록: ${selectedHeader}` \n            : '헤더명 조합 목록'}\n        </h2>\n        <div className=\"test-mode-toggle\">\n          <label className=\"toggle-label\">\n            <span>Test Mode {testMode ? 'ON' : 'OFF'}</span>\n            <input \n              type=\"checkbox\" \n              checked={testMode}\n              onChange={toggleTestMode}\n            />\n            <span className=\"toggle-slider\"></span>\n          </label>\n        </div>\n      </div>\n      \n      <div className=\"tabs\">\n        <button \n          className={`tab ${activeTab === 'combination' ? 'active' : ''}`}\n          onClick={() => setActiveTab('combination')}\n        >\n          조합뷰\n        </button>\n        <button \n          className={`tab ${activeTab === 'mining' ? 'active' : ''}`}\n          onClick={() => setActiveTab('mining')}\n        >\n          마이닝뷰\n        </button>\n      </div>\n      \n      {activeTab === 'combination' ? (\n        <div className=\"tab-content\">\n          {loading ? (\n            <div className=\"loading\">로딩 중...</div>\n          ) : error ? (\n            <div className=\"error\">에러: {error}</div>\n          ) : combinationHeaders.length > 0 ? (\n            <div className=\"column-content\">\n              {combinationHeaders.map((item, index) => (\n                <div\n                  key={index}\n                  className={`column-item ${selectedCombination === item.header_group ? 'selected' : ''}`}\n                  onClick={() => handleCombinationClick(item.header_group)}\n                >\n                  {renderHeaderGroupAsTags(item.header_group)}\n                </div>\n              ))}\n            </div>\n          ) : (\n            <div className=\"column-empty\">\n              {testMode \n                ? \"테스트 모드가 활성화되었습니다.\" \n                : \"채널과 헤더를 선택해주세요.\"}\n            </div>\n          )}\n        </div>\n      ) : (\n        <div className=\"tab-content\">\n          {loading ? (\n            <div className=\"loading\">로딩 중...</div>\n          ) : error ? (\n            <div className=\"error\">에러: {error}</div>\n          ) : miningData ? (\n            <div className=\"mining-view\">\n              <div className=\"mining-controls\">\n                <div className=\"algorithm-selector\">\n                  <button \n                    className={`algorithm-btn ${algorithm === 'eclat' ? 'active' : ''}`} \n                    onClick={() => switchAlgorithm('eclat')}\n                  >\n                    Eclat 알고리즘\n                  </button>\n                  <button \n                    className={`algorithm-btn ${algorithm === 'fpgrowth' ? 'active' : ''}`} \n                    onClick={() => switchAlgorithm('fpgrowth')}\n                  >\n                    FP-Growth 알고리즘\n                  </button>\n                </div>\n                <div className=\"thresholds-control\">\n                  <div className=\"threshold-item\">\n                    <label>최소 지지도: {(minSupport * 100).toFixed(0)}%</label>\n                    <input \n                      type=\"range\" \n                      min=\"0.05\" \n                      max=\"0.5\" \n                      step=\"0.05\" \n                      value={minSupport}\n                      onChange={handleSupportChange}\n                    />\n                  </div>\n                  <div className=\"threshold-item\">\n                    <label>최소 신뢰도: {(minConfidence * 100).toFixed(0)}%</label>\n                    <input \n                      type=\"range\" \n                      min=\"0.1\" \n                      max=\"0.9\" \n                      step=\"0.1\" \n                      value={minConfidence}\n                      onChange={handleConfidenceChange}\n                    />\n                  </div>\n                </div>\n              </div>\n              \n              <div className=\"mining-tree-container\">\n                <svg \n                  className=\"mining-tree-svg\" \n                  ref={svgRef} \n                  width=\"100%\" \n                  height=\"400\"\n                ></svg>\n              </div>\n              \n              <div className=\"mining-explanation\">\n                <p>{algorithm === 'eclat' ? 'Eclat' : 'FP-Growth'} 알고리즘 패턴 시각화:</p>\n                <ul>\n                  <li>패턴 클릭: 하위 패턴 확장/축소</li>\n                  <li>마우스 오버: 패턴 경로 하이라이트</li>\n                  <li>숫자: 패턴 발생 빈도</li>\n                  <li>단계별 색상: 패턴의 깊이(항목 개수)</li>\n                </ul>\n              </div>\n            </div>\n          ) : (\n            <div className=\"column-empty\">\n              {testMode \n                ? \"마이닝 데이터를 로딩 중입니다...\" \n                : \"채널과 헤더를 선택하면 마이닝 결과가 표시됩니다.\"}\n            </div>\n          )}\n        </div>\n      )}\n\n      <style jsx>{`\n        .mining-view {\n          height: 100%;\n          display: flex;\n          flex-direction: column;\n        }\n        \n        .mining-controls {\n          display: flex;\n          flex-direction: column;\n          gap: 8px;\n          margin-bottom: 12px;\n          background-color: #f8f8f8;\n          border-radius: 4px;\n          padding: 8px;\n        }\n        \n        .algorithm-selector {\n          display: flex;\n          gap: 8px;\n        }\n        \n        .algorithm-btn {\n          background: #f0f0f0;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          padding: 4px 8px;\n          font-size: 12px;\n          cursor: pointer;\n        }\n        \n        .algorithm-btn.active {\n          background: #4682b4;\n          color: white;\n          border-color: #4682b4;\n        }\n        \n        .thresholds-control {\n          display: flex;\n          flex-direction: column;\n          gap: 6px;\n        }\n        \n        .threshold-item {\n          display: flex;\n          flex-direction: column;\n          font-size: 11px;\n        }\n        \n        .threshold-item label {\n          margin-bottom: 2px;\n        }\n        \n        .threshold-item input {\n          width: 100%;\n        }\n        \n        .mining-tree-container {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: auto;\n          background-color: #fafafa;\n          flex-grow: 1;\n          min-height: 300px;\n        }\n        \n        .mining-explanation {\n          margin-top: 10px;\n          font-size: 11px;\n          color: #666;\n          background-color: #f9f9f9;\n          border-radius: 4px;\n          padding: 6px 10px;\n        }\n        \n        .mining-explanation ul {\n          padding-left: 16px;\n          margin: 4px 0;\n        }\n        \n        .mining-explanation p {\n          margin: 4px 0;\n          font-weight: bold;\n        }\n        \n        .mining-explanation li {\n          margin-bottom: 2px;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default HeaderCombinationList; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
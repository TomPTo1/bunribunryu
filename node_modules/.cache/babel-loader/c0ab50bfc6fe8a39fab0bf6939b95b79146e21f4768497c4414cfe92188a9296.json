{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js\";\nimport React from 'react';\nimport './SeparationClassifier.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DataDisplay = ({\n  processedData,\n  flattenData\n}) => {\n  if (!processedData) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"no-data\",\n      children: \"\\uCC98\\uB9AC\\uD560 \\uB370\\uC774\\uD130\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 12\n    }, this);\n  }\n\n  // Check if the text is a duplicated string (contains itself twice)\n  const isDuplicatedText = text => {\n    if (typeof text !== 'string' || text.length === 0) return false;\n    const halfLength = Math.floor(text.length / 2);\n    const firstHalf = text.substring(0, halfLength);\n    return text.includes(firstHalf + firstHalf);\n  };\n\n  // Remove duplicated text if needed\n  const cleanDuplicatedText = text => {\n    if (!isDuplicatedText(text)) return text;\n    const halfLength = Math.floor(text.length / 2);\n    return text.substring(0, halfLength);\n  };\n\n  // Helper function to render a tag with appropriate styling\n  const renderTag = (value, source, key) => {\n    const className = `value-tag ${source === 'bracket' ? 'bracket-source' : source === 'clean-text' ? 'text-source' : 'delimiter-source'}`;\n    return /*#__PURE__*/_jsxDEV(\"span\", {\n      className: className,\n      children: typeof value === 'string' ? value : value.value\n    }, key, false, {\n      fileName: _jsxFileName,\n      lineNumber: 32,\n      columnNumber: 7\n    }, this);\n  };\n\n  // Check if a value is in any group from the substring grouping\n  const isValueInGroups = (value, groupData) => {\n    if (!groupData || !groupData.groups) return false;\n\n    // Check if it's in the ungrouped list\n    if (groupData.ungrouped && groupData.ungrouped.includes(value)) {\n      return false;\n    }\n\n    // Check each group\n    for (const substring in groupData.groups) {\n      if (substring === '__ungrouped__') continue; // Skip the special ungrouped key\n\n      const group = groupData.groups[substring];\n      if (group.includes(value)) {\n        return true;\n      }\n    }\n\n    // If not found in any group, check if it starts with or ends with any substring\n    for (const substringObj of groupData.substrings || []) {\n      const substring = substringObj.substring;\n      if (value.startsWith(substring) || value.endsWith(substring)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = row => {\n    // Handle substring grouping data\n    if (row.type === 'substring-grouping') {\n      return renderSubstringGroupingView(row);\n    }\n\n    // Clean up potentially duplicated original text\n    let original = row.original;\n    if (isDuplicatedText(original)) {\n      original = cleanDuplicatedText(original);\n    }\n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row);\n    }\n\n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"unprocessed-tag\",\n        children: original\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 87,\n        columnNumber: 14\n      }, this);\n    }\n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n\n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"unprocessed-tag\",\n            children: unprocessedText\n          }, `unproc-${idx}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 104,\n            columnNumber: 13\n          }, this));\n        }\n\n        // Add the processed bracket content\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"value-tag bracket-source\",\n          children: match.value\n        }, `proc-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 110,\n          columnNumber: 11\n        }, this));\n        lastIndex = match.endIndex;\n      });\n\n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"unprocessed-tag\",\n          children: original.substring(lastIndex)\n        }, \"unproc-last\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 119,\n          columnNumber: 11\n        }, this));\n      }\n      return result;\n    } else if (row.type === 'delimiter-separation') {\n      // For delimiter separation, we should preserve bracket positions from previous step\n      const elements = [];\n\n      // First, separate out the bracket parts (they have position info)\n      const bracketParts = row.separated.filter(part => part.source === 'bracket' && part.bracketInfo).sort((a, b) => a.bracketInfo.startIndex - b.bracketInfo.startIndex);\n\n      // Non-bracket parts go in between or around bracket parts\n      const otherParts = row.separated.filter(part => part.source !== 'bracket');\n\n      // Use a simple approach: put brackets in their exact positions, other parts elsewhere\n      let lastEnd = 0;\n      let otherIndex = 0;\n\n      // First, place any non-bracket parts that come before the first bracket\n      if (bracketParts.length > 0) {\n        const firstBracketStart = bracketParts[0].bracketInfo.startIndex;\n\n        // Add some non-bracket parts at the beginning if there's space\n        const beforeBracketText = original.substring(0, firstBracketStart).trim();\n        if (beforeBracketText.length > 0) {\n          // Look for matching non-bracket parts to put here\n          let foundMatchingPart = false;\n\n          // Try to find a matching part\n          for (let i = 0; i < otherParts.length; i++) {\n            const part = otherParts[i];\n            if (beforeBracketText.includes(part.value)) {\n              elements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n                className: `value-tag ${part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n                children: part.value\n              }, `other-${otherIndex}`, false, {\n                fileName: _jsxFileName,\n                lineNumber: 157,\n                columnNumber: 17\n              }, this));\n              otherIndex++;\n              otherParts.splice(i, 1); // Remove this part\n              foundMatchingPart = true;\n              i--; // Adjust index for removed item\n            }\n          }\n\n          // If no matching part found, show as unprocessed\n          if (!foundMatchingPart) {\n            elements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"unprocessed-tag\",\n              children: beforeBracketText\n            }, `unproc-start`, false, {\n              fileName: _jsxFileName,\n              lineNumber: 171,\n              columnNumber: 15\n            }, this));\n          }\n        }\n      }\n\n      // Place bracket parts in their exact positions\n      bracketParts.forEach((bracketPart, idx) => {\n        const bracketInfo = bracketPart.bracketInfo;\n\n        // Add the bracket content\n        elements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"value-tag bracket-source\",\n          children: bracketPart.value\n        }, `bracket-${idx}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 183,\n          columnNumber: 11\n        }, this));\n\n        // Update the last position\n        lastEnd = bracketInfo.endIndex;\n\n        // If there's another bracket coming, check if we can fit other parts in between\n        if (idx < bracketParts.length - 1) {\n          const nextBracketStart = bracketParts[idx + 1].bracketInfo.startIndex;\n\n          // If there's space between brackets, add some non-bracket parts\n          if (nextBracketStart > lastEnd) {\n            const betweenText = original.substring(lastEnd, nextBracketStart).trim();\n            if (betweenText.length > 0) {\n              // Try to find matching parts for this space\n              let foundMatchingPart = false;\n\n              // Look for parts that might fit here\n              for (let i = 0; i < otherParts.length && i < 2; i++) {\n                // Limit to 2 parts\n                const part = otherParts[i];\n                if (betweenText.includes(part.value)) {\n                  elements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n                    className: `value-tag ${part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n                    children: part.value\n                  }, `between-${idx}-${i}`, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 208,\n                    columnNumber: 21\n                  }, this));\n                  otherParts.splice(i, 1); // Remove this part\n                  foundMatchingPart = true;\n                  i--; // Adjust index for removed item\n                }\n              }\n\n              // If no matching part found, show as unprocessed\n              if (!foundMatchingPart) {\n                elements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n                  className: \"unprocessed-tag\",\n                  children: betweenText\n                }, `unproc-${idx}`, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 221,\n                  columnNumber: 19\n                }, this));\n              }\n            }\n          }\n        }\n      });\n\n      // Add any text after the last bracket\n      if (lastEnd < original.length) {\n        const afterText = original.substring(lastEnd).trim();\n        if (afterText.length > 0) {\n          // Try to place remaining non-bracket parts\n          if (otherParts.length > 0) {\n            // Add remaining other parts\n            otherParts.forEach((part, idx) => {\n              elements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n                className: `value-tag ${part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n                children: part.value\n              }, `remaining-${idx}`, false, {\n                fileName: _jsxFileName,\n                lineNumber: 239,\n                columnNumber: 17\n              }, this));\n            });\n          } else {\n            // No parts left, show as unprocessed\n            elements.push(/*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"unprocessed-tag\",\n              children: afterText\n            }, \"unproc-end\", false, {\n              fileName: _jsxFileName,\n              lineNumber: 247,\n              columnNumber: 15\n            }, this));\n          }\n        }\n      }\n      return elements.length > 0 ? elements : renderSeparatedValues(row);\n    }\n\n    // Fallback to original display method\n    return renderSeparatedValues(row);\n  };\n\n  // Render substring grouping data with color-coded grouped vs ungrouped items\n  const renderSubstringGroupingView = row => {\n    // Check for separated data in both row.separated and row.previous.separated\n    const separatedData = row.separated || row.previous && row.previous.separated || [];\n    if (separatedData.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"no-values\",\n        children: \"\\uC774\\uC804 \\uB2E8\\uACC4\\uC758 \\uAC12\\uC774 \\uC5C6\\uC2B5\\uB2C8\\uB2E4\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 266,\n        columnNumber: 14\n      }, this);\n    }\n\n    // Count how many items are grouped and how many are ungrouped\n    let groupedCount = 0;\n    let ungroupedCount = 0;\n    const items = separatedData.map((item, idx) => {\n      const value = typeof item === 'string' ? item : item.value;\n      const isGrouped = isValueInGroups(value, row);\n\n      // Increment counter\n      if (isGrouped) {\n        groupedCount++;\n      } else {\n        ungroupedCount++;\n      }\n      const groupClass = isGrouped ? 'grouped' : 'ungrouped';\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: `value-tag ${groupClass}`,\n        title: isGrouped ? '그룹에 포함됨' : '그룹화되지 않음',\n        children: value\n      }, idx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 287,\n        columnNumber: 9\n      }, this);\n    });\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"substring-grouping-view\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"substring-grouping-stats\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"stats-item\",\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"stats-label\",\n            children: \"\\uADF8\\uB8F9\\uD654 \\uB428:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 301,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"stats-value grouped\",\n            children: groupedCount\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 302,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 300,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"stats-item\",\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"stats-label\",\n            children: \"\\uADF8\\uB8F9\\uD654\\uB418\\uC9C0 \\uC54A\\uC74C:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 305,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"stats-value ungrouped\",\n            children: ungroupedCount\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 306,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 304,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 299,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"substring-grouping-items\",\n        children: items\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 309,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 298,\n      columnNumber: 7\n    }, this);\n  };\n  const renderSeparatedValues = row => {\n    if (!row.separated || row.separated.length === 0) {\n      return /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"no-values\",\n        children: \"\\uCD94\\uCD9C\\uB41C \\uAC12 \\uC5C6\\uC74C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 318,\n        columnNumber: 14\n      }, this);\n    }\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"value-tag\",\n        children: val\n      }, idx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 324,\n        columnNumber: 9\n      }, this));\n    }\n\n    // New format (with metadata)\n    return row.separated.map((item, idx) => /*#__PURE__*/_jsxDEV(\"span\", {\n      className: `value-tag ${item.source === 'bracket' ? 'bracket-source' : item.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`,\n      children: typeof item === 'string' ? item : item.value\n    }, idx, false, {\n      fileName: _jsxFileName,\n      lineNumber: 330,\n      columnNumber: 7\n    }, this));\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"data-display\",\n    children: /*#__PURE__*/_jsxDEV(\"table\", {\n      className: \"data-table\",\n      children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n        children: flattenData(processedData).map((row, index) => /*#__PURE__*/_jsxDEV(\"tr\", {\n          children: /*#__PURE__*/_jsxDEV(\"td\", {\n            className: \"enhanced-view\",\n            children: renderEnhancedView(row)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 346,\n            columnNumber: 15\n          }, this)\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 345,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 343,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 342,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 341,\n    columnNumber: 5\n  }, this);\n};\n_c = DataDisplay;\nexport default DataDisplay;\nvar _c;\n$RefreshReg$(_c, \"DataDisplay\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","DataDisplay","processedData","flattenData","className","children","fileName","_jsxFileName","lineNumber","columnNumber","isDuplicatedText","text","length","halfLength","Math","floor","firstHalf","substring","includes","cleanDuplicatedText","renderTag","value","source","key","isValueInGroups","groupData","groups","ungrouped","group","substringObj","substrings","startsWith","endsWith","renderEnhancedView","row","type","renderSubstringGroupingView","original","renderSeparatedValues","separated","result","lastIndex","matchDetails","sortedMatches","sort","a","b","startIndex","forEach","match","idx","unprocessedText","push","endIndex","elements","bracketParts","filter","part","bracketInfo","otherParts","lastEnd","otherIndex","firstBracketStart","beforeBracketText","trim","foundMatchingPart","i","splice","bracketPart","nextBracketStart","betweenText","afterText","separatedData","previous","groupedCount","ungroupedCount","items","map","item","isGrouped","groupClass","title","Array","isArray","every","v","val","index","_c","$RefreshReg$"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/DataDisplay.js"],"sourcesContent":["import React from 'react';\nimport './SeparationClassifier.css';\n\nconst DataDisplay = ({ processedData, flattenData }) => {\n  if (!processedData) {\n    return <div className=\"no-data\">처리할 데이터가 없습니다</div>;\n  }\n\n  // Check if the text is a duplicated string (contains itself twice)\n  const isDuplicatedText = (text) => {\n    if (typeof text !== 'string' || text.length === 0) return false;\n    const halfLength = Math.floor(text.length / 2);\n    const firstHalf = text.substring(0, halfLength);\n    return text.includes(firstHalf + firstHalf);\n  };\n\n  // Remove duplicated text if needed\n  const cleanDuplicatedText = (text) => {\n    if (!isDuplicatedText(text)) return text;\n    const halfLength = Math.floor(text.length / 2);\n    return text.substring(0, halfLength);\n  };\n\n  // Helper function to render a tag with appropriate styling\n  const renderTag = (value, source, key) => {\n    const className = `value-tag ${\n      source === 'bracket' ? 'bracket-source' : \n      source === 'clean-text' ? 'text-source' : 'delimiter-source'\n    }`;\n    \n    return (\n      <span key={key} className={className}>\n        {typeof value === 'string' ? value : value.value}\n      </span>\n    );\n  };\n  \n  // Check if a value is in any group from the substring grouping\n  const isValueInGroups = (value, groupData) => {\n    if (!groupData || !groupData.groups) return false;\n    \n    // Check if it's in the ungrouped list\n    if (groupData.ungrouped && groupData.ungrouped.includes(value)) {\n      return false;\n    }\n    \n    // Check each group\n    for (const substring in groupData.groups) {\n      if (substring === '__ungrouped__') continue; // Skip the special ungrouped key\n      \n      const group = groupData.groups[substring];\n      if (group.includes(value)) {\n        return true;\n      }\n    }\n    \n    // If not found in any group, check if it starts with or ends with any substring\n    for (const substringObj of (groupData.substrings || [])) {\n      const substring = substringObj.substring;\n      if (value.startsWith(substring) || value.endsWith(substring)) {\n        return true;\n      }\n    }\n    \n    return false;\n  };\n\n  // Render the enhanced view that shows processed and unprocessed parts in sequence\n  const renderEnhancedView = (row) => {\n    // Handle substring grouping data\n    if (row.type === 'substring-grouping') {\n      return renderSubstringGroupingView(row);\n    }\n    \n    // Clean up potentially duplicated original text\n    let original = row.original;\n    if (isDuplicatedText(original)) {\n      original = cleanDuplicatedText(original);\n    }\n    \n    if (!original || typeof original !== 'string') {\n      return renderSeparatedValues(row);\n    }\n    \n    // If no separation has happened yet\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"unprocessed-tag\">{original}</span>;\n    }\n    \n    if (row.type === 'bracket-separation') {\n      // For bracket separation, highlight brackets and content\n      let result = [];\n      let lastIndex = 0;\n      \n      // Sort match details by start index if available\n      const matchDetails = row.matchDetails || [];\n      const sortedMatches = [...matchDetails].sort((a, b) => a.startIndex - b.startIndex);\n      \n      sortedMatches.forEach((match, idx) => {\n        // Add unprocessed text before this match\n        if (match.startIndex > lastIndex) {\n          const unprocessedText = original.substring(lastIndex, match.startIndex);\n          result.push(\n            <span key={`unproc-${idx}`} className=\"unprocessed-tag\">{unprocessedText}</span>\n          );\n        }\n        \n        // Add the processed bracket content\n        result.push(\n          <span key={`proc-${idx}`} className=\"value-tag bracket-source\">{match.value}</span>\n        );\n        \n        lastIndex = match.endIndex;\n      });\n      \n      // Add any remaining text\n      if (lastIndex < original.length) {\n        result.push(\n          <span key=\"unproc-last\" className=\"unprocessed-tag\">\n            {original.substring(lastIndex)}\n          </span>\n        );\n      }\n      \n      return result;\n    } else if (row.type === 'delimiter-separation') {\n      // For delimiter separation, we should preserve bracket positions from previous step\n      const elements = [];\n      \n      // First, separate out the bracket parts (they have position info)\n      const bracketParts = row.separated\n        .filter(part => part.source === 'bracket' && part.bracketInfo)\n        .sort((a, b) => a.bracketInfo.startIndex - b.bracketInfo.startIndex);\n      \n      // Non-bracket parts go in between or around bracket parts\n      const otherParts = row.separated.filter(part => part.source !== 'bracket');\n      \n      // Use a simple approach: put brackets in their exact positions, other parts elsewhere\n      let lastEnd = 0;\n      let otherIndex = 0;\n      \n      // First, place any non-bracket parts that come before the first bracket\n      if (bracketParts.length > 0) {\n        const firstBracketStart = bracketParts[0].bracketInfo.startIndex;\n        \n        // Add some non-bracket parts at the beginning if there's space\n        const beforeBracketText = original.substring(0, firstBracketStart).trim();\n        if (beforeBracketText.length > 0) {\n          // Look for matching non-bracket parts to put here\n          let foundMatchingPart = false;\n          \n          // Try to find a matching part\n          for (let i = 0; i < otherParts.length; i++) {\n            const part = otherParts[i];\n            if (beforeBracketText.includes(part.value)) {\n              elements.push(\n                <span key={`other-${otherIndex}`} className={`value-tag ${part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}>\n                  {part.value}\n                </span>\n              );\n              otherIndex++;\n              otherParts.splice(i, 1); // Remove this part\n              foundMatchingPart = true;\n              i--; // Adjust index for removed item\n            }\n          }\n          \n          // If no matching part found, show as unprocessed\n          if (!foundMatchingPart) {\n            elements.push(\n              <span key={`unproc-start`} className=\"unprocessed-tag\">{beforeBracketText}</span>\n            );\n          }\n        }\n      }\n      \n      // Place bracket parts in their exact positions\n      bracketParts.forEach((bracketPart, idx) => {\n        const bracketInfo = bracketPart.bracketInfo;\n        \n        // Add the bracket content\n        elements.push(\n          <span key={`bracket-${idx}`} className=\"value-tag bracket-source\">\n            {bracketPart.value}\n          </span>\n        );\n        \n        // Update the last position\n        lastEnd = bracketInfo.endIndex;\n        \n        // If there's another bracket coming, check if we can fit other parts in between\n        if (idx < bracketParts.length - 1) {\n          const nextBracketStart = bracketParts[idx + 1].bracketInfo.startIndex;\n          \n          // If there's space between brackets, add some non-bracket parts\n          if (nextBracketStart > lastEnd) {\n            const betweenText = original.substring(lastEnd, nextBracketStart).trim();\n            \n            if (betweenText.length > 0) {\n              // Try to find matching parts for this space\n              let foundMatchingPart = false;\n              \n              // Look for parts that might fit here\n              for (let i = 0; i < otherParts.length && i < 2; i++) {  // Limit to 2 parts\n                const part = otherParts[i];\n                if (betweenText.includes(part.value)) {\n                  elements.push(\n                    <span key={`between-${idx}-${i}`} className={`value-tag ${part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}>\n                      {part.value}\n                    </span>\n                  );\n                  otherParts.splice(i, 1); // Remove this part\n                  foundMatchingPart = true;\n                  i--; // Adjust index for removed item\n                }\n              }\n              \n              // If no matching part found, show as unprocessed\n              if (!foundMatchingPart) {\n                elements.push(\n                  <span key={`unproc-${idx}`} className=\"unprocessed-tag\">{betweenText}</span>\n                );\n              }\n            }\n          }\n        }\n      });\n      \n      // Add any text after the last bracket\n      if (lastEnd < original.length) {\n        const afterText = original.substring(lastEnd).trim();\n        \n        if (afterText.length > 0) {\n          // Try to place remaining non-bracket parts\n          if (otherParts.length > 0) {\n            // Add remaining other parts\n            otherParts.forEach((part, idx) => {\n              elements.push(\n                <span key={`remaining-${idx}`} className={`value-tag ${part.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}>\n                  {part.value}\n                </span>\n              );\n            });\n          } else {\n            // No parts left, show as unprocessed\n            elements.push(\n              <span key=\"unproc-end\" className=\"unprocessed-tag\">{afterText}</span>\n            );\n          }\n        }\n      }\n      \n      return elements.length > 0 ? elements : renderSeparatedValues(row);\n    }\n    \n    // Fallback to original display method\n    return renderSeparatedValues(row);\n  };\n  \n  // Render substring grouping data with color-coded grouped vs ungrouped items\n  const renderSubstringGroupingView = (row) => {\n    // Check for separated data in both row.separated and row.previous.separated\n    const separatedData = row.separated || (row.previous && row.previous.separated) || [];\n    \n    if (separatedData.length === 0) {\n      return <span className=\"no-values\">이전 단계의 값이 없습니다</span>;\n    }\n    \n    // Count how many items are grouped and how many are ungrouped\n    let groupedCount = 0;\n    let ungroupedCount = 0;\n    \n    const items = separatedData.map((item, idx) => {\n      const value = typeof item === 'string' ? item : item.value;\n      const isGrouped = isValueInGroups(value, row);\n      \n      // Increment counter\n      if (isGrouped) {\n        groupedCount++;\n      } else {\n        ungroupedCount++;\n      }\n      \n      const groupClass = isGrouped ? 'grouped' : 'ungrouped';\n      \n      return (\n        <span \n          key={idx} \n          className={`value-tag ${groupClass}`}\n          title={isGrouped ? '그룹에 포함됨' : '그룹화되지 않음'}\n        >\n          {value}\n        </span>\n      );\n    });\n    \n    return (\n      <div className=\"substring-grouping-view\">\n        <div className=\"substring-grouping-stats\">\n          <div className=\"stats-item\">\n            <span className=\"stats-label\">그룹화 됨:</span>\n            <span className=\"stats-value grouped\">{groupedCount}</span>\n          </div>\n          <div className=\"stats-item\">\n            <span className=\"stats-label\">그룹화되지 않음:</span>\n            <span className=\"stats-value ungrouped\">{ungroupedCount}</span>\n          </div>\n        </div>\n        <div className=\"substring-grouping-items\">\n          {items}\n        </div>\n      </div>\n    );\n  };\n\n  const renderSeparatedValues = (row) => {\n    if (!row.separated || row.separated.length === 0) {\n      return <span className=\"no-values\">추출된 값 없음</span>;\n    }\n\n    if (Array.isArray(row.separated) && row.separated.every(v => typeof v === 'string')) {\n      // Old format (just strings)\n      return row.separated.map((val, idx) => (\n        <span key={idx} className=\"value-tag\">{val}</span>\n      ));\n    } \n    \n    // New format (with metadata)\n    return row.separated.map((item, idx) => (\n      <span \n        key={idx} \n        className={`value-tag ${item.source === 'bracket' ? 'bracket-source' : \n                              item.source === 'clean-text' ? 'text-source' : 'delimiter-source'}`}\n      >\n        {typeof item === 'string' ? item : item.value}\n      </span>\n    ));\n  };\n\n  return (\n    <div className=\"data-display\">\n      <table className=\"data-table\">\n        <tbody>\n          {flattenData(processedData).map((row, index) => (\n            <tr key={index}>\n              <td className=\"enhanced-view\">\n                {renderEnhancedView(row)}\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport default DataDisplay; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
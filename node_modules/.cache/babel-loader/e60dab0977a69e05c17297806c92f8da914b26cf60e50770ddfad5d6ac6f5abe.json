{"ast":null,"code":"var _jsxFileName = \"/Users/francesson/Documents/github/bunribunryu/src/components/browse/SeparationClassifier.js\";\nimport React from 'react';\nimport './SeparationClassifier.css';\n\n// Utility functions for text processing\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst textUtils = {\n  // String reversal utility\n  reverseString: str => str.split('').reverse().join(''),\n  // Extract tokens from data rows\n  extractTokens: dataRows => {\n    const bracketSet = new Set();\n    const valueSet = new Set();\n    dataRows.forEach(row => {\n      const cellValue = row[0];\n\n      // Skip empty/null values\n      if (cellValue === null || cellValue === undefined || String(cellValue).trim() === '') {\n        return;\n      }\n      const cellValueStr = String(cellValue);\n\n      // 1. Handle bracket content with regex\n      const bracketContentRegex = /\\(([^)]*)\\)|\\[([^\\]]*)\\]|\\{([^}]*)\\}/g;\n      let textWithoutBrackets = cellValueStr.replace(bracketContentRegex, (match, p1, p2, p3) => {\n        const content = p1 || p2 || p3;\n        if (content && content.trim()) {\n          bracketSet.add(content.trim());\n        }\n        return ' ';\n      });\n\n      // 2. Split by spaces and commas\n      const separatedValues = textWithoutBrackets.split(/[\\s,]+/).map(value => value.trim()).filter(value => value.length > 0);\n      separatedValues.forEach(value => {\n        if (value && value.trim()) {\n          valueSet.add(value.trim());\n        }\n      });\n    });\n    return {\n      bracketValues: Array.from(bracketSet).map(val => `[괄호] ${val}`),\n      normalValues: Array.from(valueSet)\n    };\n  },\n  // Find common substring patterns\n  findCommonSubstrings: (tokens, minLength = 1, minCount = 2, direction = 'any') => {\n    // Track substring frequencies\n    const substringFreq = {};\n\n    // Analyze all tokens\n    tokens.forEach(token => {\n      const cleanToken = token.replace('[괄호] ', '');\n\n      // Handle prefixes\n      if (direction === 'prefix' || direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          const substr = cleanToken.substring(0, len);\n          if (substr.length >= minLength) {\n            if (!substringFreq[substr]) {\n              substringFreq[substr] = {\n                count: 1,\n                tokens: [token],\n                direction: 'prefix'\n              };\n            } else if (!substringFreq[substr].tokens.includes(token)) {\n              substringFreq[substr].count++;\n              substringFreq[substr].tokens.push(token);\n              if (substringFreq[substr].direction !== 'prefix') {\n                substringFreq[substr].direction = 'both';\n              }\n            }\n          }\n        }\n      }\n\n      // Handle suffixes\n      if (direction === 'suffix' || direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          const substr = cleanToken.substring(cleanToken.length - len);\n          if (substr.length >= minLength) {\n            if (!substringFreq[substr]) {\n              substringFreq[substr] = {\n                count: 1,\n                tokens: [token],\n                direction: 'suffix'\n              };\n            } else if (!substringFreq[substr].tokens.includes(token)) {\n              substringFreq[substr].count++;\n              substringFreq[substr].tokens.push(token);\n              if (substringFreq[substr].direction !== 'suffix') {\n                substringFreq[substr].direction = 'both';\n              }\n            }\n          }\n        }\n      }\n\n      // Handle middle substrings\n      if (direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          for (let i = 1; i < cleanToken.length - len; i++) {\n            const substr = cleanToken.substring(i, i + len);\n            if (substr.length >= minLength) {\n              if (!substringFreq[substr]) {\n                substringFreq[substr] = {\n                  count: 1,\n                  tokens: [token],\n                  direction: 'middle'\n                };\n              } else if (!substringFreq[substr].tokens.includes(token)) {\n                substringFreq[substr].count++;\n                substringFreq[substr].tokens.push(token);\n                substringFreq[substr].direction = 'mixed';\n              }\n            }\n          }\n        }\n      }\n    });\n\n    // Filter and sort results\n    return Object.entries(substringFreq).filter(([substr, data]) => {\n      // Base filter: meet minimum count\n      const baseFilter = data.count >= minCount;\n\n      // Special handling for single characters\n      if (substr.length === 1) {\n        const coverage = data.tokens.length / tokens.length * 100;\n        return baseFilter && (coverage >= 30 || data.count >= 5);\n      }\n      return baseFilter;\n    }).sort((a, b) => {\n      // Sort by token count (descending)\n      const countDiff = b[1].count - a[1].count;\n      if (countDiff !== 0) return countDiff;\n\n      // Then by length (descending)\n      const lengthDiff = b[0].length - a[0].length;\n      if (lengthDiff !== 0) return lengthDiff;\n\n      // Finally by alphabetical order\n      return a[0].localeCompare(b[0]);\n    }).map(([substr, data]) => ({\n      substring: substr,\n      count: data.count,\n      tokens: data.tokens,\n      direction: data.direction,\n      percentCoverage: data.tokens.length / tokens.length * 100\n    }));\n  },\n  // Analyze compound word relationships\n  analyzeCompoundRelationships: tokens => {\n    const relationships = [];\n\n    // Compare all token pairs\n    for (let i = 0; i < tokens.length; i++) {\n      const token1 = tokens[i].replace('[괄호] ', '');\n      for (let j = 0; j < tokens.length; j++) {\n        if (i === j) continue;\n        const token2 = tokens[j].replace('[괄호] ', '');\n\n        // Check if token1 is part of token2\n        if (token2.includes(token1)) {\n          const position = token2.indexOf(token1);\n          const beforeChar = position > 0 ? token2[position - 1] : '';\n          const afterChar = position + token1.length < token2.length ? token2[position + token1.length] : '';\n\n          // Check if it's at a word boundary\n          const isWordBoundary = (position === 0 || beforeChar === ' ' || beforeChar === '-') && (position + token1.length === token2.length || afterChar === ' ' || afterChar === '-');\n          if (isWordBoundary || token1.length >= 2) {\n            relationships.push({\n              parent: tokens[j],\n              // Compound\n              child: tokens[i],\n              // Component\n              position: position // Position\n            });\n          }\n        }\n      }\n    }\n    return relationships;\n  },\n  // Select optimal substrings for grouping\n  selectOptimalSubstrings: (substrings, tokens, compoundRel, maxGroups = 10) => {\n    // Sort by coverage and importance\n    const sortedSubstrings = [...substrings].sort((a, b) => {\n      // Prioritize substrings that have compound relationships\n      const hasCompoundA = compoundRel.some(rel => rel.parent.includes(a.substring) || rel.child.includes(a.substring));\n      const hasCompoundB = compoundRel.some(rel => rel.parent.includes(b.substring) || rel.child.includes(b.substring));\n      if (hasCompoundA && !hasCompoundB) return -1;\n      if (!hasCompoundA && hasCompoundB) return 1;\n\n      // Score based on count and length^2\n      const scoreA = a.count * Math.pow(a.substring.length, 2);\n      const scoreB = b.count * Math.pow(b.substring.length, 2);\n      return scoreB - scoreA;\n    });\n    const selectedSubstrings = [];\n    const coveredTokens = new Set();\n\n    // Greedy selection\n    for (const substr of sortedSubstrings) {\n      // Check if this covers new tokens\n      const newCoverage = substr.tokens.some(token => !coveredTokens.has(token));\n\n      // Selection criteria\n      const isImportantSubstr = substr.substring.length >= 2 && substr.count >= 3;\n      const isHighSupportSingleChar = substr.substring.length === 1 && substr.count >= Math.max(4, tokens.length * 0.2);\n      if (newCoverage || isImportantSubstr || isHighSupportSingleChar) {\n        selectedSubstrings.push(substr);\n\n        // Update covered tokens\n        substr.tokens.forEach(token => coveredTokens.add(token));\n      }\n\n      // Limit groups\n      if (selectedSubstrings.length >= maxGroups) break;\n    }\n    return selectedSubstrings;\n  },\n  // Form compound word relationship groups\n  formCompoundGroups: relationships => {\n    // Group by parent token\n    const compoundGroups = {};\n    relationships.forEach(rel => {\n      const parentToken = rel.parent;\n      if (!compoundGroups[parentToken]) {\n        compoundGroups[parentToken] = {\n          parent: parentToken,\n          children: [rel.child],\n          positions: [rel.position]\n        };\n      } else if (!compoundGroups[parentToken].children.includes(rel.child)) {\n        compoundGroups[parentToken].children.push(rel.child);\n        compoundGroups[parentToken].positions.push(rel.position);\n      }\n    });\n\n    // Sort by number of children (descending)\n    return Object.values(compoundGroups).sort((a, b) => b.children.length - a.children.length).filter(group => group.children.length >= 2) // At least 2 children\n    .slice(0, 5); // Top 5 only\n  }\n};\n\n// Main component for classification results\nconst SeparationClassifier = ({\n  data,\n  onReset\n}) => {\n  // Empty data handling\n  if (!data || !data.rows || data.rows.length === 0) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"separation-empty\",\n      children: \"No data to classify\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 278,\n      columnNumber: 12\n    }, this);\n  }\n\n  // Process and classify the data\n  const processData = () => {\n    const {\n      bracketValues,\n      normalValues\n    } = textUtils.extractTokens(data.rows);\n\n    // No results case\n    if (bracketValues.length === 0 && normalValues.length === 0) {\n      return {\n        headers: [\"Group\", \"Token\"],\n        rows: [[\"\", \"분리된 값이 없습니다\"]]\n      };\n    }\n\n    // All tokens\n    const allMinTokens = [...bracketValues, ...normalValues];\n\n    // Analyze compound relationships\n    const compoundRelationships = textUtils.analyzeCompoundRelationships(allMinTokens);\n\n    // Get directional substrings\n    const prefixSubstrings = textUtils.findCommonSubstrings(allMinTokens, 1, 2, 'prefix');\n    const suffixSubstrings = textUtils.findCommonSubstrings(allMinTokens, 1, 2, 'suffix');\n\n    // Select optimal substrings\n    const optimalPrefixSubstrings = textUtils.selectOptimalSubstrings(prefixSubstrings, allMinTokens, compoundRelationships, 8);\n    const optimalSuffixSubstrings = textUtils.selectOptimalSubstrings(suffixSubstrings, allMinTokens, compoundRelationships, 8);\n\n    // Build compound groups\n    const compoundGroups = textUtils.formCompoundGroups(compoundRelationships);\n\n    // Build results data structure\n    const finalRows = [];\n\n    // 1. Prefix groups\n    finalRows.push([\"🌲 접두사 기준 그룹 (앞글자순)\", \"\"]);\n    optimalPrefixSubstrings.forEach(group => {\n      finalRows.push([`📌 앞부분: ${group.substring} (${group.count})`, \"\"]);\n      const groupTokens = group.tokens.sort((a, b) => {\n        const aIsBracket = a.startsWith('[괄호]');\n        const bIsBracket = b.startsWith('[괄호]');\n        if (aIsBracket && !bIsBracket) return -1;\n        if (!aIsBracket && bIsBracket) return 1;\n        return a.localeCompare(b);\n      });\n      groupTokens.forEach(token => {\n        finalRows.push([\"└─\", token]);\n      });\n      finalRows.push([\"\", \"\"]);\n    });\n\n    // 2. Suffix groups\n    finalRows.push([\"🌲 접미사 기준 그룹 (뒷글자순)\", \"\"]);\n    optimalSuffixSubstrings.forEach(group => {\n      finalRows.push([`📌 뒷부분: ${group.substring} (${group.count})`, \"\"]);\n      const groupTokens = group.tokens.sort((a, b) => {\n        const aIsBracket = a.startsWith('[괄호]');\n        const bIsBracket = b.startsWith('[괄호]');\n        if (aIsBracket && !bIsBracket) return -1;\n        if (!aIsBracket && bIsBracket) return 1;\n        return textUtils.reverseString(a.replace('[괄호] ', '')).localeCompare(textUtils.reverseString(b.replace('[괄호] ', '')));\n      });\n      groupTokens.forEach(token => {\n        finalRows.push([\"└─\", token]);\n      });\n      finalRows.push([\"\", \"\"]);\n    });\n\n    // 3. Compound relationships\n    if (compoundGroups.length > 0) {\n      finalRows.push([\"🌲 복합어 관계 그룹\", \"\"]);\n      compoundGroups.forEach(group => {\n        finalRows.push([`📌 복합어: ${group.parent.replace('[괄호] ', '')} (${group.children.length})`, group.parent]);\n        group.children.forEach((child, idx) => {\n          const position = group.positions[idx];\n          const parentClean = group.parent.replace('[괄호] ', '');\n          const childClean = child.replace('[괄호] ', '');\n          let positionMarker = '';\n          if (position === 0) {\n            positionMarker = '⬅️ 시작 부분';\n          } else if (position + childClean.length === parentClean.length) {\n            positionMarker = '➡️ 끝 부분';\n          } else {\n            positionMarker = '⬇️ 중간 부분';\n          }\n          finalRows.push([`└─ [${positionMarker}]`, child]);\n        });\n        finalRows.push([\"\", \"\"]);\n      });\n    }\n\n    // 4. Ungrouped tokens\n    const allGroupedTokens = new Set();\n    optimalPrefixSubstrings.forEach(group => group.tokens.forEach(token => allGroupedTokens.add(token)));\n    optimalSuffixSubstrings.forEach(group => group.tokens.forEach(token => allGroupedTokens.add(token)));\n    compoundGroups.forEach(group => {\n      allGroupedTokens.add(group.parent);\n      group.children.forEach(child => allGroupedTokens.add(child));\n    });\n    const ungroupedTokens = allMinTokens.filter(token => !allGroupedTokens.has(token)).sort();\n    if (ungroupedTokens.length > 0) {\n      finalRows.push([\"🌲 미분류 토큰\", \"\"]);\n      ungroupedTokens.forEach(token => {\n        finalRows.push([\"└─\", token]);\n      });\n    }\n    return {\n      headers: [\"Group\", \"Token\"],\n      rows: finalRows\n    };\n  };\n\n  // Processed classification data\n  const classificationData = processData();\n\n  // Render the classification results with improved UI\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"separation-classifier\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"classifier-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"\\uBD84\\uB9AC\\uBD84\\uB958 \\uACB0\\uACFC\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 434,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"reset-button\",\n        onClick: onReset,\n        title: \"\\uC6D0\\uBCF8 \\uB370\\uC774\\uD130\\uB85C \\uBCF5\\uC6D0\",\n        children: /*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\uD83D\\uDD04 \\uC6D0\\uBCF8\\uC73C\\uB85C \\uBCF5\\uC6D0\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 436,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 435,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 433,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"classification-results\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"results-table-wrapper\",\n        children: /*#__PURE__*/_jsxDEV(\"table\", {\n          className: \"classification-table\",\n          children: [/*#__PURE__*/_jsxDEV(\"thead\", {\n            children: /*#__PURE__*/_jsxDEV(\"tr\", {\n              children: classificationData.headers.map((header, idx) => /*#__PURE__*/_jsxDEV(\"th\", {\n                children: header\n              }, idx, false, {\n                fileName: _jsxFileName,\n                lineNumber: 446,\n                columnNumber: 19\n              }, this))\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 444,\n              columnNumber: 15\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 443,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"tbody\", {\n            children: classificationData.rows.map((row, rowIdx) => {\n              // Identify row types\n              const isTreeType = String(row[0]).startsWith('🌲');\n              const isGroupHeader = String(row[0]).startsWith('📌');\n              const isGroupItem = String(row[0]).startsWith('└─');\n\n              // Track current tree section\n              let treeTypeClass = '';\n              if (String(row[0]).includes('접두사')) {\n                treeTypeClass = 'prefix-tree';\n              } else if (String(row[0]).includes('접미사')) {\n                treeTypeClass = 'suffix-tree';\n              } else if (String(row[0]).includes('복합어')) {\n                treeTypeClass = 'compound-tree';\n              } else if (String(row[0]).includes('미분류')) {\n                treeTypeClass = 'ungrouped-tree';\n              }\n              return /*#__PURE__*/_jsxDEV(\"tr\", {\n                className: `\n                      ${isTreeType ? 'tree-type' : ''} \n                      ${isGroupHeader ? 'group-header' : ''} \n                      ${isGroupItem ? 'group-item' : ''}\n                      ${treeTypeClass}\n                    `,\n                children: row.map((cell, cellIdx) => {\n                  // Special handling for bracket content\n                  const isBracketContent = String(cell).startsWith('[괄호]');\n                  let displayContent = cell;\n                  if (isBracketContent) {\n                    displayContent = /*#__PURE__*/_jsxDEV(_Fragment, {\n                      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                        className: \"bracket-indicator\",\n                        children: \"\\u2282\\u2283\"\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 487,\n                        columnNumber: 29\n                      }, this), String(cell).replace('[괄호] ', '')]\n                    }, void 0, true);\n                  }\n\n                  // Tree type headers span columns\n                  if (isTreeType && cellIdx === 0) {\n                    return /*#__PURE__*/_jsxDEV(\"td\", {\n                      colSpan: \"2\",\n                      className: \"tree-type-header\",\n                      children: displayContent\n                    }, cellIdx, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 496,\n                      columnNumber: 27\n                    }, this);\n                  }\n\n                  // Position indicators in compound groups\n                  const isPositionIndicator = String(cell).includes('⬅️') || String(cell).includes('➡️') || String(cell).includes('⬇️');\n                  return /*#__PURE__*/_jsxDEV(\"td\", {\n                    className: `\n                            ${isGroupHeader && cellIdx === 0 ? 'group-header-cell' : ''} \n                            ${isGroupItem && cellIdx === 0 ? 'group-connector-cell' : ''}\n                            ${isBracketContent ? 'bracket-content-cell' : ''}\n                            ${isPositionIndicator ? 'position-indicator-cell' : ''}\n                          `,\n                    children: displayContent\n                  }, cellIdx, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 512,\n                    columnNumber: 25\n                  }, this);\n                })\n              }, rowIdx, false, {\n                fileName: _jsxFileName,\n                lineNumber: 470,\n                columnNumber: 19\n              }, this);\n            })\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 450,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 442,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 441,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 440,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 432,\n    columnNumber: 5\n  }, this);\n};\n_c = SeparationClassifier;\nexport default SeparationClassifier;\nvar _c;\n$RefreshReg$(_c, \"SeparationClassifier\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","Fragment","_Fragment","textUtils","reverseString","str","split","reverse","join","extractTokens","dataRows","bracketSet","Set","valueSet","forEach","row","cellValue","undefined","String","trim","cellValueStr","bracketContentRegex","textWithoutBrackets","replace","match","p1","p2","p3","content","add","separatedValues","map","value","filter","length","bracketValues","Array","from","val","normalValues","findCommonSubstrings","tokens","minLength","minCount","direction","substringFreq","token","cleanToken","len","substr","substring","count","includes","push","i","Object","entries","data","baseFilter","coverage","sort","a","b","countDiff","lengthDiff","localeCompare","percentCoverage","analyzeCompoundRelationships","relationships","token1","j","token2","position","indexOf","beforeChar","afterChar","isWordBoundary","parent","child","selectOptimalSubstrings","substrings","compoundRel","maxGroups","sortedSubstrings","hasCompoundA","some","rel","hasCompoundB","scoreA","Math","pow","scoreB","selectedSubstrings","coveredTokens","newCoverage","has","isImportantSubstr","isHighSupportSingleChar","max","formCompoundGroups","compoundGroups","parentToken","children","positions","values","group","slice","SeparationClassifier","onReset","rows","className","fileName","_jsxFileName","lineNumber","columnNumber","processData","headers","allMinTokens","compoundRelationships","prefixSubstrings","suffixSubstrings","optimalPrefixSubstrings","optimalSuffixSubstrings","finalRows","groupTokens","aIsBracket","startsWith","bIsBracket","idx","parentClean","childClean","positionMarker","allGroupedTokens","ungroupedTokens","classificationData","onClick","title","header","rowIdx","isTreeType","isGroupHeader","isGroupItem","treeTypeClass","cell","cellIdx","isBracketContent","displayContent","colSpan","isPositionIndicator","_c","$RefreshReg$"],"sources":["/Users/francesson/Documents/github/bunribunryu/src/components/browse/SeparationClassifier.js"],"sourcesContent":["import React from 'react';\nimport './SeparationClassifier.css';\n\n// Utility functions for text processing\nconst textUtils = {\n  // String reversal utility\n  reverseString: (str) => str.split('').reverse().join(''),\n  \n  // Extract tokens from data rows\n  extractTokens: (dataRows) => {\n    const bracketSet = new Set();\n    const valueSet = new Set();\n    \n    dataRows.forEach(row => {\n      const cellValue = row[0];\n      \n      // Skip empty/null values\n      if (cellValue === null || cellValue === undefined || String(cellValue).trim() === '') {\n        return;\n      }\n      \n      const cellValueStr = String(cellValue);\n      \n      // 1. Handle bracket content with regex\n      const bracketContentRegex = /\\(([^)]*)\\)|\\[([^\\]]*)\\]|\\{([^}]*)\\}/g;\n      let textWithoutBrackets = cellValueStr.replace(bracketContentRegex, (match, p1, p2, p3) => {\n        const content = p1 || p2 || p3; \n        if (content && content.trim()) {\n          bracketSet.add(content.trim());\n        }\n        return ' '; \n      });\n      \n      // 2. Split by spaces and commas\n      const separatedValues = textWithoutBrackets\n        .split(/[\\s,]+/)\n        .map(value => value.trim())\n        .filter(value => value.length > 0);\n      \n      separatedValues.forEach(value => {\n        if (value && value.trim()) {\n          valueSet.add(value.trim());\n        }\n      });\n    });\n    \n    return {\n      bracketValues: Array.from(bracketSet).map(val => `[괄호] ${val}`),\n      normalValues: Array.from(valueSet),\n    };\n  },\n  \n  // Find common substring patterns\n  findCommonSubstrings: (tokens, minLength = 1, minCount = 2, direction = 'any') => {\n    // Track substring frequencies\n    const substringFreq = {};\n    \n    // Analyze all tokens\n    tokens.forEach(token => {\n      const cleanToken = token.replace('[괄호] ', '');\n      \n      // Handle prefixes\n      if (direction === 'prefix' || direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          const substr = cleanToken.substring(0, len);\n          if (substr.length >= minLength) {\n            if (!substringFreq[substr]) {\n              substringFreq[substr] = { \n                count: 1, \n                tokens: [token],\n                direction: 'prefix'\n              };\n            } else if (!substringFreq[substr].tokens.includes(token)) {\n              substringFreq[substr].count++;\n              substringFreq[substr].tokens.push(token);\n              if (substringFreq[substr].direction !== 'prefix') {\n                substringFreq[substr].direction = 'both';\n              }\n            }\n          }\n        }\n      }\n      \n      // Handle suffixes\n      if (direction === 'suffix' || direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          const substr = cleanToken.substring(cleanToken.length - len);\n          if (substr.length >= minLength) {\n            if (!substringFreq[substr]) {\n              substringFreq[substr] = { \n                count: 1, \n                tokens: [token],\n                direction: 'suffix'\n              };\n            } else if (!substringFreq[substr].tokens.includes(token)) {\n              substringFreq[substr].count++;\n              substringFreq[substr].tokens.push(token);\n              if (substringFreq[substr].direction !== 'suffix') {\n                substringFreq[substr].direction = 'both';\n              }\n            }\n          }\n        }\n      }\n      \n      // Handle middle substrings\n      if (direction === 'any') {\n        for (let len = minLength; len <= cleanToken.length; len++) {\n          for (let i = 1; i < cleanToken.length - len; i++) {\n            const substr = cleanToken.substring(i, i + len);\n            if (substr.length >= minLength) {\n              if (!substringFreq[substr]) {\n                substringFreq[substr] = { \n                  count: 1, \n                  tokens: [token],\n                  direction: 'middle'\n                };\n              } else if (!substringFreq[substr].tokens.includes(token)) {\n                substringFreq[substr].count++;\n                substringFreq[substr].tokens.push(token);\n                substringFreq[substr].direction = 'mixed';\n              }\n            }\n          }\n        }\n      }\n    });\n    \n    // Filter and sort results\n    return Object.entries(substringFreq)\n      .filter(([substr, data]) => {\n        // Base filter: meet minimum count\n        const baseFilter = data.count >= minCount;\n        \n        // Special handling for single characters\n        if (substr.length === 1) {\n          const coverage = (data.tokens.length / tokens.length) * 100;\n          return baseFilter && (coverage >= 30 || data.count >= 5);\n        }\n        \n        return baseFilter;\n      })\n      .sort((a, b) => {\n        // Sort by token count (descending)\n        const countDiff = b[1].count - a[1].count;\n        if (countDiff !== 0) return countDiff;\n        \n        // Then by length (descending)\n        const lengthDiff = b[0].length - a[0].length;\n        if (lengthDiff !== 0) return lengthDiff;\n        \n        // Finally by alphabetical order\n        return a[0].localeCompare(b[0]);\n      })\n      .map(([substr, data]) => ({\n        substring: substr,\n        count: data.count,\n        tokens: data.tokens,\n        direction: data.direction,\n        percentCoverage: (data.tokens.length / tokens.length) * 100\n      }));\n  },\n  \n  // Analyze compound word relationships\n  analyzeCompoundRelationships: (tokens) => {\n    const relationships = [];\n    \n    // Compare all token pairs\n    for (let i = 0; i < tokens.length; i++) {\n      const token1 = tokens[i].replace('[괄호] ', '');\n      \n      for (let j = 0; j < tokens.length; j++) {\n        if (i === j) continue;\n        \n        const token2 = tokens[j].replace('[괄호] ', '');\n        \n        // Check if token1 is part of token2\n        if (token2.includes(token1)) {\n          const position = token2.indexOf(token1);\n          const beforeChar = position > 0 ? token2[position - 1] : '';\n          const afterChar = position + token1.length < token2.length ? token2[position + token1.length] : '';\n          \n          // Check if it's at a word boundary\n          const isWordBoundary = (position === 0 || beforeChar === ' ' || beforeChar === '-') &&\n                                (position + token1.length === token2.length || afterChar === ' ' || afterChar === '-');\n          \n          if (isWordBoundary || token1.length >= 2) {\n            relationships.push({\n              parent: tokens[j],   // Compound\n              child: tokens[i],    // Component\n              position: position   // Position\n            });\n          }\n        }\n      }\n    }\n    \n    return relationships;\n  },\n  \n  // Select optimal substrings for grouping\n  selectOptimalSubstrings: (substrings, tokens, compoundRel, maxGroups = 10) => {\n    // Sort by coverage and importance\n    const sortedSubstrings = [...substrings]\n      .sort((a, b) => {\n        // Prioritize substrings that have compound relationships\n        const hasCompoundA = compoundRel.some(rel => \n          rel.parent.includes(a.substring) || rel.child.includes(a.substring));\n        const hasCompoundB = compoundRel.some(rel => \n          rel.parent.includes(b.substring) || rel.child.includes(b.substring));\n        \n        if (hasCompoundA && !hasCompoundB) return -1;\n        if (!hasCompoundA && hasCompoundB) return 1;\n        \n        // Score based on count and length^2\n        const scoreA = a.count * Math.pow(a.substring.length, 2);\n        const scoreB = b.count * Math.pow(b.substring.length, 2);\n        return scoreB - scoreA;\n      });\n    \n    const selectedSubstrings = [];\n    const coveredTokens = new Set();\n    \n    // Greedy selection\n    for (const substr of sortedSubstrings) {\n      // Check if this covers new tokens\n      const newCoverage = substr.tokens.some(token => !coveredTokens.has(token));\n      \n      // Selection criteria\n      const isImportantSubstr = substr.substring.length >= 2 && substr.count >= 3;\n      const isHighSupportSingleChar = substr.substring.length === 1 && substr.count >= Math.max(4, tokens.length * 0.2);\n      \n      if (newCoverage || isImportantSubstr || isHighSupportSingleChar) {\n        selectedSubstrings.push(substr);\n        \n        // Update covered tokens\n        substr.tokens.forEach(token => coveredTokens.add(token));\n      }\n      \n      // Limit groups\n      if (selectedSubstrings.length >= maxGroups) break;\n    }\n    \n    return selectedSubstrings;\n  },\n  \n  // Form compound word relationship groups\n  formCompoundGroups: (relationships) => {\n    // Group by parent token\n    const compoundGroups = {};\n    \n    relationships.forEach(rel => {\n      const parentToken = rel.parent;\n      if (!compoundGroups[parentToken]) {\n        compoundGroups[parentToken] = {\n          parent: parentToken,\n          children: [rel.child],\n          positions: [rel.position]\n        };\n      } else if (!compoundGroups[parentToken].children.includes(rel.child)) {\n        compoundGroups[parentToken].children.push(rel.child);\n        compoundGroups[parentToken].positions.push(rel.position);\n      }\n    });\n    \n    // Sort by number of children (descending)\n    return Object.values(compoundGroups)\n      .sort((a, b) => b.children.length - a.children.length)\n      .filter(group => group.children.length >= 2) // At least 2 children\n      .slice(0, 5); // Top 5 only\n  }\n};\n\n// Main component for classification results\nconst SeparationClassifier = ({ data, onReset }) => {\n  // Empty data handling\n  if (!data || !data.rows || data.rows.length === 0) {\n    return <div className=\"separation-empty\">No data to classify</div>;\n  }\n  \n  // Process and classify the data\n  const processData = () => {\n    const { bracketValues, normalValues } = textUtils.extractTokens(data.rows);\n    \n    // No results case\n    if (bracketValues.length === 0 && normalValues.length === 0) {\n      return {\n        headers: [\"Group\", \"Token\"],\n        rows: [[\"\", \"분리된 값이 없습니다\"]]\n      };\n    }\n    \n    // All tokens\n    const allMinTokens = [...bracketValues, ...normalValues];\n    \n    // Analyze compound relationships\n    const compoundRelationships = textUtils.analyzeCompoundRelationships(allMinTokens);\n    \n    // Get directional substrings\n    const prefixSubstrings = textUtils.findCommonSubstrings(allMinTokens, 1, 2, 'prefix');\n    const suffixSubstrings = textUtils.findCommonSubstrings(allMinTokens, 1, 2, 'suffix');\n    \n    // Select optimal substrings\n    const optimalPrefixSubstrings = textUtils.selectOptimalSubstrings(\n      prefixSubstrings, allMinTokens, compoundRelationships, 8\n    );\n    const optimalSuffixSubstrings = textUtils.selectOptimalSubstrings(\n      suffixSubstrings, allMinTokens, compoundRelationships, 8\n    );\n    \n    // Build compound groups\n    const compoundGroups = textUtils.formCompoundGroups(compoundRelationships);\n    \n    // Build results data structure\n    const finalRows = [];\n    \n    // 1. Prefix groups\n    finalRows.push([\"🌲 접두사 기준 그룹 (앞글자순)\", \"\"]);\n    \n    optimalPrefixSubstrings.forEach(group => {\n      finalRows.push([`📌 앞부분: ${group.substring} (${group.count})`, \"\"]);\n      \n      const groupTokens = group.tokens.sort((a, b) => {\n        const aIsBracket = a.startsWith('[괄호]');\n        const bIsBracket = b.startsWith('[괄호]');\n        \n        if (aIsBracket && !bIsBracket) return -1;\n        if (!aIsBracket && bIsBracket) return 1;\n        \n        return a.localeCompare(b);\n      });\n      \n      groupTokens.forEach(token => {\n        finalRows.push([\"└─\", token]);\n      });\n      \n      finalRows.push([\"\", \"\"]);\n    });\n    \n    // 2. Suffix groups\n    finalRows.push([\"🌲 접미사 기준 그룹 (뒷글자순)\", \"\"]);\n    \n    optimalSuffixSubstrings.forEach(group => {\n      finalRows.push([`📌 뒷부분: ${group.substring} (${group.count})`, \"\"]);\n      \n      const groupTokens = group.tokens.sort((a, b) => {\n        const aIsBracket = a.startsWith('[괄호]');\n        const bIsBracket = b.startsWith('[괄호]');\n        \n        if (aIsBracket && !bIsBracket) return -1;\n        if (!aIsBracket && bIsBracket) return 1;\n        \n        return textUtils.reverseString(a.replace('[괄호] ', '')).localeCompare(\n          textUtils.reverseString(b.replace('[괄호] ', ''))\n        );\n      });\n      \n      groupTokens.forEach(token => {\n        finalRows.push([\"└─\", token]);\n      });\n      \n      finalRows.push([\"\", \"\"]);\n    });\n    \n    // 3. Compound relationships\n    if (compoundGroups.length > 0) {\n      finalRows.push([\"🌲 복합어 관계 그룹\", \"\"]);\n      \n      compoundGroups.forEach(group => {\n        finalRows.push([\n          `📌 복합어: ${group.parent.replace('[괄호] ', '')} (${group.children.length})`, \n          group.parent\n        ]);\n        \n        group.children.forEach((child, idx) => {\n          const position = group.positions[idx];\n          const parentClean = group.parent.replace('[괄호] ', '');\n          const childClean = child.replace('[괄호] ', '');\n          \n          let positionMarker = '';\n          if (position === 0) {\n            positionMarker = '⬅️ 시작 부분';\n          } else if (position + childClean.length === parentClean.length) {\n            positionMarker = '➡️ 끝 부분';\n          } else {\n            positionMarker = '⬇️ 중간 부분';\n          }\n          \n          finalRows.push([`└─ [${positionMarker}]`, child]);\n        });\n        \n        finalRows.push([\"\", \"\"]);\n      });\n    }\n    \n    // 4. Ungrouped tokens\n    const allGroupedTokens = new Set();\n    \n    optimalPrefixSubstrings.forEach(group => \n      group.tokens.forEach(token => allGroupedTokens.add(token)));\n    \n    optimalSuffixSubstrings.forEach(group => \n      group.tokens.forEach(token => allGroupedTokens.add(token)));\n    \n    compoundGroups.forEach(group => {\n      allGroupedTokens.add(group.parent);\n      group.children.forEach(child => allGroupedTokens.add(child));\n    });\n    \n    const ungroupedTokens = allMinTokens\n      .filter(token => !allGroupedTokens.has(token))\n      .sort();\n    \n    if (ungroupedTokens.length > 0) {\n      finalRows.push([\"🌲 미분류 토큰\", \"\"]);\n      ungroupedTokens.forEach(token => {\n        finalRows.push([\"└─\", token]);\n      });\n    }\n    \n    return {\n      headers: [\"Group\", \"Token\"],\n      rows: finalRows\n    };\n  };\n  \n  // Processed classification data\n  const classificationData = processData();\n  \n  // Render the classification results with improved UI\n  return (\n    <div className=\"separation-classifier\">\n      <div className=\"classifier-header\">\n        <h3>분리분류 결과</h3>\n        <button className=\"reset-button\" onClick={onReset} title=\"원본 데이터로 복원\">\n          <span>🔄 원본으로 복원</span>\n        </button>\n      </div>\n      \n      <div className=\"classification-results\">\n        <div className=\"results-table-wrapper\">\n          <table className=\"classification-table\">\n            <thead>\n              <tr>\n                {classificationData.headers.map((header, idx) => (\n                  <th key={idx}>{header}</th>\n                ))}\n              </tr>\n            </thead>\n            <tbody>\n              {classificationData.rows.map((row, rowIdx) => {\n                // Identify row types\n                const isTreeType = String(row[0]).startsWith('🌲');\n                const isGroupHeader = String(row[0]).startsWith('📌');\n                const isGroupItem = String(row[0]).startsWith('└─');\n                \n                // Track current tree section\n                let treeTypeClass = '';\n                if (String(row[0]).includes('접두사')) {\n                  treeTypeClass = 'prefix-tree';\n                } else if (String(row[0]).includes('접미사')) {\n                  treeTypeClass = 'suffix-tree';\n                } else if (String(row[0]).includes('복합어')) {\n                  treeTypeClass = 'compound-tree';\n                } else if (String(row[0]).includes('미분류')) {\n                  treeTypeClass = 'ungrouped-tree';\n                }\n                \n                return (\n                  <tr \n                    key={rowIdx} \n                    className={`\n                      ${isTreeType ? 'tree-type' : ''} \n                      ${isGroupHeader ? 'group-header' : ''} \n                      ${isGroupItem ? 'group-item' : ''}\n                      ${treeTypeClass}\n                    `}\n                  >\n                    {row.map((cell, cellIdx) => {\n                      // Special handling for bracket content\n                      const isBracketContent = String(cell).startsWith('[괄호]');\n                      let displayContent = cell;\n                      \n                      if (isBracketContent) {\n                        displayContent = (\n                          <>\n                            <span className=\"bracket-indicator\">⊂⊃</span>\n                            {String(cell).replace('[괄호] ', '')}\n                          </>\n                        );\n                      }\n                      \n                      // Tree type headers span columns\n                      if (isTreeType && cellIdx === 0) {\n                        return (\n                          <td \n                            key={cellIdx}\n                            colSpan=\"2\" \n                            className=\"tree-type-header\"\n                          >\n                            {displayContent}\n                          </td>\n                        );\n                      }\n                      \n                      // Position indicators in compound groups\n                      const isPositionIndicator = String(cell).includes('⬅️') || \n                                                String(cell).includes('➡️') || \n                                                String(cell).includes('⬇️');\n                      \n                      return (\n                        <td \n                          key={cellIdx} \n                          className={`\n                            ${isGroupHeader && cellIdx === 0 ? 'group-header-cell' : ''} \n                            ${isGroupItem && cellIdx === 0 ? 'group-connector-cell' : ''}\n                            ${isBracketContent ? 'bracket-content-cell' : ''}\n                            ${isPositionIndicator ? 'position-indicator-cell' : ''}\n                          `}\n                        >\n                          {displayContent}\n                        </td>\n                      );\n                    })}\n                  </tr>\n                );\n              })}\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SeparationClassifier; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}